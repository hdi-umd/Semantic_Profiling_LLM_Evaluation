[{"query": "what's the production budget for movies in different years", "Relevant data columns": ["Production Budget", "Release Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Release Year')['Production Budget'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Movie gross and budge relationship based on genre", "Relevant data columns": ["Major Genre", "Worldwide Gross", "Production Budget"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlation", "dependency"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to perform aggregation on the data by genre or plot individual points.", "Ambiguity resolution": "Group movies by genre and compute aggregate metrics for worldwide gross and production budget.", "Data transformations": "genre_gross_budget_data = df.groupby('Major Genre')[['Worldwide Gross', 'Production Budget']].agg(['mean', std'])", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me imdb rating versus rotten tomatoes rating", "Relevant data columns": ["IMDB Rating", "Rotten Tomatoes Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating','IMDB Rating']] ", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What creative type of movie had the highest production budget for each content rating", "Relevant data columns": ["Creative Type", "Production Budget", "Content Rating"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["filter", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df.groupby('Content Rating')['Production Budget'].idxmax()]", "Data transformation operation": ["groupby", "idxmax"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between production budget and worldwide gross for each major genre", "Relevant data columns": ["Production Budget", "Worldwide Gross", "Major Genre"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["relationship"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Major Genre')[['Production Budget', 'Worldwide Gross']].plot(kind='scatter')", "Data transformation operation": ["groupby", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between release year and average production budget", "Relevant data columns": ["Release Year", "Production Budget"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value", "correlation analysis"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "budget_by_year = df.groupby('Release Year')['Production Budget'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What major genre had the highest average worldwide gross", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_avg = df.groupby('Major Genre')['Worldwide Gross'].mean().reset_index()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What major genre had the lowest average worldwide gross", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_avg = df.groupby('Major Genre')['Worldwide Gross'].mean()", "Data transformation operation": ["groupby", "average"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much did average worldwide gross vary by major genre", "Relevant data columns": ["Worldwide Gross", "Major Genre"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_avg = df.groupby('Major Genre')['Worldwide Gross'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many movies are there are of each creative type", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["count", "grouping"], "Low-level visualization task classification": ["inferred", "synonym"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.value_counts('Creative Type')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which creative type had the fewest movies", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "creative_type_counts = df['Creative Type'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the total worldwide gross for each major genre across time", "Relevant data columns": ["Worldwide Gross", "Major Genre", "Release Year"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["summarize", "group by", "dependency"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether to consider only unique genres or combine sub-genres under their respective parent genres.", "Ambiguity resolution": "Combine sub-genres under their respective parent genres", "Data transformations": "genre_gross_df = df.groupby(['Release Year', 'Major Genre'])['Worldwide Gross'].sum().reset_index()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a relationship between production budget and worldwide gross for each content rating", "Relevant data columns": ["Production Budget", "Worldwide Gross", "Content Rating"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["relationship"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Content Rating')[['Production Budget', 'Worldwide Gross']].corr()", "Data transformation operation": ["groupby", "correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the distribution of running times for each movie", "Relevant data columns": ["Running Time"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Title', 'Running Time']].groupby('Running Time')['Title'].count().reset_index(name='Count')", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a relationship between IMDB rating and rotten tomatoes rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Movie run time distribution", "Relevant data columns": ["Running Time"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Running Time']].describe()", "Data transformation operation": ["summary_statistics"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How production budge changes over release years", "Relevant data columns": ["Production Budget", "Release Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Release Year', 'Production Budget']].groupby('Release Year')['Production Budget'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What was the average production budget of movies by year", "Relevant data columns": ["Production Budget", "Release Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value", "grouping"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_grouped = df.groupby('Release Year')['Production Budget'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What's the average production budget of the different rated movies, separated by creative type", "Relevant data columns": ["Production Budget", "Content Rating", "Creative Type"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compute derived value", "grouping"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['Content Rating', 'Creative Type'])['Production Budget'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which genre movie makes most worldwide gross", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_df = df.groupby('Major Genre')['Worldwide Gross'].sum().reset_index()", "Data transformation operation": ["groupby", "sum", "reset_index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are IMDb rating and rotten tomatoes rating related", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].corr()", "Data transformation operation": ["calculate_correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the worldwide gross distribution per genre", "Relevant data columns": ["Worldwide Gross", "Major Genre"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate the worldwide gross by genre or simply show the distribution.", "Ambiguity resolution": "Aggregate the worldwide gross by major genres.", "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].describe()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what's the breakdown of production budget by creative type per content rating", "Relevant data columns": ["Production Budget", "Creative Type", "Content Rating"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["retrieve value", "grouping"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether the result should be aggregated by sum or average.", "Ambiguity resolution": "Use aggregation function to combine production budgets", "Data transformations": "df.pivot_table(index='Content Rating', columns='Creative Type', values='Production Budget', aggfunc='sum')", "Data transformation operation": ["pivot", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how does Rotten Tomatoes Rating change as IMDB Rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the total worldwide gross earned by each major genre and content rating", "Relevant data columns": ["Worldwide Gross", "Major Genre", "Content Rating"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["aggregation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross = df.groupby(['Major Genre', 'Content Rating'])['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much did each type of movie earn in across the whole world", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize", "compute derived value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross = df.groupby('Major Genre')['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much money did movies of each genre and rating make", "Relevant data columns": ["Major Genre", "Content Rating", "Worldwide Gross"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to aggregate the worldwide gross by genre, by rating, or both.", " Ambiguity resolution": "Perform aggregation by genre and then by rating within each genre.", "Data transformations": "genre_gross = df.groupby(['Major Genre'])['Worldwide Gross'].sum(); rated_genre_gross = df.groupby(['Major Genre', 'Content Rating'])['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What was the average budget for each content rating and creative type, as multiple column charts", "Relevant data columns": ["Content Rating", "Creative Type", "Production Budget"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["aggregation", "categorization", "relationship"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether the average budget should be calculated separately for each combination of content rating and creative type, or jointly.", "Ambiguity resolution": "Calculate separate averages for each unique pair of content rating and creative type", "Data transformations": "df.groupby(['Content Rating', 'Creative Type'])['Production Budget'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average production budget in each year", "Relevant data columns": ["Release Year", "Production Budget"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Release Year')['Production Budget'].mean()", "Data transformation operation": ["groupby", "average"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Compare imdb rating to rotten tomatoes rating", "Relevant data columns": ["IMDB Rating", "Rotten Tomatoes Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the query wants to visualize the ratings directly or analyze their differences.", "Ambiguity resolution": "Visualize both ratings separately and compute their difference to explore relationships between them.", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].plot(kind='scatter')", "Data transformation operation": ["visualize"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which creative types have the most movies", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need to count distinct movie titles under each creative type or just get the total number of rows corresponding to each creative type.", "Ambiguity resolution": "Count distinct movie titles under each creative type", "Data transformations": "creative_type_counts = df['Creative Type'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "On average, how much was earned by movies of each genre", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value", "grouping"], "Low-level visualization task classification": ["inferred", "synonym"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the question refers to a simple mean or a more complex aggregation method such as median or weighted average.", "Ambiguity resolution": "Use mean as the default aggregation method unless specified otherwise", "Data transformations": "genre_gross_avg = df.groupby('Major Genre')['Worldwide Gross'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many movies are of each length", "Relevant data columns": ["Running Time"], "Data column classification": ["keyword"], "Low-level visualization task": ["histogram", "bar chart"], "Low-level visualization task classification": ["inferred", "synonym"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Running Time').size()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What was the average worldwide gross of movies by genre", "Relevant data columns": ["Worldwide Gross", "Major Genre"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["aggregate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].mean()", "Data transformation operation": ["groupby", "average"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much did major genres gross in total", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the question refers to aggregating by unique genre categories or treating sub-genres separately.", "Ambiguity resolution": "Treat sub-genres separately and aggregate by unique genre categories.", "Data transformations": "genre_gross_df = df.groupby('Major Genre')['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what's the distribution of running times by movie", "Relevant data columns": ["Running Time", "Title"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Title', 'Running Time']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many movies are there in 20 minute bins of running time", "Relevant data columns": ["Running Time"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what exactly constitutes a bin of 20 minutes.", "Ambiguity resolution": "Divide the range of running times into discrete intervals of 20 minutes each.", "Data transformations": "bins = [x for x in range(min(df['Running Time']), max(df['Running Time']) + 21, 20)]; binned_data = df.assign(Bin=[(rt - 1) // 20 for rt in df['Running Time']])", "Data transformation operation": ["create_bins", "assign_bin_to_each_row"], "New Column Name": "Bin", "Derivation Specification": "(rt - 1) // 20 where rt is Running Time", "Missing Data Column": ""}, {"query": "how many movies are there for each creative type", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["count", "grouping"], "Low-level visualization task classification": ["inferred", "synonym"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Creative Type')['Title'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which creative types had the most movies", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.value_counts('Creative Type')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Show me the variation in the amount ordered by different entities in different orders", "Relevant data columns": ["Production Budget", "Title", "Major Genre", "Release Year"], "Data column classification": ["inferred", "inferred", "keyword", "inferred"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what type of variation is requested (e.g., change over time, distribution across genres)", "Ambiguity resolution": "Assume variation refers to differences in production budget across different entities such as genre, release year, and title", "Data transformations": "df[['Production Budget', 'Major Genre', 'Release Year']].groupby(['Major Genre', 'Release Year']).agg(['mean', std'])", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "relation between rotten tomatoes and IMDB ratings", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "worldwide gross for each genre for each year 1995 to now", "Relevant data columns": ["Release Year", "Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize", "compare", "dependency"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the result should be aggregated by sum or average.", "Ambiguity resolution": "Assume aggregation by sum since we want total worldwide gross.", "Data transformations": "genre_year_gross = df.groupby(['Release Year', 'Major Genre'])['Worldwide Gross'].sum().reset_index()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many films of each creative type", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["count", "group by"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Creative Type')['Title'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a correlation between acceleration and horsepower", "Relevant data columns": ["timeto60", "hp"], "Data column classification": ["synonym", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the user wants to see the raw data points or a statistical measure of correlation.", "Ambiguity resolution": "Show scatter plot with regression line", "Data transformations": "df[['timeto60', 'hp']].corr()", "Data transformation operation": ["calculate_correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many heavy cars are in the dataset", "Relevant data columns": ["weightlbs"], "Data column classification": ["keyword"], "Low-level visualization task": ["filter", "count"], "Low-level visualization task classification": ["explicit", "explicit"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear what constitutes a 'heavy' car.", "Ambiguity resolution": "Define a threshold for 'heavy' cars, say top 50% by weight.", "Data transformations": "heavy_cars = df[df['weightlbs'] > df['weightlbs'].quantile(0.5)]", "Data transformation operation": ["filter", "calculate quantile"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any American 5 cylinder cars", "Relevant data columns": ["cylinders", "country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['country']=='US.') & (df['cylinders']==5)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does displacement relate to fuel economy for cars from Europe v USA", "Relevant data columns": ["cubicinches", "mpg", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["correlation", "dependency"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_europe = df[df['country']=='Europe']; df_usa = df[df['country']=='US']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which countries have the highest acceleration for cars of different cylinders", "Relevant data columns": ["timeto60", "cylinders", "country"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compare", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need to consider average or overall highest acceleration for each cylinder type.", "Ambiguity resolution": "Consider both average and overall highest acceleration for each cylinder type.", "Data transformations": "avg_acceleration_by_cylinder_country = df.groupby(['cylinders', 'country'])['timeto60'].mean().reset_index(); max_acceleration_by_cylinder_country = df.loc[df.groupby(['cylinders', 'country'])['timeto60'].idxmin()]; combined_result = avg_acceleration_by_cylinder_country.merge(max_acceleration_by_cylinder_country, on=['cylinders', 'country'])", "Data transformation operation": ["groupby", "aggregate", "merge"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the correlation between displacement and MPG of cars with different origins", "Relevant data columns": ["cubicinches", "mpg", "country"], "Data column classification": ["synonym", "keyword", "data value mention"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_country_mpg_corr = df.groupby('country')[['cubicinches', mpg']].corr()", "Data transformation operation": ["groupby", "calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "count the number of cars based on their origins", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.country.value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the correlation between horsepower and acceleration", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp', 'timeto60']].corr()", "Data transformation operation": ["calculate correlation coefficient"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a correlation between cars' horsepower and acceleration", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp','timeto60']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how does horsepower relate to acceleration for individual car models", "Relevant data columns": ["hp", "timeto60", "mpg", "cylinders", "year", "country"], "Data column classification": ["keyword", "keyword", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["relationship"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the relation between horsepower and acceleration refers to a general trend or a model-specific insight.", "Ambiguity resolution": "Generate scatter plot with regression line to visualize overall trend and explore individual car models.", "Data transformations": "df[['hp', 'timeto60']].dropna()", "Data transformation operation": ["select", "drop na"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Compare the number of models in USA, Japan and Europe", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "usa_models = df[df['country']=='US']; japan_models = df[df['country']=='Japan']; europe_models = df[df['country']=='Europe']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Does higher horsepower mean lower acceleration", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp','timeto60']] ", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many cylinders do cars manufactured in different countries have", "Relevant data columns": ["cylinders", "country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('country')['cylinders'].value_counts()", "Data transformation operation": ["groupby", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Compare car cylinder count against acceleration across countries", "Relevant data columns": ["cylinders", "timeto60", "country"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["compare", "correlate"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to aggregate data by country or perform separate comparisons for each country.", "Ambiguity resolution": "Perform separate correlations for each country", "Data transformations": "country_wise_data = df.groupby('country')[['cylinders', 'timeto60']].corr()", "Data transformation operation": ["groupby", "calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many cars do each country manufacture", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('country')['mpg'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What's the mileage for cars based on the number of cylinders present", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["relationship"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['mpg', 'cylinders']].groupby('cylinders')['mpg'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Does higher cylinder count mean mean lower mileage", "Relevant data columns": ["cylinders", "mpg"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['cylinders','mpg']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does mileage relate to cylinder count", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['mpg', 'cylinders']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average MPG for different cylinders", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('cylinders')['mpg'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relation between horsepower and acceleration", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp', 'timeto60']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how weight varies each year", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate weights by year or show individual points.", "Ambiguity resolution": "Aggregate weights by year to see overall variation.", "Data transformations": "df.groupby('year')['weightlbs'].plot()", "Data transformation operation": ["groupby", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How has horsepower changed over time by country", "Relevant data columns": ["hp", "year", "country"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["trend", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we want to see the change in average horsepower, total horsepower, or something else.", "Ambiguity resolution": "Assume we want to see the change in average horsepower.", "Data transformations": "df_grouped = df.groupby(['year', 'country'])['hp'].mean().reset_index()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Have cars gotten lighter over time", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['year','weightlbs']].sort_values(by='year')", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many models are proudced by each country", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["count", "grouping"], "Low-level visualization task classification": ["inferred", "column_name"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only unique car models or count duplicates.", "Ambiguity resolution": "Count the number of rows for each country assuming duplicate models exist.", "Data transformations": "df_country_count = df.groupby('country')['mpg'].count().reset_index(name='model_count')", "Data transformation operation": ["groupby", "count"], "New Column Name": "model_count", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average weight of cars over time", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider only certain types of cars or all cars in general.", "Ambiguity resolution": "Consider all available car models and their corresponding weights.", "Data transformations": "df[['year', 'weightlbs']].groupby('year')['weightlbs'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much do various cars weigh", "Relevant data columns": ["weightlbs"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['weightlbs']] ", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the range of weights for all cars", "Relevant data columns": ["weightlbs"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['weightlbs']].describe()", "Data transformation operation": ["describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "where do the cars originate from", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['country']].value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Compare AVG (Acceleration) with Cylinders | Segregate the cylinders by their origin", "Relevant data columns": ["timeto60", "cylinders", "country"], "Data column classification": ["synonym", "keyword", "keyword"], "Low-level visualization task": ["compare", "cluster"], "Low-level visualization task classification": ["keyword", "synonym"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the acceleration refers specifically to the time-to-60 metric or if other metrics could also be considered.", "Ambiguity resolution": "Use time-to-60 as the primary measure of acceleration.", "Data transformations": "avg_acceleration_by_cylinder_country = df.groupby(['cylinders', 'country'])['timeto60'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "avg_acceleration", "Derivation Specification": "df['avg_acceleration'] = df.groupby(['cylinders', 'country'])['timeto60'].transform('mean')", "Missing Data Column": ""}, {"query": "How does AVG (Weight) evolve over the years", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["parenthesis enclosed data value reference", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['year', 'weightlbs']].groupby('year')['weightlbs'].mean()", "Data transformation operation": ["groupby", "aggregate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does the acceleration of cars from different countries vary by the number of cylinders", "Relevant data columns": ["timeto60", "cylinders", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we want to see overall trends or compare between specific countries.", "Ambiguity resolution": "Compare the distribution of acceleration times across different numbers of cylinders for each country.", "Data transformations": "df.pivot_table(index='country', columns='cylinders', values='timeto60')", "Data transformation operation": ["pivot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does acceleration vary by weight for cars from different regions", "Relevant data columns": ["timeto60", "weightlbs", "country"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["correlation", "dependency"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to perform any data aggregation or filtering to prepare the data for visualization.", "Ambiguity resolution": "", "Data transformations": "df[['timeto60', 'weightlbs', 'country']].groupby('country')[['timeto60', 'weightlbs']].corr()", "Data transformation operation": ["groupby", "calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average MPG for cars with different cylinders", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('cylinders')['mpg'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does MPG vary by the number of cylinders in a car", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["trend", "compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['mpg','cylinders']].groupby('cylinders')['mpg'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does acceleration change with horsepower", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "synonym"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp','timeto60']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does acceleration behave compared to horsepower", "Relevant data columns": ["timeto60", "hp"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['timeto60', 'hp']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how does MPG compare to displacement, broken out by region", "Relevant data columns": ["mpg", "cubicinches", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["compare", "determine range"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('country')[['mpg', 'cubicinches']].plot(kind='scatter')", "Data transformation operation": ["groupby", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the breakdown of cars by the number of cylinders in each region", "Relevant data columns": ["cylinders", "country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["count distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['country', 'cylinders']).size()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many cars have various numbers of cylinders in each region", "Relevant data columns": ["cylinders", "country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["grouping", "count"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['country','cylinders']).size().reset_index(name='counts')", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average weight of cars by model year", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('year')['weightlbs'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How has the average weight of cars changed over the years", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value", "trend"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('year')['weightlbs'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much is the average of profit of each state", "Relevant data columns": ["Profit", "State"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider other factors like region or city while calculating the average profit by state.", "Ambiguity resolution": "Group by state only", "Data transformations": "state_profit_avg = df.groupby('State')['Profit'].mean()", "Data transformation operation": ["groupby", "average"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How do the company earn in each state", "Relevant data columns": ["Profit", "State"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('State')['Profit'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What were the total sales for each date in each category", "Relevant data columns": ["Order Date", "Sales", "Category"], "Data column classification": ["inferred", "keyword", "keyword"], "Low-level visualization task": ["summarize", "group by"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the order dates refer to exact dates or need to be grouped by month/year/day.", "Ambiguity resolution": "Group order dates by day/month/year depending on the level of aggregation required.", "Data transformations": "df.groupby([pd.Grouper(key='Order Date', freq='D'), 'Category'])['Sales'].sum()", "Data transformation operation": ["groupby", "aggregate sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much was sold each day for each category", "Relevant data columns": ["Sales", "Order Date", "Category"], "Data column classification": ["keyword", "inferred", "keyword"], "Low-level visualization task": ["aggregation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider only unique dates or also account for multiple orders made by customers on same date.", "Ambiguity resolution": "Use daily sales aggregation without considering customer-specific information.", "Data transformations": "import datetime; df['Order Date'] = pd.to_datetime(df['Order Date'], format='%m/%d/%y'); df_daily_sales = df.resample('D', on='Order Date')['Sales'].sum().reset_index()", "Data transformation operation": ["datetime conversion", "resample", "groupby", "sum"], "New Column Name": "Daily Sales", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between profit and sales", "Relevant data columns": ["Profit", "Sales"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["relationship"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Profit','Sales']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average profit of each ship mode divided by segment", "Relevant data columns": ["Ship Mode", "Segment", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['Ship Mode', 'Segment'])['Profit'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many orders were placed for each order quantity", "Relevant data columns": ["Quantity", "Order ID"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["count", "determine range"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Quantity')['Order ID'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between sales and profit for each region", "Relevant data columns": ["Sales", "Profit", "Region"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlation", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_sales_profit_df = df[['Region', 'Sales', 'Profit']].groupby('Region')['Sales', 'Profit'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many orders were placed for each sub-category", "Relevant data columns": ["Sub-Category", "Order ID"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["count", "group by"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "order_counts_by_sub_category = df.groupby('Sub-Category')['Order ID'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the total profit for each region, based on ship status", "Relevant data columns": ["Region", "Ship Status", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize", "group by"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_profit_ship_status = df.groupby(['Region', 'Ship Status'])['Profit'].sum()", "Data transformation operation": ["groupby", "summarize"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the sales trend of the different product categories", "Relevant data columns": ["Sales", "Product Name", "Sub-Category", "Category"], "Data column classification": ["keyword", "inferred", "inferred", "inferred"], "Low-level visualization task": ["trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider time-based trends (yearly/monthly) or just overall category-wise trends.", "Ambiguity resolution": "Consider both yearly/monthly trends and overall category-wise trends.", "Data transformations": "df[['Category', 'Sub-Category', 'Order Date', 'Sales']].groupby(['Category', 'Sub-Category', pd.Grouper(freq='M')['Order Date']]).agg({'Sales': ['sum', mean']})", "Data transformation operation": ["groupby", "resample", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many products have 3 or more quantity ordered", "Relevant data columns": ["Quantity", "Product Name"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["count"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['Quantity'] >= 3]; result = filtered_df.shape[0]", "Data transformation operation": ["filter", "shape"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many products are ordered in single quantity", "Relevant data columns": ["Quantity"], "Data column classification": ["keyword"], "Low-level visualization task": ["count"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "single_quantity_orders = df.loc[df['Quantity']==1]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What are the profits across different states", "Relevant data columns": ["Profit", "State"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['State', 'Profit']].groupby('State')['Profit'].sum()", "Data transformation operation": ["groupby", "summarize"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What product category has more orders placed", "Relevant data columns": ["Category", "Order ID"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["count"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to count unique order IDs or total quantity sold.", "Ambiguity resolution": "Count unique order IDs for each category.", "Data transformations": "category_counts = df.groupby('Category')['Order ID'].nunique()", "Data transformation operation": ["groupby", "nunique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "sales forecast between Jan 2016 and July 2017", "Relevant data columns": ["Order Date", "Sales", "Region"], "Data column classification": ["inferred", "keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only orders within this time range or also those placed outside but shipped/delivered during this period.", "Ambiguity resolution": "Filter out orders whose dates fall outside the specified range.", "Data transformations": "filtered_df = df[(df['Order Date'] >= '2016-01-01') & (df['Order Date'] <= '2017-07-31')] ; aggregated_df = filtered_df.groupby(['Region'])['Sales'].sum()", "Data transformation operation": ["filter", "groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "I want to know how many orders there are by the quantity of the order", "Relevant data columns": ["Quantity", "Order ID"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["count", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "order_quantity_count = df[['Quantity', 'Order ID']].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is our profit based on shipping mode by customer segment", "Relevant data columns": ["Profit", "Ship Mode", "Segment"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "profit_by_ship_mode_and_segment = df.groupby(['Ship Mode', 'Segment'])['Profit'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the sales vs profit ratio of the four regions", "Relevant data columns": ["Region", "Sales", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_sales_profit = df.groupby('Region')[['Sales', 'Profit']].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "sales_to_profit_ratio", "Derivation Specification": "region_sales_profit['sales_to_profit_ratio'] = region_sales_profit['Sales'] / region_sales_profit['Profit']", "Missing Data Column": ""}, {"query": "What is the average profit of each state", "Relevant data columns": ["State", "Profit"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the average profit refers to the total profit for each state or the average profit per order.", "Ambiguity resolution": "Assume we need the average profit per order for each state", "Data transformations": "df_group_state = df.groupby('State')['Profit'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the sales vs profit ratio of all the zones", "Relevant data columns": ["Sales", "Profit", "Region"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the query wants overall zone-wise sales-to-profit ratios or individual product-wise ratios.", "Ambiguity resolution": "Assuming the query wants zone-wise sales-to-profit ratios", "Data transformations": "df_grouped = df.groupby('Region')['Sales', 'Profit'].sum(); df_ratio = df_grouped['Sales'] / df_grouped['Profit'];", "Data transformation operation": ["groupby", "sum", "divide"], "New Column Name": "sales_to_profit_ratio", "Derivation Specification": "df_grouped['Sales'] / df_grouped['Profit']", "Missing Data Column": ""}, {"query": "how much is the profit for sales for each", "Relevant data columns": ["Profit", "Sales"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["summarize", "compute derived value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate by any particular category (e.g., region, product, customer)", "Ambiguity resolution": "Aggregate profits and sales at various levels of granularity (region, product, customer) to provide multiple insights.", "Data transformations": "df.groupby(['Region']).agg({'Profit': sum', 'Sales': sum'})", "Data transformation operation": ["groupby", "summarize"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the correlation between sales and profit by region", "Relevant data columns": ["Sales", "Profit", "Region"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "regional_correlation_data = df.groupby('Region')[['Sales', 'Profit']].corr()", "Data transformation operation": ["groupby", "calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What months are hurricanes most common", "Relevant data columns": ["month", "status", "category"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we're interested only in hurricane categories or all types of storms.", "Ambiguity resolution": "Filter out non-hurricane categories", "Data transformations": "hurricanes_only = df[(df['status']=='hurricane') | (df['category']>0)]; hurricane_months = hurricanes_only['month'].value_counts()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What does the distribution of the storms look like", "Relevant data columns": ["category", "status"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["distribution"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['category', status']].value_counts()", "Data transformation operation": ["aggregation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the most frequent status over the year", "Relevant data columns": ["status", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.value_counts('status').reset_index(name='counts')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the main factor depending on different status (wind, time, pressure, or etc)", "Relevant data columns": ["status", "category", "wind", "pressure"], "Data column classification": ["keyword", "keyword", "inferenced by mentioning factors", "inferenced by mentioning factors"], "Low-level visualization task": ["dependency"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import matplotlib.pyplot as plt\nfrom scipy.stats import pearsonr\nplt.figure(figsize=(10,6))\nfor col in ['wind','pressure']:\n\tcorr, _ = pearsonr(df.status, df[col])\n\tprint(f\"Correlation between Status and {col}: {corr}\")", "Data transformation operation": ["correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What was the name of the earliest storm", "Relevant data columns": ["name", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['year'].idxmin()]['name']", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many hurricanes", "Relevant data columns": ["category"], "Data column classification": ["keyword"], "Low-level visualization task": ["count", "filter"], "Low-level visualization task classification": ["inferred", "synonym"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "hurricane_count = len(df[(df['status']!='tropical depression') & (df['category']>0)])", "Data transformation operation": ["filter", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the name of the largest storm", "Relevant data columns": ["name", "category", "wind"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "largest_storm = df.loc[df['wind'].idxmax()]", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What storm produced the greatest air pressure", "Relevant data columns": ["name", "pressure"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[df['pressure'].idxmin()]", "Data transformation operation": ["sort", "retrieve value"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many storms are named Caroline", "Relevant data columns": ["name"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['name']=='Caroline']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What storm produced the least air pressure", "Relevant data columns": ["name", "pressure"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['pressure'].idxmin()]", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What storm had the greatest diameter of tropical storm strength winds", "Relevant data columns": ["name", "ts_diameter"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['status']=='tropical storm')]; max_ts_diameter_storm = filtered_df.loc[filtered_df['ts_diameter'].idxmax()]", "Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What storm had the greatest diameter of hurricane strength winds", "Relevant data columns": ["name", "ts_diameter", "hu_diameter", "status", "category"], "Data column classification": ["data value mention", "keyword", "keyword", "inferred", "inferred"], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we're looking at hurricane-strength winds specifically or just strong winds in general.", "Ambiguity resolution": "Filter out storms that don't meet hurricane strength criteria", "Data transformations": "hurricane_storms = df[(df['status']=='hurricane') | ((df['category']>0) & (df['wind']>74))]; max_hu_diameter = hurricane_storms.loc[hurricane_storms['hu_diameter'].idxmax()]['hu_diameter']; result = hurricane_storms[hurricane_storms['hu_diameter']==max_hu_diameter][['name', 'hu_diameter']]", "Data transformation operation": ["filter", "logical operator", "groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many storms occur per year, on average", "Relevant data columns": ["year", "name"], "Data column classification": ["keyword", "inferenced"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "storms_per_year = df.groupby('year')['name'].nunique()", "Data transformation operation": ["groupby", "nunique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "On average, what is the first date that a tropical cyclone (tropical depression, tropical storm, or hurricane) forms on every year", "Relevant data columns": ["year", "month", "day"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "first_date_per_year = df.loc[(df.groupby(['year']).apply(lambda x: x.nsmallest(1,'day'))).reset_index(drop=True)]", "Data transformation operation": ["groupby", "sort", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a correlation between wind speed and air pressure", "Relevant data columns": ["wind", "pressure"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['wind', 'pressure']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a correlation between the duration of the storm and wind speed", "Relevant data columns": ["name", "year", "month", "day", "hour", "wind"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of duration of the storm is ambiguous since we don't know exactly when the storm started or ended.", "Ambiguity resolution": "Assume the start time is the first entry for each storm, end time is the last entry for each storm, and calculate the difference", "Data transformations": "storms = df.groupby('name')['hour'].apply(lambda x: max(x)-min(x)); storms_wind_speed = df.groupby('name')['wind'].mean()", "Data transformation operation": ["groupby", "apply", "mean"], "New Column Name": "storm_duration", "Derivation Specification": "storms['storm_duration'] = storms.values;", "Missing Data Column": ""}, {"query": "Where have all hurricanes been recorded on the globe Where are they more common", "Relevant data columns": ["lat", "long"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["retrieve value", "determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term hurricane is ambiguous since we only have information about storms classified into categories like tropical depressions and tropical storms.", "Ambiguity resolution": "Consider any entry with non-zero wind speed as a hurricane event", "Data transformations": "hurricane_data = df[(df['category']!='-1')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What lat/long locations are most likely to experience hurricanes", "Relevant data columns": ["lat", "long"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['lat', 'long']].plot(kind='scatter')", "Data transformation operation": ["select", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What are lengths/timings of hurricane seasons in different regions of the world", "Relevant data columns": ["year", "month", "day"], "Data column classification": ["inferred", "inferred", "inferred"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'hurricane season' is ambiguous and could refer to either the duration or timing of hurricanes in general, or specifically the Atlantic hurricane season.", "Ambiguity resolution": "Assume 'hurricane season' refers to the typical time period during which most hurricanes occur in different regions.", "Data transformations": "df_monthly_counts = df.resample('M', on='datetime')['status'].count()", "Data transformation operation": ["resample", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average storm length", "Relevant data columns": ["name", "year", "month", "day", "hour"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether storm length refers to time elapsed between first and last recorded points or total hours spent within certain categories.", "Ambiguity resolution": "Assume storm length means total hours spent within certain categories.", "Data transformations": "storm_lengths = df.groupby('name')['hour'].apply(lambda x: max(x)-min(x))", "Data transformation operation": ["groupby", "lambda function"], "New Column Name": "Storm Length", "Derivation Specification": "max_hour-min_hour", "Missing Data Column": ""}, {"query": "What is the average time that it takes to go from depression to storm", "Relevant data columns": ["status", "year", "month", "day", "hour"], "Data column classification": ["keyword", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["calculate duration"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "depression_rows = df[(df['status']=='tropical depression')]; storm_rows = df[(df['status']=='tropical storm')]; avg_time_diff = ((storm_rows[['year', month', 'day', 'hour']].values - depression_rows [['year', month', 'day', 'hour']].values).mean().astype(int)", "Data transformation operation": ["filter", "subtract", "mean"], "New Column Name": "time_to_storm", "Derivation Specification": "(pd.to_datetime(storm_rows[['year', month', 'day', 'hour']], unit='h') - pd.to_datetime(depression_rows[['year', month', 'day', 'hour']], unit='h')).dt.total_seconds() / 3600", "Missing Data Column": ""}, {"query": "What is the relationship, if any, between wind and pressure", "Relevant data columns": ["wind", "pressure"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["relationship"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['wind', 'pressure']].corr()", "Data transformation operation": ["correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does wind change over the course of each hurricane", "Relevant data columns": ["name", "wind"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('name')['wind']", "Data transformation operation": ["groupby"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Average tropical storm diameter", "Relevant data columns": ["category", "ts_diameter"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's ambiguous whether we need to consider only rows where the category is exactly 'tropical storm' or any type of storm.", "Ambiguity resolution": "Filter out categories other than 'tropical storm'", "Data transformations": "storm_data = df[df['category']=='tropical storm']; avg_ts_diameter = storm_data['ts_diameter'].mean()", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between storm day and hu_diameter", "Relevant data columns": ["day", "hu_diameter"], "Data column classification": ["data value mention", "column name mention"], "Low-level visualization task": ["dependency"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['day', 'hu_diameter']].dropna()", "Data transformation operation": ["select", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any repeat names of storms", "Relevant data columns": ["name"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "storm_names_count = df['name'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the maximum pressure of a certain hurricane", "Relevant data columns": ["pressure", "name"], "Data column classification": ["keyword", "inferenced"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'certain' implies a specific hurricane but does not specify its name.", "Ambiguity resolution": "Ask the user to provide the name of the hurricane they're interested in.", "Data transformations": "df.loc[df['name']=='hurricane_name']['pressure'].max()", "Data transformation operation": ["filter", "aggregate max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Relationship between position and the strength of the hurricane", "Relevant data columns": ["lat", "long", "wind", "pressure", "status", "category"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "inferred", "inferred"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the position refers specifically to latitude/longitude or also includes other location-related features.", "Ambiguity resolution": "Consider both latitude and longitude when evaluating position", "Data transformations": "df[['lat', 'long', 'wind', 'pressure']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Average time for each hurricane status", "Relevant data columns": ["status", "hour"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('status')['hour'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any visible trends in violent crime rates over the time period", "Relevant data columns": ["Years", "Firearm deaths (People)", "Homicide (People)", "Suicide (People)", "Unintentional (People)", "Legal intervention (People)", "Undetermined (People)"], "Data column classification": ["inferred", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["determine range", "trend"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.set_index('Years')['Firearm deaths (People)':'Undetermined (People)').plot()", "Data transformation operation": ["set index", "plot multiple lines"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the most frequent place of violent crime", "Relevant data columns": ["city_or_county"], "Data column classification": ["keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "crime_data = df.value_counts('city_or_county').reset_index(name='Count'); crime_data.columns = ['City/Country', 'Frequency']", "Data transformation operation": ["value counts", "reset index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any correlations in violent or non-violent crimes based on congressional district and year", "Relevant data columns": ["congressional_district", "year", "incident_characteristics"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["retrieve value", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "crimes_by_year_cong_dist = df.groupby(['congressional_district', 'year']).apply(lambda x: x['incident_characteristics'].value_counts()).reset_index(name='counts')", "Data transformation operation": ["groupby", "apply", "value_counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What city has the highest crime rate", "Relevant data columns": ["city_or_county", "incident_id", "n_killed", "n_injured"], "Data column classification": ["keyword", "inferred", "inferred", "inferred"], "Low-level visualization task": ["retrieval"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we want overall crime rates including both fatal and non-fatal incidents.", "Ambiguity resolution": "We will focus on total number of fatalities and injuries combined.", "Data transformations": "crime_rate_per_city = df.groupby('city_or_county')['n_killed', 'n_injured'].sum().reset_index()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many gun violence incidents are there each year", "Relevant data columns": ["incident_id", "date"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["aggregate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['year']] = df.date.dt.year; count_per_year = df.groupby('year')['incident_id'].count()", "Data transformation operation": ["extract", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any significant correlations between any 2 variables in the dataset", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What\u2019s the frequency of gun violence incidents with multiple victims", "Relevant data columns": ["incident_id", "date", "state", "city_or_county", "address", "n_killed", "n_injured"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred", "keyword", "keyword"], "Low-level visualization task": ["distribution", "correlation"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['n_killed']>0) | (df['n_injured']>0)]; filtered_df.groupby(['year']).size()", "Data transformation operation": ["filter", "groupby", "size"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How have homicide rates increased over time", "Relevant data columns": ["Years", "Homicide (People)"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["time series", "trend"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.plot(x='Years', y='Homicide (People)')", "Data transformation operation": ["plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What type of gun violence has seen the most growth over the years", "Relevant data columns": ["incident_id", "date", "state", "city_or_county", "address", "n_killed", "n_injured", "congressional_district", "gun_stolen", "gun_type", "incident_characteristics"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword", "numeric", "numeric", "keyword", "keyword", "keyword", "text"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('year')['incident_characteristics'].value_counts().unstack()", "Data transformation operation": ["groupby", "value counts", "unstack"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are most gun death because of suicide", "Relevant data columns": ["intent"], "Data column classification": ["keyword"], "Low-level visualization task": ["distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.intent.value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Did most gun violence happen inside home", "Relevant data columns": ["location_description", "incident_characteristics"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether 'inside home' refers specifically to residential locations or any indoor setting.", "Ambiguity resolution": "Assume 'inside home' means incidents occurring at residences or homes.", "Data transformations": "home_incidents = df[(df['location_description'].str.contains('home|residence')) & (~df['location_description'].isnull()); home_incident_frequency = home_incidents.groupby('incident_characteristics')['incident_id'].count()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the correlation between education levels and suicide rates", "Relevant data columns": ["education", "intent"], "Data column classification": ["keyword", "inferenced"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df['intent'] == 'Suicide')] ; edu_corr = df[['education', 'intent']].corr()", "Data transformation operation": ["filter", "correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which state/year has the most gun deaths", "Relevant data columns": ["state", "year", "Firearm deaths (People)", "Homicide (People)", "Suicide (People)", "Unintentional (People)", "Legal intervention (People)", "Undetermined (People)"], "Data column classification": ["keyword", "keyword", "inferenced from various death types"], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "combined_deaths = df[['Homicide (People)', 'Suicide (People)', 'Unintentional (People)', 'Legal intervention (People)', 'Undetermined (People)']].sum(axis=1); combined_deaths.name = 'Total Gun Deaths'; result = df.merge(combined_deaths, left_on='Years', right_index=True).sort_values(by='Total Gun Deaths', ascending=False)", "Data transformation operation": ["merge", "sort_values"], "New Column Name": "Total Gun Deaths", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me a list of neighborhoods with the number of male births from least to most", "Relevant data columns": ["Neighborhood Name", "Number"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["sort", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Number')", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "let me know if there are groups of neighborhoods with similar birth gender ratios", "Relevant data columns": ["Neighborhood Name", "Number", "Gender"], "Data column classification": ["inferred", "inferred", "keyword"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what exactly constitutes a \"similar\" ratio.", "Ambiguity resolution": "Use clustering algorithms to group neighborhoods by their gender ratios.", "Data transformations": "birth_gender_ratio = df.groupby(['Neighborhood Name', 'Gender'])['Number'].sum().unstack()['Boys']/df.groupby(['Neighborhood Name', 'Gender'])['Number'].sum().unstack()['Girls']; clustered_data = birth_gender_ratio.reset_index().groupby('Neighborhood Name')['Boys'].apply(lambda x: x / sum(x)).reset_index(name='ratio')", "Data transformation operation": ["groupby", "sum", "divide", "cluster"], "New Column Name": "ratio", "Derivation Specification": "birth_gender_ratio = boys_count / girls_count", "Missing Data Column": ""}, {"query": "which neighborhood in ciutat vella has more than 100 females born in the year 2013", "Relevant data columns": ["Neighborhood Name", "District Name", "Gender", "Number", "Year"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "data value mention"], "Low-level visualization task": ["filter", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The query mentions 2013 but the given dataset only contains 2017.", "Ambiguity resolution": "Since the dataset doesn't contain 2013, we'll assume the query meant to ask about 2017 instead.", "Data transformations": "df_filtered = df[(df['District Name']=='Ciutat Vella') & (df['Gender']=='Females') & (df['Year']==2017)]; result = df_filtered[df_filtered['Number']>100]['Neighborhood Name']", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the distribution of all births in all districts between 2013 and 2017", "Relevant data columns": ["District Name", "Number", "Year"], "Data column classification": ["inferred", "keyword", "range specification"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['Year'] >= 2013) & (df['Year'] <= 2017)]; grouped_df = filtered_df.groupby(['District Name', 'Year'])['Number'].sum().reset_index()", "Data transformation operation": ["filter", "groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what neighborhood had 56 boys born in 2017", "Relevant data columns": ["Neighborhood Name", "Number", "Gender", "Year"], "Data column classification": ["keyword", "data value mention", "keyword", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['Year']==2017)&(df['Gender']=='Boys')&(df['Number']==56)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the total number of categories", "Relevant data columns": ["Category"], "Data column classification": ["keyword"], "Low-level visualization task": ["aggregation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "categories_count = df['Category'].nunique()", "Data transformation operation": ["nunique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what 's the size of \" kids paint free - drawing fun \"", "Relevant data columns": ["App", "Size"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['App'] == 'Kids Paint Free - Drawing Fun'), ['Size']] ", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "does a app exist that is much different than the others", "Relevant data columns": ["Category", "Rating", "Reviews", "Size", "Installs"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["determine range", "cluster"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what constitutes being \"much different\" from other apps.", "Ambiguity resolution": "Determine outliers based on multiple features such as rating, reviews, size, installs, and category.", "Data transformations": "from sklearn.covariance import EllipticEnvelope; ee = EllipticEnvelope(contamination=0.1); df[['Rating', 'Reviews', 'Size', 'Installs']].apply(lambda x: ee.fit(x.values.reshape(-1,1)))", "Data transformation operation": ["fit", "reshape"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the total amount of genres", "Relevant data columns": ["Genres"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genres_count = df['Genres'].nunique()", "Data transformation operation": ["count_unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the title of the biggest app", "Relevant data columns": ["App"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "it's unclear what 'biggest' means - is it by installs, size, rating?", "Ambiguity resolution": "Determine 'biggest' refers to max installs", "Data transformations": "df.loc[df['Installs'].idxmax()]", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what apps have a perfect rating and a lot of reviews", "Relevant data columns": ["Rating", "Reviews"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["filter", "determine range"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['Rating']==5.0)&(df['Reviews']>10000)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "see if you can locate the most recent gaming app", "Relevant data columns": ["Category", "Last Updated"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value", "sort"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's ambiguous whether most recent' refers to the last updated date or something else.", "Ambiguity resolution": "Assume it means the last updated date", "Data transformations": "gaming_apps = df.loc[(df['Category'] == 'GAME')] ; max_last_updated_app = gaming_apps.loc[gaming_apps['Last Updated'].idxmax()]", "Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me free or paid apps have a higher mean rating", "Relevant data columns": ["Rating", "Price"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "free_apps_rating_mean = df.loc[df['Price']=='Free']['Rating'].mean(); paid_apps_rating_mean = df.loc[df['Price']!='Free']['Rating'].mean()", "Data transformation operation": ["filter", "groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which genres are included in the dataset", "Relevant data columns": ["Genres"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genres_list = df['Genres'].tolist()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which apps have support for versions of android lower than 40", "Relevant data columns": ["Android Ver"], "Data column classification": ["keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["Targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data_transformations": "df = df[df['Android Ver'].str.contains('and up|1\\.6|2\\.1')] ", "Data_transformation_operation": ["Filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "describe shape of the distribution for the number of installations", "Relevant data columns": ["Installs"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import matplotlib.pyplot as plt; import seaborn as sns; sns.distplot(df['Installs']); plt.show()", "Data transformation operation": ["visualize distribution"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the app that costs the most", "Relevant data columns": ["Price"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['Price'].idxmax()]", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a relationship between the android version of an app and its installations", "Relevant data columns": ["Android Ver", "Installs"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Android Ver', 'Installs']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "when taking different android versions into account, does that have any impact on installation", "Relevant data columns": ["Android Ver", "Installs"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "android_ver_install_corr = df[['Android Ver', 'Installs']].groupby('Android Ver')['Installs'].corr()", "Data transformation operation": ["groupby", "calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the attribute ' 'rating ' ' be affected ' 'installation", "Relevant data columns": ["Rating", "Installs"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rating', 'Installs']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which app has a rating that doesn 't follow a trend between installations, rating and number of reviews", "Relevant data columns": ["Rating", "Installs", "Reviews"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlate", "determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['App','Rating','Installs','Reviews']].corr()", "Data transformation operation": ["correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are there an unusually high number of reviews for any of the apps", "Relevant data columns": ["Reviews"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "what defines an unusual number of reviews?", "Ambiguity resolution": "determine the threshold for outlier detection", "Data transformations": "from scipy import stats; df['zscore'] = (df['Reviews'] - df['Reviews'].mean())/df['Reviews'].std(); outliers = df[np.abs(stats.zscore(df['Reviews'])) > 3]", "Data transformation operation": ["calculate z-score", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the distribution of the number based on shape of installations", "Relevant data columns": ["Installs"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The phrase shape of installations' is ambiguous - does it refer to a categorical grouping or a continuous transformation?", "Ambiguity resolution": "Assume a categorical grouping by range of installs (e.g. <10000, 10000-500000, >500000)", "Data transformations": "bins = [0, 10000, 500000, np.inf]; df['Install Bin'] = pd.cut(df['Installs'], bins); install_distribution = df['Install Bin'].value_counts()", "Data transformation operation": ["binning", "categorization"], "New Column Name": "Install Bin", "Derivation Specification": "pd.cut(df['Installs'], bins)", "Missing Data Column": ""}, {"query": "is there an effect on price caused by the app 's genre", "Relevant data columns": ["Price", "Genres"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider other factors besides genres when analyzing their impact on prices.", "Ambiguity resolution": "Control for other variables such as category, rating, reviews, size, installs, type, and last updated while studying the relationship between genres and prices.", "Data transformations": "genre_price_data = df[['Price', 'Genres']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a correlation between apps with more installations and higher ratings", "Relevant data columns": ["Installs", "Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import matplotlib.pyplot as plt; import seaborn as sns;sns.pairplot(x_vars='Installs', y_vars='Rating', data=df);plt.show()", "Data transformation operation": ["pairplot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the most pricey apps by release date, recent to oldest", "Relevant data columns": ["Price", "Last Updated"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value", "sort"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Last Updated', ascending=False); df_price_rank = df.loc[(df['Price']!='Free'),'Price'].idxmax()", "Data transformation operation": ["sort", "filter", "loc"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "find out any app that is distinctive from the rest", "Relevant data columns": ["App", "Category", "Rating"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what makes an app distinctive.", "Ambiguity resolution": "Identify apps with unique characteristics such as category, rating, or other features.", "Data transformations": "distinct_apps = df[(np.abs(stats.zscore(df[['Rating']])) > 3) | (df['Category'].value_counts() == 1)]", "Data transformation operation": ["calculate z-score", "identify outliers", "filter by category count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "list the top 10 gaming apps sorted from highest to lowest installations", "Relevant data columns": ["Category", "Installs"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value", "sort"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", " Ambiguity resolution": "", "Data transformations": "gaming_apps = df[(df['Category'] == 'GAME')]; gaming_apps.sort_values(by='Installs', ascending=False).head(10)", "Data transformation operation": ["filter", "sort", "head"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the price distribution of all the beauty apps", "Relevant data columns": ["Category", "Price"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what constitutes a \"beauty app\"", "Ambiguity resolution": "Filter by categories such as lifestyle or family that could be interpreted as beauty-related.", "Data transformations": "filtered_beauty_apps = df[(df['Category']=='LIFESTYLE') | (df['Category']=='FAMILY')] ; filtered_beauty_apps[['Price']].value_counts()", "Data transformation operation": ["filter", "select", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name any apps that can support any version of android lower than 40", "Relevant data columns": ["Android Ver"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df['Android Ver'].str.contains\u2227(r'and up|andro'))&(df['Android Ver'].str.split('and up')[0].astype(float)<4)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which 10 regions have the most health centers", "Relevant data columns": ["Region", "Health Centre"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value", "sort", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "sorted_regions = df.sort_values(by='Health Centre', ascending=False).head(10)[['Region', 'Health Centre']].reset_index(drop=True)", "Data transformation operation": ["sort", "rank", "limit"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "look up regions that names start with the letter a", "Relevant data columns": ["Region"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[df['Region'].str.startswith('A')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "make a list of the number of total hfs in descending order", "Relevant data columns": ["Total HFs"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Total HFs', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average count of hospitals", "Relevant data columns": ["Hospital"], "Data column classification": ["keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "average_hospital_count = df['Hospital'].mean()", "Data transformation operation": ["mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what 's the distribution of the entire hfs", "Relevant data columns": ["Total HFs", "Region"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "hf_distribution = df[['Total HFs']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which region has the lowest population ratio of hf", "Relevant data columns": ["ration of population over HF", "Region"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[df['ration of population over HF'].idxmin()]", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "look for the region that has the most people living in it", "Relevant data columns": ["Region", "Population"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[[df['Population'].idxmax()]]", "Data transformation operation": ["sort", "retrieve max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "remove any regions with a population ratio of hf lower than 15", "Relevant data columns": ["Population", "ration of population over HF", "Region"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['ratio of population over HF'] >= 1.5][['Region', 'Total HFs', 'Hospital', 'Health Centre', 'Dispensary', 'Clinic', 'Population', 'ratio of population over HF']]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do any regions have their population ratio over 20 hf", "Relevant data columns": ["Population", "ration of population over HF"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['ration of population over HF']>2]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me the movie that received the most nominations", "Relevant data columns": ["nominee film"], "Data column classification": ["keyword"], "Low-level visualization task": ["aggregation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "nomination_counts = df['nominee film'].value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "out of the winners for best performance by an actor in a motion picture - musical or comedy from 2003 to 2020, the most abnormal age belongs to which actor", "Relevant data columns": ["year_award", "category", "nominee"], "Data column classification": ["keyword", "keyword", "inferenced"], "Low-level visualization task": ["find anomaly"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The concept of 'abnormal' age is ambiguous and requires further clarification.", "Ambiguity resolution": "Define 'abnormal' as outliers compared to mean/median age of actors who won awards in the specified time period", "Data transformations": "winners_actors_df = df[(df['category']=='Best Performance by an Actor in a Motion Picture - Musical or Comedy') & (df['year_award']>=2003)&(df['year_award']<=2020)]; ages_series=winners_actors_df.apply(lambda row:get_age_from_nominee(row))", "Data transformation operation": ["filter", "apply"], "New Column Name": "age", "Derivation Specification": "Assuming get_age_from_nominee function extracts the age from the nominee information", "Missing Data Column": ""}, {"query": "can you organize the results of the table by sorting the list according to the age of the stars", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The query does not specify where to get the ages of the stars from since they do not exist in the given dataset.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Age of Stars"}, {"query": "what was the gender of all actors among all the final winners in the 60th ceremony", "Relevant data columns": ["ceremony", "win", "nominee"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's ambiguous whether we need to consider only the winning nominees or all nominees from the 60th ceremony.", "Ambiguity resolution": "Filter by both conditions: 'ceremony' equals 60 and 'win' equals True", "Data transformations": "winner_nominees_60th_ceremony = df[(df['ceremony']==60) & (df['win']==True)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in the 60th ceremony, the award for best performance by an actor in a motion picture was won by whom", "Relevant data columns": ["ceremony", "category", "nominee", "win"], "Data column classification": ["data value mention", "keyword", "inferred", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only winners or all nominees.", "Ambiguity resolution": "Filter out non-winners.", "Data transformations": "filtered_df = df[(df['ceremony']==60) & (df['category']=='Best Performance by an Actor in a Motion Picture') & (df['win']==True)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which actor was nominated for the most awards", "Relevant data columns": ["nominee"], "Data column classification": ["inferred"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "actor_nominations = df.value_counts('nominee')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can the actors nationality impact the outcome", "Relevant data columns": ["nominee", "win"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what kind of impact refers to and whether we need to analyze actor's individual performances or just their films.", "Ambiguity resolution": "Analyze correlations between actor nationalities and award outcomes for each film.", "Data transformations": "actor_nationalities = get_actor_nationalities(); merged_data = df.merge(actor_nationalities); correlated_data = merged_data[['Actor Nationality', 'Win']].corr()", "Data transformation operation": ["merge", "calculate correlation"], "New Column Name": "Actor Nationality", "Derivation Specification": "", "Missing Data Column": "Actor Nationality"}, {"query": "what is the total number of movies released in the year 1998", "Relevant data columns": ["year_film"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[df['year_film']==1998]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the correlation between the nomination and the age of a star", "Relevant data columns": ["nominee"], "Data column classification": ["inferred"], "Low-level visualization task": ["retrieve value", "correlate"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "Age information about stars is missing from the given dataset.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "age_of_star", "Derivation Specification": "Assuming we have access to external data containing birth dates of nominees", "Missing Data Column": "birth date of nominees"}, {"query": "is there an outlier within the value distribution of albinism that causes the result to be skewed", "Relevant data columns": ["ALBINO"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "albino_values = df['ALBINO']", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the maximum and minimum number of patients with autism across all regions", "Relevant data columns": ["REGION", "AUTISM"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['REGION', 'AUTISM']].describe()", "Data transformation operation": ["describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the spatial and temporal correlation of albinism", "Relevant data columns": ["REGION", "ALBINO"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["correlation", "determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether spatial correlation refers to correlations between regions or within regions, and what time aspect is referred to.", "Ambiguity resolution": "Assume spatial correlation means correlations between regions, and temporal correlation means changes over time but since there's only one timestamp, look at regional patterns", "Data transformations": "albino_per_region = df.groupby('REGION')['ALBINO'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "looking at the number of people in all regions with a visual impairment, what is the median", "Relevant data columns": ["REGION", "VISUALLY IMPAIRED"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["calculate statistic"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import numpy as np; median_visual_impairment = np.median(df['VISUALLY IMPAIRED'])", "Data transformation operation": ["calculate statistic"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "does the value distribution of albinism look skewed", "Relevant data columns": ["ALBINO"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['ALBINO']].describe()", "Data transformation operation": ["summary stats"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "kindly rate the regions on the basis of the number of patients", "Relevant data columns": ["REGION", "ALBINO", "AUTISM", "DEAF-MUTE", "DEAF-BLIND", "MENTALLY IMPAIRED", "PHYSICAL IMPAIRED", "VISUALLY IMPAIRED"], "Data column classification": ["inferred", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether the rating should consider individual patient types separately or aggregate them into total patients per region.", "Ambiguity resolution": "Aggregate patient counts by region to create a comprehensive ranking.", "Data transformations": "patient_counts_by_region = df.select_dtypes(include=[np.number]).sum(axis=1).reset_index(name='Total Patients')", "Data transformation operation": ["select", "aggregate"], "New Column Name": "Total Patients", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "they want to know what tactic is most effective during football", "Relevant data columns": ["goals", "tactic"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value", "summarize data", "compare"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether effectiveness should be measured by average number of goals scored or total number of goals scored.", "Ambiguity resolution": "Use mean of goals scored grouped by tactics", "Data transformations": "df.groupby('tactic')['goals'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "were you aware of the most recent news", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The question seems unrelated to the provided dataset.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the clubs should be arranged by their shooting attempts", "Relevant data columns": ["shooting attempts", "player name"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='shooting attempts')", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what was the total amount of goals scored in the game that liverpool played in", "Relevant data columns": ["goals"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The team 'Liverpool' does not exist in the given dataset.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "team/country"}, {"query": "rank these clubs by their shooting attempts", "Relevant data columns": ["shooting attempts", "player name"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need to aggregate shooting attempts at club level or just sort individual players' records.", "Ambiguity resolution": "Assuming ranking means sorting, so simply sort individual players' records by shooting attempts.", "Data transformations": "df.sort_values(by='shooting attempts', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can lower study times among students cause greater failure rates in class", "Relevant data columns": ["studytime", "failures"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['studytime', 'failures']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you name an unusual reason for choosing this school", "Relevant data columns": ["reason"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['reason']].value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "find the distribution by age", "Relevant data columns": ["age"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.age.value_counts()", "Data transformation operation": ["value count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the youngest students in the dataset", "Relevant data columns": ["age"], "Data column classification": ["keyword"], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "youngest_students = df.loc[df['age'] == df['age'].min()]", "Data transformation operation": ["filter", "minimum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the types of jobs the student 's mothers have", "Relevant data columns": ["Mjob"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Mjob']].value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "i 'm wondering would the travel time decrease for students if they spent more time studying", "Relevant data columns": ["traveltime", "studytime"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to control for other factors that might influence both travel time and study time.", "Ambiguity resolution": "Control for potential confounding variables such as student demographics, academic performance, and extracurricular activities.", "Data transformations": "df[['traveltime', studytime']].corr()", "Data transformation operation": ["calculate correlation coefficient"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "would more time spent on studying reduce travel time for students", "Relevant data columns": ["studytime", "traveltime"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['studytime', 'traveltime']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "please help me identify the least common age", "Relevant data columns": ["age"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "value_counts_age = df['age'].value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name me a country that 's happiness score does not coincide with the region it belongs to", "Relevant data columns": ["Happiness Score", "Region", "Country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether coincidence refers to absolute difference between scores or relative ranking within regions.", "Ambiguity resolution": "Identify top/bottom scorers in each region, then compare their rankings across regions.", "Data transformations": "region_scores = df.groupby('Region')['Happiness Score'].describe(); regional_rankings = df.sort_values(by='Happiness Score').groupby('Region')['Country'].rank()", "Data transformation operation": ["groupby", "sort", "rank"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the country with the lowest trust score", "Relevant data columns": ["Trust (Government Corruption)", "Country"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["direct"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[df['Trust (Government Corruption)'].idxmin()", "Data transformation operation": ["sort", "retrieve"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me, in terms of economy, what is the range across all countries", "Relevant data columns": ["Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df[['Country', 'Economy (GDP per Capita)']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what countries, other than finland, have higher happiness scores and lower gdp", "Relevant data columns": ["Happiness Score", "Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["filter", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['Happiness Score']>df.loc[df['Country']=='Finland','Happiness Score'].values[0]) & (df['Economy (GDP per Capita)']<df.loc[df['Country']=='Finland','Economy (GDP per Capita)'].values[0])] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the area in the previous decade that increased rapidly in the happiness score", "Relevant data columns": ["Region", "Happiness Score"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range", "compute derived value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The phrase \"previous decade\" implies looking at past data but since we only have one snapshot of current data, we'll need to infer changes from other available information.", "Ambiguity resolution": "", "Data transformations": "No direct calculation possible due to lack of historical data", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the range of happiness score in western europe", "Relevant data columns": ["Happiness Score", "Region"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "western_europe_data = df[df['Region']=='Western Europe']; happiest_score_range = [western_europe_data['Happiness Score'].min(), western_europe_data['Happiness Score'].max()] ", "Data transformation operation": ["filter", "aggregation(min,max)"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "out of all the countries, which ones have a happiness score higher then finland", "Relevant data columns": ["Happiness Score", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value", "filter"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "finland_happiness_score = df.loc[df['Country']=='Finland', 'Happiness Score']; result_df = df[df['Happiness Score']>finland_happiness_score]", "Data transformation operation": ["filter", "selection"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "please identify the parameters of the happiness score in western europe", "Relevant data columns": ["Happiness Score", "Region"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "western_europe_data = df[df['Region']=='Western Europe'][['Happiness Score']] ", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show all the countries with happiness scores higher than 5", "Relevant data columns": ["Happiness Score", "Country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_data = df[df['Happiness Score']>5][['Country', 'Happiness Score']]", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name the continent that contains the greatest number of countries that are top 10 on the happiness index", "Relevant data columns": ["Region", "Happiness Rank"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "top_10_regions = df.loc[df['Happiness Rank'] <= 10]['Region']; region_counts = top_10_regions.value_counts()", "Data transformation operation": ["filter", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do any countries have happiness scores that don 't match with their gdp", "Relevant data columns": ["Happiness Score", "Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what constitutes a mismatch between happiness score and GDP.", "Ambiguity resolution": "Identify outliers in the scatter plot of Happiness Score vs. GDP per Capita", "Data transformations": "import matplotlib.pyplot as plt; plt.scatter(df['Economy (GDP per Capita)'], df['Happiness Score'])", "Data transformation operation": ["scatterplot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "of all the countries trust score, which country has the lowest", "Relevant data columns": ["Trust (Government Corruption)", "Country"], "Data column classification": ["keyword", "inferenced"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['Trust (Government Corruption)'].idxmin()]", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name the country that scores the least on trust", "Relevant data columns": ["Trust (Government Corruption)", "Country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result=df.loc[df['Trust (Government Corruption)'].idxmin()]", "Data transformation operation": ["sort", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the range across all the countries in terms of economy", "Relevant data columns": ["Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Country', 'Economy (GDP per Capita)']].describe()", "Data transformation operation": ["describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "organize the countries based on happiness score, with the score limit on each group being 10", "Relevant data columns": ["Happiness Score", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the groups need to be continuous intervals of scores or just rough categories.", "Ambiguity resolution": "Create discrete bins of width 1 from 0 to 10 for grouping happiness scores", "Data transformations": "bins = [x - x % 1 for x in range(11)]; grouped_df = df.groupby(pd.cut(df['Happiness Score'], bins))", "Data transformation operation": ["cut", "groupby"], "New Column Name": "happiness_group", "Derivation Specification": "pd.cut(df['Happiness Score'], bins).astype(str)", "Missing Data Column": ""}, {"query": "show me the distribution of the health score as it is presented in different regions", "Relevant data columns": ["Health (Life Expectancy)", "Region"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_health_dist = df.groupby('Region')['Health (Life Expectancy)'].plot.kde()", "Data transformation operation": ["groupby", "plot kde"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the average gdp of countries in western europe", "Relevant data columns": ["Region", "Economy (GDP per Capita)"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "western_europe_gdp_avg = df.loc[df['Region']=='Western Europe', 'Economy (GDP per Capita)'].mean()", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "organize the countries by their region", "Relevant data columns": ["Region", "Country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "regionwise_data = df.groupby('Region')['Country'].apply(list)", "Data transformation operation": ["groupby"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "for all the regions, can you show me the pattern of the happiness score", "Relevant data columns": ["Region", "Happiness Score"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to aggregate the scores by region or keep them at individual level.", "Ambiguity resolution": "Group the data by region and plot the average happiness score for each region.", "Data transformations": "region_happiness_scores = df.groupby('Region')['Happiness Score'].mean()", "Data transformation operation": ["groupby", "average"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what are all the countries that have a happiness score similar to fineland  5 is an acceptable error score", "Relevant data columns": ["Happiness Score", "Country"], "Data column classification": ["keyword", "synonym"], "Low-level visualization task": ["find anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "finland_happiness_score = df.loc[df['Country']=='Finland']['Happiness Score']; result_df = df[(np.abs(df['Happiness Score'] - finland_happiness_score) <= 0.05)]", "Data transformation operation": ["locate", "calculate difference", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the range of economy across all the countries", "Relevant data columns": ["Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Economy (GDP per Capita)']].describe() ", "Data transformation operation": ["summary statistics"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "rank countries high to low by their family score", "Relevant data columns": ["Family", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Family', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can we conclude that higher happiness comes from higher freedom", "Relevant data columns": ["Happiness Score", "Freedom"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "corr_matrix = df[['Happiness Score', 'Freedom']].corr()", "Data transformation operation": ["correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what dimension of the happiness index has the maximum fluctuation", "Relevant data columns": ["Happiness Score", "Family", "Health (Life Expectancy)", "Freedom", "Trust (Government Corruption)", "Generosity", "Dystopia Residual"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["find extremum", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether maximum fluctuation' refers to standard deviation, variance, range, or another measure.", "Ambiguity resolution": "Assume maximum fluctuation' means the largest range between the minimum and maximum values for each dimension.", "Data transformations": "score_cols = ['Happiness Score', 'Family', 'Health (Life Expectancy)', 'Freedom', 'Trust (Government Corruption)', 'Generosity', 'Dystopia Residual']; max_fluctuations = [col for col in score_cols]", "Data transformation operation": ["calculate range"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "retrieve the country that has had a sudden decrease in happiness score within a year", "Relevant data columns": ["Happiness Score", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what constitutes a sudden decrease", "Ambiguity resolution": "Define threshold for percentage change in happiness score", "Data transformations": "pct_change_df = df.sort_values(by='Region')['Happiness Score'].pct_change()", "Data transformation operation": ["sort", "calculate percentage change"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "across all regions, what is the happiness score pattern", "Relevant data columns": ["Region", "Happiness Score"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["trend"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate Happiness Scores by region or analyze them separately.", "Ambiguity resolution": "Aggregate Happiness Scores by region", "Data transformations": "region_happiness_scores = df.groupby('Region')['Happiness Score'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the health score is highest in which country", "Relevant data columns": ["Health (Life Expectancy)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['Health (Life Expectancy)'].idxmax()]", "Data transformation operation": ["find max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the highest health score is held by which country", "Relevant data columns": ["Health (Life Expectancy)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['Health (Life Expectancy)'].idxmax()]", "Data transformation operation": ["find max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the distribution for the book ratings", "Relevant data columns": ["averageRating"], "Data column classification": ["keyword"], "Low-level visualization task": ["distribution"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['averageRating']].describe()", "Data transformation operation": ["summary stats"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you rearrange the table by book rating in descending order", "Relevant data columns": ["averageRating"], "Data column classification": ["keyword"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='averageRating', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what books have low ratings that seem suspect", "Relevant data columns": ["averageRating", "title", "authors"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term seem suspect' is ambiguous and requires clarification.", "Ambiguity resolution": "Define suspiciously low-rated books as those with below-average ratings and investigate further.", "Data transformations": "filtered_df = df[df['averageRating'] < df['averageRating'].mean()]", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the book ratings distribution", "Relevant data columns": ["averageRating"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['averageRating']].describe()", "Data transformation operation": ["summary stats"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which author has worked with dark horse comics most frequently", "Relevant data columns": ["authors"], "Data column classification": ["keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "Dark Horse Comics is not present in the given dataset.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "publisher"}, {"query": "please go and get all of the books written in english", "Relevant data columns": ["language"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "english_books_df = df[df['language']=='en']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are there outliers in the book ratings", "Relevant data columns": ["averageRating"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.describe()", "Data transformation operation": ["summary stats"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "of fiction books, which are written in english", "Relevant data columns": ["categories", "language"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "fiction_books_in_english = df[(df['categories'].str.contains('Fiction')) & (df['language']=='en')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many books have been released by dark horse comics", "Relevant data columns": ["publisher"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_publisher_dark_horse = df[df['publisher']=='Dark Horse Comics']; count_books = df_publisher_dark_horse.shape[0]", "Data transformation operation": ["filter", "shape"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the most expensive book and who published it", "Relevant data columns": ["pageCount", "publisher"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Retrieve Value", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "expensive_book = df.loc[df['pageCount'].idxmax()]", "Data transformation operation": ["sort", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "produce a list of book titles published during the current year", "Relevant data columns": ["title", "publishedDate"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'current year' is ambiguous since we don't know what year is meant by 'current'. It could mean the most recent available year or any arbitrary year.", "Ambiguity resolution": "Assume 'current year' means the latest available publication date.", "Data transformations": "latest_year = max(df['publishedDate'].apply(lambda x: x.year)); filtered_df = df[df['publishedDate'].apply(lambda x: x.year) == latest_year][['title', 'publishedDate']]", "Data transformation operation": ["max", "filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in terms of the readings, group the similar timestamps for the sants", "Relevant data columns": ["Station", "Generated", "O3 Value", "NO2 Value", "PM10 Value"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the user wants to group by exact timestamp matches or within a certain time range.", "Ambiguity resolution": "Group by hour or minute intervals", "Data transformations": "df_sants = df[df['Station']=='Barcelona - Sants']; grouped_data = df_sants.resample('H', on='Generated')['O3 Value', 'NO2 Value', 'PM10 Value'].mean()", "Data transformation operation": ["filter", "resample", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "for o3, what is the distribution value", "Relevant data columns": ["O3 Value"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "o3_value_distribution = df['O3 Value'].value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in the whole table, show me the best record of pm10", "Relevant data columns": ["PM10 Value"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "best_pm10_record = df.loc[df['PM10 Value'].idxmax()]", "Data transformation operation": ["sort", "idxmax"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "based on their pollution, group the locations together that are similar", "Relevant data columns": ["Station", "O3 Value", "NO2 Value", "PM10 Value", "Generated"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear how similarity between locations will be determined based on their pollution levels.", "Ambiguity resolution": "Determine clustering method and relevant features for measuring pollution level similarity", "Data transformations": "from sklearn.cluster import KMeans; kmeans = KMeans(n_clusters=5); df[['O3 Value', 'NO2 Value', 'PM10 Value']].fillna(0).apply(lambda x: np.log(x + 1)); clustered_data = kmeans.fit_predict(df[['O3 Value', 'NO2 Value', 'PM10 Value']].fillna(0))", "Data transformation operation": ["fill missing values", "log transform", "clustering"], "New Column Name": "Cluster ID", "Derivation Specification": "kmeans.labels_", "Missing Data Column": ""}, {"query": "please look at the o3 data and find the minimum number", "Relevant data columns": ["O3 Value"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["direct request", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "o3_min_value = df['O3 Value'].min()", "Data transformation operation": ["min"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in what manner are good air quality records dispersed throughout the monitored region", "Relevant data columns": ["Station", "Air Quality"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the distribution refers to spatial dispersion or temporal variation.", "Ambiguity resolution": "Interpret as both spatial and temporal dispersion.", "Data transformations": "good_air_quality_records = df[df['Air Quality']=='Good']; good_air_quality_spatial_distribution = good_air_quality_records[['Longitude', 'Latitude']].plot(kind='scatter'); good_air_quality_temporal_distribution = good_air_quality_records.set_index('Generated')['Air Quality'].resample('H').count().plot(kind='line')", "Data transformation operation": ["filter", "select", "groupby", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are there any outliers in pm10 readings from a temporal perspective", "Relevant data columns": ["PM10 Value", "Generated"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The query does not specify what time granularity to consider when looking at the temporal aspect.", "Ambiguity resolution": "Consider hourly/daily/monthly/yearly aggregates depending on the available data", "Data transformations": "pm10_readings = df[['Generated', 'PM10 Value']].copy(); pm10_readings['Generated'] = pd.to_datetime(pm10_readings['Generated']); pm10_readings.set_index('Generated', inplace=True); hourly_pm10 = pm10_readings.resample('H')['PM10 Value']; daily_pm10 = pm10_readings.resample('D')['PM10 Value']", "Data transformation operation": ["resample", "set index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "work out the quality of o3", "Relevant data columns": ["O3 Quality", "Station"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'work out' implies that we need to process or transform the data but doesn't specify exactly what operation needs to be done.", "Ambiguity resolution": "Determine the distribution of O3 Quality across stations", "Data transformations": "o3_quality_distribution = df[['Station', 'O3 Quality']].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is distribution for pm10 value anything other than normal", "Relevant data columns": ["PM10 Value"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "pm10_values = df['PM10 Value']; from scipy import stats; _, p = stats.normaltest(pm10_values)", "Data transformation operation": ["selection", "normal test"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me a day with extremely bad air quality", "Relevant data columns": ["O3 Quality", "NO2 Quality", "PM10 Quality", "Generated"], "Data column classification": ["keyword", "keyword", "keyword", "inferred"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the request refers to a single station or multiple stations.", "Ambiguity resolution": "Identify days where at least one station has extremely bad air quality", "Data transformations": "bad_quality_days = df[(df[['O3 Quality', 'NO2 Quality', 'PM10 Quality']].eq('Bad')).any(axis=1)].sort_values(by='Generated')['Generated'].unique()", "Data transformation operation": ["filter", "sort", "unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what days had really bad air quality", "Relevant data columns": ["Station", "Air Quality"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear what constitutes really bad' air quality.", "Ambiguity resolution": "Determine threshold for 'bad' air quality based on the distribution of 'Air Quality'", "Data transformations": "bad_air_quality_threshold = df['Air Quality'].quantile(0.25); bad_days_df = df[df['Air Quality']=='Bad']", "Data transformation operation": ["summary statistic"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are the o3 value and the pm10 value dependent on each other", "Relevant data columns": ["O3 Value", "PM10 Value"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["dependency"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['O3 Value', 'PM10 Value']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in the premier league how are the transferred players ages distributed", "Relevant data columns": ["Age", "League_to"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "premier_league_transfers = df[(df['League_to'] == 'Premier League')] ; age_distribution = premier_league_transfers[['Age']].value_counts()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me a reason why top backcourt players have a higher market value than the top frontcourt player", "Relevant data columns": ["Position", "Market_value"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider only the given dataset or also other external factors.", "Ambiguity resolution": "", "Data transformations": "backcourt_players = df[(df['Position']=='Right Winger') | (df['Position']=='Attacking Midfield')] ; frontcourt_players = df[df['Position']!='Centre-Forward']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which player had an abnormal transfer_fee", "Relevant data columns": ["Transfer_fee"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "from scipy import stats; outliers = df[(np.abs(stats.zscore(df['Transfer_fee'])) > 3)]", "Data transformation operation": ["calculate z-score", "identify outliers"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how old was david when he was transferred in 2010", "Relevant data columns": ["Age", "Name", "Season"], "Data column classification": ["keyword", "data value mention", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "david_players = df[(df['Name'].str.contains('David')) & (df['Season']=='2010-2011')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what player had a market value of 50,000,000 and was transferred for 58,500,000 in the 2010\u201a\u00c4\u00ec2011", "Relevant data columns": ["Market_value", "Transfer_fee", "Season"], "Data column classification": ["data value mention", "data value mention", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['Market_value']==50000000.0)&(df['Transfer_fee']==58500000)&(df['Season']=='2010-2011')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the numbers of the transferred players in different leagues in the 2010 -2011 season", "Relevant data columns": ["League_from", "Team_to", "Season"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["count", "group by"], "Low-level visualization task classification": ["inferred", "synonym"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "league_counts = df.loc[(df['Season']=='2010-2011'), ['League_from']].value_counts()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you buy a player with his market value higher than a transfer fee", "Relevant data columns": ["Market_value", "Transfer_fee"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['Market_value']>df['Transfer_fee'])]", "Data transformation operation": ["filter", "compare"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average transfer_fee for players who transferred to the premier league", "Relevant data columns": ["Transfer_fee", "League_to"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["calculate mean"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "premier_league_transfers = df[df['League_to'] == 'Premier League']; avg_transfer_fee = premier_league_transfers['Transfer_fee'].mean()", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "list center -backs by what their transfer_fee was", "Relevant data columns": ["Position", "Transfer_fee"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "center_backs = df[(df['Position']=='Centre-Back')] ; sorted_center_backs = center_backs.sort_values(by='Transfer_fee') ", "Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which player was the oldest that was transferred", "Relevant data columns": ["Age"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "oldest_player_age = df.loc[df['Age'].idxmax()]", "Data transformation operation": ["find max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the distribution of the leagues who paid for transferred players in 2010", "Relevant data columns": ["League_to", "Season"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider only transfers where the season is exactly 2010-2011 or any transfer that happened during 2010.", "Ambiguity resolution": "Consider only transfers where the season includes 2010.", "Data transformations": "df[(df['Season']=='2010-2011')] => league_distribution = df['League_to'].value_counts()", "Data transformation operation": ["filter", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are you aware of any clustering of the seasons in which players were transferred to the premier league", "Relevant data columns": ["Season"], "Data column classification": ["keyword"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "season_counts = df['Season'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do you feel that midfield players have a lower market value than front court players", "Relevant data columns": ["Position", "Market_value"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["relationship"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "midfield_players = df[df['Position'].str.contains('Midfield')]; frontend_players = df[(~df['Position'].str.contains('Midfield')) & (~df['Position'].str.contains('Defender')) ]; midpoint_market_values = midield_players['Market_value']; frontendpoint_market_values = frontend_players['Market_value']", "Data transformation operation": ["filter", "boolean indexing", "selection"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name movies released in 2017", "Relevant data columns": ["release_year", "title"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['release_year']==2017,['title']] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is the normal distribuition satisfied by the length of the movies", "Relevant data columns": ["duration"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import scipy.stats as stats; result = stats.normaltest(df['duration'])", "Data transformation operation": ["normal test"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "sort the movies by length", "Relevant data columns": ["duration", "type"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "movie_data = df[df['type']=='Movie']; movie_data.sort_values(by='duration')", "Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how long is the run time of average r -rated movies", "Relevant data columns": ["rating", "duration"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "r_movies = df[(df['rating']=='R')]; avg_duration_r = r_movies['duration'].mean()", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me the numbers of movies that were released in 2017", "Relevant data columns": ["release_year"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['release_year']==2017]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there an average run time for movies", "Relevant data columns": ["duration"], "Data column classification": ["keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "avg_duration = df['duration'].mean()", "Data transformation operation": ["mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is the running time of movies recently longer than it used to be", "Relevant data columns": ["duration", "release_year"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['duration','release_year']].groupby('release_year')['duration'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do movie tags and duration have a connection", "Relevant data columns": ["listed_in", "duration"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['listed_in', 'duration']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "determine if the running time of movies has increased in recent years", "Relevant data columns": ["release_year", "duration"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["compute derived value", "trend"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The query does not specify the exact timeframe for recent years'. It could refer to any arbitrary range of years.", "Ambiguity resolution": "Define recent years' as releases within the last 5-10 years.", "Data transformations": "filtered_df = df[(df['type'] == 'Movie') & (df['release_year'] >= 2010)]; filtered_df[['release_year', 'duration']].corr()", "Data transformation operation": ["filter", "correlate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the dates that netflix released movies", "Relevant data columns": ["date_added", "release_year"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['date_added', release_year']].drop_duplicates()", "Data transformation operation": ["select", "distinct"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "does any movies not have a description", "Relevant data columns": ["description"], "Data column classification": ["keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['type']=='Movie')&(df['description'].isnull()), ['title','director']].head()", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "at what point was data added to the table for netflix", "Relevant data columns": ["date_added"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['date_added']].head()", "Data transformation operation": ["select", "head"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the percentage of the white population in blount county, alabama", "Relevant data columns": ["White", "County"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['County'] == 'Blount County'), ['White']] / df.loc[(df['County'] == 'Blount County')), ['TotalPop']] * 100 ", "Data transformation operation": ["filter", "divide"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me which county has the greatest number of female residents", "Relevant data columns": ["County", "Women"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['Women'].idxmax()]", "Data transformation operation": ["sort", "find max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "calculate the average black population for each state", "Relevant data columns": ["State", "Black"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('State')['Black'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what are the groups of regions according to three types of avocados sales ratio", "Relevant data columns": ["region", "type", "AveragePrice", "Total Volume"], "Data column classification": ["inferred", "inferred", "keyword", "keyword"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of 'three types of avocado sales ratio' is ambiguous as it does not specify what these ratios represent.", "Ambiguity resolution": "Assuming the three types refer to quantiles or categories of average price or total volume sales.", "Data transformations": "df[['region', 'type', 'AveragePrice', 'Total Volume']].groupby(['region']).apply(lambda x: pd.qcut(x['AveragePrice'], q=3))", "Data transformation operation": ["groupby", "qcut"], "New Column Name": "sales_ratio_category", "Derivation Specification": "pd.qcut(df['AveragePrice'], q=3)", "Missing Data Column": ""}, {"query": "using the three types of avocado 's sales ratio, provide the groups of regions", "Relevant data columns": ["region", "type"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The query does not specify what kind of grouping is required for the regions.", "Ambiguity resolution": "Group regions by their corresponding avocado types.", "Data transformations": "avocado_types = ['conventional']; grouped_regions = df[df['type'].isin(avocado_types)].groupby('region')['AveragePrice'].mean()", "Data transformation operation": ["filter", "groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "provide the distribution of the sales in 2015 of type 4046", "Relevant data columns": ["type", "year", "Total Volume"], "Data column classification": ["data value mention", "inferred", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_4046_2015 = df[(df['type']==4046)&(df['year']==2015)]; df_distribution = df_4046_2015[['Total Volume']].describe()", "Data transformation operation": ["filter", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "determine in what year the income of undergraduate students was higher", "Relevant data columns": ["Undergraduate Income", "Year"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The question does not specify whether we need to compare incomes between countries or within one country.", "Ambiguity resolution": "Assume the question asks about comparing incomes across all countries.", "Data transformations": "df.sort_values(by='Undergraduate Income', ascending=False); df_year_max_income = df.loc[df.groupby('Year')['Undergraduate Income'].idxmax()]", "Data transformation operation": ["sort", "groupby", "idxmax"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how are postgraduate student numbers distributed every year", "Relevant data columns": ["Postgraduate", "Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Year','Postgraduate']].groupby('Year')['Postgraduate'].value_counts()", "Data transformation operation": ["groupby", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you tell me if there is any correlation between the number of undergraduate and postgraduate students", "Relevant data columns": ["Undergraduate", "Postgraduate"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Undergraduate', 'Postgraduate']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the number of postgraduate students for each year", "Relevant data columns": ["Postgraduate", "Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Year','Postgraduate']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in each year, what is the distribution of the number of postgraduates", "Relevant data columns": ["Postgraduate"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "post_grad_counts_per_year = df.groupby('Year')['Postgraduate'].value_counts()", "Data transformation operation": ["groupby", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what differences are there among the students who acquired more than 270 points between 2010 -2019", "Relevant data columns": ["Total Points", "Student Average"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["filter", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The time range specified does not match any column in the given dataset.", "Ambiguity resolution": "Assuming the time range refers to the student's performance over multiple years, but since there is no year information available, we will ignore this part of the query.", "Data transformations": "filtered_df = df[(df['Total Points']>270)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me all of the categories of grade types", "Relevant data columns": ["Grade"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["direct_query"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "grade_categories = df['Grade'].unique()", "Data transformation operation": ["unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "use the midterm exam and final exam as the 2nd and 1st keywords respectively in order to assign a rank to every one of the students", "Relevant data columns": ["Mid-term exams", "Final exam"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the ranking should consider both mid-term and final exams equally weighted or prioritize one over another", "Ambiguity resolution": "Use equal weights for both mid-term and final exams unless specified otherwise", "Data transformations": "ranked_df = df.sort_values(by=['Final exam', 'Mid-term exams'], ascending=False).reset_index(drop=True)", "Data transformation operation": ["sort", "reset index"], "New Column Name": "Rank", "Derivation Specification": "ranked_df['Rank'] = ranked_df.index + 1", "Missing Data Column": ""}, {"query": "what did the majority of students receive as a grade", "Relevant data columns": ["Grade"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "grade_counts = df['Grade'].value_counts()", "Data transformation operation": ["count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "use the final exam as the first keyword and midterm exam as the second keyword to rank all the students", "Relevant data columns": ["Final exam", "Mid-term exams"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether ranking by both criteria simultaneously or separately is intended", "Ambiguity resolution": "Ranking will consider both mid-term and final exams together", "Data transformations": "ranked_df = df.sort_values(by=['Final exam', 'Mid-term exams'], ascending=False)", "Data transformation operation": ["sort_values", "ascending=False"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the scope, among all the students, of the cw2 score", "Relevant data columns": ["CW 2", "Student"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term scope' could mean either range, distribution, or overall pattern.", "Ambiguity resolution": "Interpret scope' as showing the overall distribution of CW2 scores", "Data transformations": "df[['CW 2']].describe()", "Data transformation operation": ["summary statistic calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in cw1, how many students achieved the feat of 100%, or full marks", "Relevant data columns": ["CW 1"], "Data column classification": ["mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['CW 1'] == 100)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "rank the grades from highest to lowest according to the average score", "Relevant data columns": ["Student Average", "Grade"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "sorted_df = df.sort_values(by='Student Average', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the median score of the cw1 class", "Relevant data columns": ["CW 1"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value", "compute derived value"], "Low-level visualization task classification": ["inferred", "synonym"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "cw1_median = df['CW 1'].median()", "Data transformation operation": ["calculate median"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do you know the median score of all students in cw1", "Relevant data columns": ["CW 1"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "median_cw1_score = df['CW 1'].median()", "Data transformation operation": ["calculate statistic"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many students received an a", "Relevant data columns": ["Grade"], "Data column classification": ["keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_data = df[df['Grade']=='A']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "select all cw1 scores not less than 80%", "Relevant data columns": ["CW 1"], "Data column classification": ["keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['CW 1'] >= 80]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "does simiyu have a similar structure of peope as that of katavi", "Relevant data columns": ["Regions"], "Data column classification": ["data value mention"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear what Simiyu and Katavi refer to since they don't exist in the provided dataset.", "Ambiguity resolution": "Check if Simiyu and Katavi are regions in another dataset or clarify their meanings.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is the total attribute of one area equal to the sum of the other attributes in any area", "Relevant data columns": ["Total", "Never Married", "Married", "Living Together", "Separated", "Divorced", "Widowed"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_total_cols = ['Never Married', 'Married', 'Living Together', 'Separated', 'Divorced', 'Widowed']; df['total_sum'] = df[df_total_cols].sum(axis=1); result = (df['Total'] == df['total_sum']).all()", "Data transformation operation": ["calculate sum", "compare equality"], "New Column Name": "total_sum", "Derivation Specification": "df_total_cols.sum(axis=1)", "Missing Data Column": ""}, {"query": "can you see any abnormalities in the suicide rates", "Relevant data columns": ["suicides_no", "population", "suicides/100k pop"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['country', 'year', sex', 'age', suicides_no', 'population', suicides/100k pop']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name the country with the lowest suicide rate", "Relevant data columns": ["country", "suicides/100k pop"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['suicides/100k pop']==df['suicides/100k pop'].min()]['country']", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do you know the average number of suicides in europe", "Relevant data columns": ["suicides_no"], "Data column classification": ["keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["targeted"], "Ambiguity in the query": "The query does not specify the time period or countries in Europe for which the average suicide rate is desired.", "Ambiguity resolution": "Filter by European countries and aggregate over all available years", "Data transformations": "eu_countries = ['Albania',...]; filtered_df = df[df['country'].isin(eu_countries)]; avg_suicides_europe = filtered_df['suicides_no'].mean()", "Data transformation operation": ["filter", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are there any countries with anomalously low suicides rates", "Relevant data columns": ["country", "suicides_no", "population"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["determine range", "characterize distribution", "find anomalies"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the focus is solely on absolute suicide numbers or relative measures such as suicide rate.", "Ambiguity resolution": "Use both absolute and relative measures to detect anomalies", "Data transformations": "df['suicide_rate'] = df['suicides_no'] / df['population'] * 100000; anomalous_country_rates = df[(np.abs(stats.zscore(df['suicide_rate'])) > 2)]", "Data transformation operation": ["calculate", "filter"], "New Column Name": "suicide_rate", "Derivation Specification": "df['suicide_rate'] = df['suicides_no'] / df['population'] * 100000", "Missing Data Column": ""}, {"query": "with the suicide larger than 100, determine the ages in albania", "Relevant data columns": ["suicides_no", "age", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "albania_data = df[(df['country']=='Albania') & (df['suicides_no']>100)]; albania_ages = albania_data['age']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the country with the lowest suicide rate is", "Relevant data columns": ["country", "suicides/100k pop"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "it is unclear whether only one country should be returned or multiple ones.", "Ambiguity resolution": "returning a single country with the lowest suicide rate", "Data transformations": "result = df.loc[df['suicides/100k pop'].idxmin()", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the distribution rate of suicide", "Relevant data columns": ["suicides_no", "population"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the distribution refers to geographic distribution by country or demographic distribution by other factors such as age and gender.", "Ambiguity resolution": "Explore both geographic and demographic distributions separately.", "Data transformations": "country_distribution = df.groupby('country')['suicides_no'].sum() / df.groupby('country')['population'].sum(); demographics_distribution = df.groupby(['sex', 'age'])['suicides_no'].sum() / df.groupby(['sex', 'age'])['population'].sum()", "Data transformation operation": ["groupby", "sum", "division"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the total number of all suicides in 1999", "Relevant data columns": ["suicides_no", "year"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df['year']==1999)]; total_suicides = df['suicides_no'].sum()", "Data transformation operation": ["filter", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "create a list showing the ages of people who committed suicide in albania", "Relevant data columns": ["age", "country", "suicides_no"], "Data column classification": ["keyword", "data value mention", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "albania_suicides = df[(df['country']=='Albania')] ; result = albania_suicides[['age','suicides_no']].values.tolist()", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "of all countries, how is the gdp distribution", "Relevant data columns": ["country", "gdp_for_year ($)"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['country', 'gdp_for_year ($)']].groupby('country')['gdp_for_year ($)'].describe()", "Data transformation operation": ["groupby", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "i want to see the distribution of the school rankings in geita in 2006", "Relevant data columns": ["REGION", "RANK", "YEAR_OF_RESULT"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The year specified does not match any available data. It is unclear whether we need to adjust our time frame to get relevant results.", "Ambiguity resolution": "Adjust the year range to include nearby years since exact match isn't found", "Data transformations": "filtered_df = df[(df['REGION']=='GEITA') & ((df['YEAR_OF_RESULT']==2015)|(df['YEAR_OF_RESULT']==2017))]; filtered_df[['RANK']].hist()", "Data transformation operation": ["filter", "selection"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do the pass rate and the ownership of schools have any correlation", "Relevant data columns": ["PASS_RATE", "OWNERSHIP"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "pass_rate_by_ownership = df.groupby('OWNERSHIP')['PASS_RATE'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "create a list of schools showing the descending order by change_p", "Relevant data columns": ["NAME", "CHANGE_PREVIOUS_YEAR"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='CHANGE_PREVIOUS_YEAR', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "determine if there are any schools in neighboring regions that have similar avg_m", "Relevant data columns": ["REGION", "DISTRICT", "AVG_MARK"], "Data column classification": ["inferred", "inferred", "keyword"], "Low-level visualization task": ["compare", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether 'neighboring' refers to adjacent districts within a region or nearby regions.", "Ambiguity resolution": "Define neighboring regions by identifying adjacent regions geographically close to one another.", "Data transformations": "from scipy.spatial import distance\nimport numpy as np\ndef get_adjacent_regions(regions):\n    distances = {}\n    for i in range(len(regions)):\n        for j in range(i+1, len(regions)):\n            dist = distance.euclidean((regions[i]['LATITUDE'], regions[i]['LONGITUDE']), (regions[j]['LATITUDE'], regions[j]['LONGITUDE']))\n            distances[(regions[i]['REGION'], regions[j]['REGION])] = dist\n            distances[(regions[j]['REGION'], regions[i]['REGION])] = dist\n    adjacent_regions = [(k,v) for k,v in distances.items() if v < 50]\n    return [r for r,_ in adjacent_regions]; \ndf['NEIGHBOR_REGIONS'] = df.apply(lambda row: get_adjacent_regions(row), axis=1); \nsimilar_avg_marks = df.merge(df, left_on='REGION', right_on='NEIGHBOR_REGIONS')['AVG_MARK'].between(220,240)", "Data transformation operation": ["merge", "apply", "calculate_distance", "filter"], "New Column Name": "NEIGHBOR_REGIONS", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "list the values of kwema modern pr  school 's change_p in all the years", "Relevant data columns": ["NAME", "CHANGE_PREVIOUS_YEAR", "YEAR_OF_RESULT"], "Data column classification": ["data value mention", "keyword", "inferred"], "Low-level visualization task": ["retrieve value", "filter"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need to aggregate the results by year", "Ambiguity resolution": "No aggregation needed since we want individual yearly results", "Data transformations": "kwema_modern_results = df[(df['NAME']=='KWEMA MODERN PR. SCHOOL')] [['NAME', 'CHANGE_PREVIOUS_YEAR', 'YEAR_OF_RESULT']]", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what schools have similar avg_m in the neighboring region", "Relevant data columns": ["REGION", "DISTRICT", "AVG_MARK"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compare", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of 'neighboring' regions is ambiguous and could refer to multiple possible geographic relationships.", "Ambiguity resolution": "Define neighborhood by district or latitude/longitude proximity", "Data transformations": "district_neighbors = df.groupby('DISTRICT')['REGION'].apply(lambda x: x.unique()); school_avg_marks = df[['NAME', 'REGION', 'DISTRICT', 'AVG_MARK']].groupby(['REGION', 'DISTRICT']).mean()", "Data transformation operation": ["groupby", "apply", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which of these school have a pass rate of over 90", "Relevant data columns": ["PASS_RATE", "NAME"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_data = df[df['PASS_RATE']>90]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average height of the floors of these buildings", "Relevant data columns": ["Meters"], "Data column classification": ["keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "avg_floor_height = df['Meters']/df['Stories']", "Data transformation operation": ["divide"], "New Column Name": "average floor height", "Derivation Specification": "(df['Meters']/df['Stories']).mean()", "Missing Data Column": ""}, {"query": "compare the number of tall buildings in hong kong with taiwan", "Relevant data columns": ["name", "Building/City", "Country/Region"], "Data column classification": ["inferred", "inferred", "keyword"], "Low-level visualization task": ["comparison"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "hk_buildings = df[df['Country/Region']=='Hong Kong']; tw_buildings = df[df['Country/Region']=='Taiwan']; hk_count = len(hk_buildings); tw_count = len.tw_buildings)", "Data transformation operation": ["filter", "length"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what location has the highest number of tall buildings", "Relevant data columns": ["Building/City", "Country/Region"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range", "filter"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "city_counts = df.value_counts('Building/City'); city_country_counts = df.groupby('Country/Region')['Building/City'].nunique()", "Data transformation operation": ["value counts", "groupby", "nunique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the oldest user was born in what year", "Relevant data columns": ["birthyear"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "oldest_birth_year = df['birthyear'].min()", "Data transformation operation": ["min"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "indicate all the travels taking more than 1000 minutes", "Relevant data columns": ["trip_duration"], "Data column classification": ["keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_filtered = df[df['tripduration']>1000]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me a list of the tripe that take longer than 1,000 minutes", "Relevant data columns": ["trip_id", "tripduration"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["direct"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['tripduration']>1000]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the distribution of travel times between wells st & elm st and lake shore dr & ohio st", "Relevant data columns": ["from_station_name", "to_station_name", "tripduration"], "Data column classification": ["synonym", "synonym", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "wells_to_lake_shore_trips = df[(df['from_station_name']=='Wells St & Elm St') | (df['to_station_name']=='Lake Shore Dr & Ohio St')] ; wells_to_lake_shore_trip_durations = wells_to_lake_shore_trips['tripduration']", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the relationship between age and travel time", "Relevant data columns": ["birthyear", "tripduration"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['birthyear', 'tripduration']].dropna()", "Data transformation operation": ["select", "dropna"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do you know of any trip that would take longer than 1000 minutes", "Relevant data columns": ["tripduration"], "Data column classification": ["keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['tripduration']>1000]; filtered_df.head()", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which position has the highest average of playing time", "Relevant data columns": ["Pos", "MPG"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "pos_mpg_avg = df.groupby('Pos')['MPG'].mean().reset_index() ", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "if you were to average it out, how upbeat would you say the songs are", "Relevant data columns": ["Energy"], "Data column classification": ["inferred"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "avg_energy = df['Energy'].mean()", "Data transformation operation": ["mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "describe the popularity of the loudest song", "Relevant data columns": ["Loudness..dB..", "Popularity"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "loudest_song_index = df.loc[df['Loudness..dB..'].idxmax() ; popularuty_of_loudest_song = df.iloc[loudest_song_index]['Popularity']", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you help me find some popular songs", "Relevant data columns": ["Popularity"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "popular_songs = df.sort_values(by='Popularity', ascending=False).head()", "Data transformation operation": ["sort", "head"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in terms of length, how long is \" beautiful people \"", "Relevant data columns": ["Length.", "Track.Name"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df.loc[df['Track.Name'] == 'Beautiful People (feat. Khalid)']; filtered_df[['Length.']]", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what songs of the pop genrea has sam smith released", "Relevant data columns": ["Artist.Name", "Genre"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "pop_songs_by.sam_smith = df[(df['Artist.Name']=='Sam Smith') & (df['Genre']=='pop')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are there singers who span multiple genres", "Relevant data columns": ["Artist.Name", "Genre"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "artist_genres = df.groupby('Artist.Name')['Genre'].apply(lambda x: ','.join(set(x)))", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "when the score difference is more than 5, please list the extreme matches to this", "Relevant data columns": ["home_score", "away_score", "date", "home_team", "away_team"], "Data column classification": ["keyword", "keyword", "inferred", "inferred", "inferred"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether the score difference refers to absolute difference or difference favoring either team.", "Ambiguity resolution": "Assume absolute difference between scores", "Data transformations": "df[(abs(df['home_score'] - df['away_score'])) > 5][['date', 'home_team', 'away_team', 'home_score', 'away_score']]", "Data transformation operation": ["calculate", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "please indicate the friendly tournament matches in which the home team beat the away team", "Relevant data columns": ["home_team", "away_team", "home_score", "away_score"], "Data column classification": ["inferred", "inferred", "keyword", "keyword"], "Low-level visualization task": ["filter", "determine range"], "Low-level visualization task classification": ["inferred", "synonym"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['home_score']>df['away_score'])]", "Data transformation operation": ["compare", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me all the tournament matches that the home team won against the away team", "Relevant data columns": ["home_team", "away_team", "home_score", "away_score", "tournament"], "Data column classification": ["inferred", "inferred", "keyword", "keyword", "inferred"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "matches_won_by_home_team = df[(df['home_score'] > df['away_score']) & (df['tournament']!='Friendly')][['home_team', 'away_team', 'home_score', 'away_score']]", "Data transformation operation": ["compare", "logical AND", "filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which group of nations won the most games", "Relevant data columns": ["home_team", "away_team", "home_score", "away_score"], "Data column classification": ["inferred", "inferred", "keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we're considering only wins by the home team or both home and away teams.", "Ambiguity resolution": "Consider wins by both home and away teams", "Data transformations": "winner = np.where(df['home_score']>df['away_score'],'Home','Away'); winner_counts = df.groupby(winner)['home_team'].value_counts()", "Data transformation operation": ["conditional creation", "groupby", "value counts"], "New Column Name": "Winner", "Derivation Specification": "np.where(df['home_score']>df['away_score'],'Home','Away')", "Missing Data Column": ""}, {"query": "based on the number of matches, can you tell me what the distribution of cities is", "Relevant data columns": ["city"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_city_counts = df['city'].value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what countries have won a similar number of games", "Relevant data columns": ["country"], "Data column classification": ["inferred"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider only wins or also draws.", "Ambiguity resolution": "Count both win and draw outcomes separately for each team and then compare distributions.", "Data transformations": "win_count = df[(df['home_score']>df['away_score']) & (df['neutral']==False)].groupby('home_team')['home_score'].count().reset_index(name='wins'); win_count.columns = ['team','wins']; draw_count = df[(df['home_score']==df['away_score'])].groupby('home_team')['home_score'].count().reset_index(name='draws'); draw_count.columns = ['team','draws']", "Data transformation operation": ["filter", "groupby", "count", "merge"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how likely is it that, if i was born in 2000, i was born in a county with no less than 20,000 people", "Relevant data columns": ["County", "April 1, 2000 Population"], "Data column classification": ["inferred", "data_value_mention"], "Low-level visualization task": ["count", "filter"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only counties where population is exactly 20,000 or more.", "Ambiguity resolution": "Consider all counties where population is at least 20,000.", "Data transformations": "df_filtered = df[(df['April 1, 2000 Population'] >= 20000)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "identify the county that has the least population each year", "Relevant data columns": ["County", "State", "July 1, 2000\nPopulation", "July 1, 2001\nPopulation", "July 1, 2002\nPopulation"], "Data column classification": ["inferred", "inferred", "keyword", "keyword", "keyword"], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need to consider only one year at a time or compare populations across multiple years.", "Ambiguity resolution": "Consider each year separately and then combine results", "Data transformations": "year_2000_min_population_county = df.loc[df['July 1, 2000\\nPopulation'].idxmin()]; year_2001_min_population_county = df.loc[df['July 1, 2001\\nPopulation'].idxmin()]; year_2002_min_population_county = df.loc[df['July 1, 2002\\nPopulation'].idxmin()]", "Data transformation operation": ["sort", "min", "loc"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average population in 2000", "Relevant data columns": ["April 1, 2000 Population"], "Data column classification": ["keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df['Average Population in 2000'] = df['April 1, 2000 Population'].mean()", "Data transformation operation": ["calculate mean"], "New Column Name": "Average Population in 2000", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "from all of the universities in london, list the one who has the most faculties", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The dataset does not contain information about London universities or their faculty count", "Ambiguity resolution": "Provide a separate dataset containing London university information and faculty counts", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Faculty Count"}, {"query": "universities with similar number of teachers", "Relevant data columns": ["Num"], "Data column classification": ["keyword"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The phrase similar' could mean within a certain range or identical.", "Ambiguity resolution": "Identify universities with the same number of teachers or those whose numbers fall within a small interval.", "Data transformations": "same_num_teachers = df.loc[(df['Num'] - df['Num']).abs() <= 1]; close_range_teachers = df.loc[(df['Num'] - df['Num']).abs() <= 5]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the universities cover which locations", "Relevant data columns": ["Location"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "locations = df['Location'].unique()", "Data transformation operation": ["unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the teacher distribution of new york universities", "Relevant data columns": ["Location", "Name"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we want to look at just one university in New York or multiple.", "Ambiguity resolution": "Filter by location equals 'New York'", "Data transformations": "new_york_universities = df[df['Location']=='NY']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "would teachers in harvard be considered outliers if the university was in new york", "Relevant data columns": ["Name", "Location"], "Data column classification": ["data value mention", "data value mention"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "it's unclear what characteristic makes someone an outlier", "Ambiguity resolution": "Consider the tuition fees distribution to determine if the Harvard's tuition fee is significantly higher than others when located in New York", "Data transformations": "new_df = df[(df['Location']=='New York')] ; mean_tuition_new_york = new_df['Tuition'].mean() ; std_deviation_tuition_new_york = new_df['Tuition'].std()", "Data transformation operation": ["filter", "calculate mean", "calculate standard deviation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the number of divisions in harvard university", "Relevant data columns": ["Name", "Num"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['Name']=='Harvard University'),'Num']", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a regional concentration trend in gdp development", "Relevant data columns": ["Country", "GDP"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of regional concentration' is ambiguous and open-ended.", "Ambiguity resolution": "Identify clusters of similar GDP values among neighboring countries.", "Data transformations": "from sklearn.cluster import KMeans; kmeans = KMeans(n_clusters=3); labels = kmeans.fit_predict(df[['GDP']]); df['Cluster'] = labels;", "Data transformation operation": ["clustering"], "New Column Name": "Cluster", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how are gdp and mteu correlated", "Relevant data columns": ["mTEU", "GDP"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['mTEU','GDP']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the propensity of the number of vehicles in japan and korea from the year 2000 to 2010", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The given dataset does not contain information about Japan, Korea, or vehicle numbers.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Number of Vehicles, Country"}, {"query": "does life expectancy have any relation with the percentage of smokers", "Relevant data columns": ["Life Expectancy (by years)", "Percentage of Smokers"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Life Expectancy (by years)','Percentage of Smokers']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is the male to female ratio more imbalanced in the last decade in russia", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["compare", "trend"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The given dataset does not contain information about Russia, so it's impossible to answer the question directly.", "Ambiguity resolution": "Use another dataset containing Russian demographics", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Male population, Female population"}, {"query": "is the speed of economic development relative to the population of each country", "Relevant data columns": ["Median Income 2007", "Population 2007"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value", "compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of speed of economic development' is ambiguous and could refer to multiple measures such as income growth rate, GDP growth rate, etc.", "Ambiguity resolution": "Assume median income growth rate as a proxy for economic development", "Data transformations": "df[['Median Income 2007', 'Population 2007']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you tell me the continental location of the poorest ( lowest income ) country", "Relevant data columns": ["Median Income 2007", "State"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "poorest_state = df.loc[df['Median Income 2007'].idxmin()]; continent_location = df_continent_map[poorest_state['State']] ", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "when looking at the average income in european countries, what is the variance", "Relevant data columns": ["Median Income 2007"], "Data column classification": ["inferred"], "Low-level visualization task": ["retrieve value", "compute derived value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether European countries refer to states within Europe or actual European countries since the given dataset appears to contain US state information.", "Ambiguity resolution": "Assuming the question refers to calculating the variance of median incomes in general rather than specifically for European countries due to the mismatch between the dataset and the query.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do countries with high populations wish to slow down population growth", "Relevant data columns": ["Population"], "Data column classification": ["keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The query does not specify whether we're looking at cities or countries, also doesn't clarify what slowing down population growth means.", "Ambiguity resolution": "Assuming it refers to analyzing correlation between population size and desire to slow down population growth rate, focusing on cities rather than countries since the dataset only has US cities.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the state which may have the largest average population in the next year", "Relevant data columns": ["State", "Population"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["forecasting"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The concept of 'next year' is ambiguous since we don't know the exact date range.", "Ambiguity resolution": "Assume the next year refers to a future time period close to the given dates.", "Data transformations": "future_year_population = df.groupby('State')['Population'].apply(lambda x: np.mean(x) + np.std(x))", "Data transformation operation": ["groupby", "aggregate", "predict"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are the students who are younger more likely to use wechat", "Relevant data columns": ["age", "social App"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "wechat_users = df[df['social App']=='wechat']; young_students = df[df['age']<np.mean(df['age'])]; result = pd.crosstab(young_students['age'], wechat_users['social App'])", "Data transformation operation": ["filter", "compare", "crosstab"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which movie is the highest -grossing", "Relevant data columns": ["Movie", "Revenue ($)"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['Revenue ($)].idxmax()]", "Data transformation operation": ["find max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me if there is a correlation between revenue and the release year", "Relevant data columns": ["Revenue ($)", "Release Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Release Year', 'Revenue ($)']].corr()", "Data transformation operation": ["correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how much revenue did \" titanic \" earn", "Relevant data columns": ["Movie", "Revenue ($)"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['Movie']=='Titanic'),'Revenue ($)']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Relationship between IMDB Rating and Rotten Tomatoes Rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which creative type had the most movies", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "creative_type_counts = df['Creative Type'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "For each genre and rating, what is the total world-wide gross earnings", "Relevant data columns": ["Major Genre", "Content Rating", "Worldwide Gross"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize", "group by"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider multiple ratings within a genre separately.", "Ambiguity resolution": "Group by both genre and rating, then aggregate worldwide gross earnings.", "/Data transformations": "genre_rating_gross = df.groupby(['Major Genre', 'Content Rating'])['Worldwide Gross'].sum()", "@Data transformation operation": ["groupby", "summarize"], "New Column Name": "", "Derivation Specification": "", "Miscellaneous Column": ""}, {"query": "Help me see outliers in IMDB and Rotten Tomatoes ratings", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["identify outlier"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import numpy as np; q1 = df['Rotten Tomatoes Rating'].quantile(0.25); q3 = df['Rotten Tomatoes Rating'].quantile(0.75); iqr = q3 - q1; lower_bound_rt = q1 - 1.5*iqr; upper_bound_rt = q3 + 1.5*iqr; \"q1_imdb = df['IMDB Rating'].quantile(0.25); q3_imdb = df['IMDB Rating'].quantile(0.75); iqr_imdb = q3_imdb - q1_imdb; lower_bound_imdb = q1_imdb - 1.5*iqr_imdb; upper_bound_imdb = q3_imdb + 1.5*iqr_imdb;", "Data transformation operation": ["calculate quantiles", "calculate IQR", "calculate bounds"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "gross across genres regarding content rating", "Relevant data columns": ["Content Rating", "Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize", "group by"], "Low-level visualization task classification": ["inferred", "synonym"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the focus is on average grossing or total grossing across genres.", "Ambiguity resolution": "Calculate both average and total grossing across genres by content rating.", "/Data transformations": "genre_gross = df.groupby(['Content Rating', 'Major Genre'])['Worldwide Gross'].agg(['sum', mean'])", "@Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Miscellaneous Column": ""}, {"query": "relation between rotten tomatoes rating and IMDB rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Miscellaneous": ""}, {"query": "Cumulative gross for each content rating, by major genre", "Relevant data columns": ["Content Rating", "Major Genre", "Worldwide Gross"], "/Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compute derived value", "grouping"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['Content Rating', 'Major Genre'])['Worldwide Gross'].sum()", "@Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Relation between worldwide gross and production budget for each major genre", "Relevant data columns": ["Worldwide Gross", "Production Budget", "Major Genre"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["retrieve value", "group by", "correlation"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.pivot_table(index='Major Genre', values=['Worldwide Gross', 'Production Budget'])", "Data transformation operation": ["pivot_table"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Relationship of Rotten Tomatoes rating to IMDB rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which cylinder cars have the highest fuel economy", "Relevant data columns": ["cylinders", "mpg"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[:, ['cylinders', mpg']].groupby('cylinders')['mpg'].max()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which countries have the most cars in this dataset", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to count the number of rows for each country or perform any other aggregation.", "Ambiguity resolution": "Count the number of rows for each country.", "Data transformations": "df_country_count = df.groupby('country')['mpg'].count().reset_index(name='count')", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How do the horsepowers of the cars from different regions change with years", "Relevant data columns": ["hp", "year", "country"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the horsepower changes over time within each region or overall.", "Ambiguity resolution": "Separate the horsepower by region and plot their trends against year.", "Data transformations": "region_hp_trends = df.groupby(['country', 'year'])['hp'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "The distribution of the number of cylinders of cars based on different origins", "Relevant data columns": ["cylinders", "country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the distribution should be shown separately for each origin or combined", "Ambiguity resolution": "Separate distributions by origin", "@Data transformations": "df_grouped = df.groupby('country')['cylinders'].value_counts().reset_index(name='counts'); df_pivot = df_grouped.pivot(index='cylinders', columns='country', values='counts')", "/Data transformation operation": ["groupby", "pivot"], "/New Column Name": "", "/Derivation Specification": "", "/Missing Data Column": ""}, {"query": "how does displacement relate to mpg for individual models, partitioned by country", "Relevant data columns": ["cubicinches", "mpg", "country"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlation", "characterize distribution"], "Low-level visualization task classification": ["keyword", "keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate the data by country before examining the relation between displacement and mpg.", "Ambiguity resolution": "No aggregation needed since we want to see relationships at individual model level", "/Data transformations": "df[['cubicinches', mpg', 'country']].copy()", "@Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how does weight relate to acceleration for car models, small multiples by origin", "Relevant data columns": ["weightlbs", "timeto60", "country"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compute derived value", "small multiple plots by origin"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The phrase small multiples' implies faceting but it's unclear whether separate charts are needed for each region/country or one chart showing differences between regions/countries.", "Ambiguity resolution": "Create facets by origin, plot relationships within each facet", "/Data transformations": "import matplotlib.pyplot as plt; import seaborn as sns; sns.set(style='whitegrid'); g = sns.FacetGrid(df, col='country', col_wrap=3); g.map(plt.scatter, 'weightlbs', 'timeto60')", "@Data transformation operation": ["facet grid", "scatterplot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how is acceleration related to horsepower", "Relevant data columns": ["timeto60", "hp"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['timeto60', 'hp']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the distribution of weight across all cars", "Relevant data columns": ["weightlbs"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['weightlbs']].describe()", "Data transformation operation": ["summary statistics"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How has AVG (Horsepower) evolved over time | Segregate it by the car origin", "Relevant data columns": ["hp", "year", "country"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["compute derived value", "time series", "grouping"], "Low-level visualization task classification": ["keyword", "synonym", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether the average horsepower should be taken for individual cars or overall across all models from a particular region", "Ambiguity resolution": "Take average horsepower across all models from a particular region", "Data transformations": "df_grouped = df.groupby(['year', 'country'])['hp'].mean().reset_index()", "Data transformation operation": ["groupby", "aggregate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many cars are from each region", "Relevant data columns": ["country"], "/Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_counts = df['country'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "For each region, how does a car's MPG vary with displacement", "Relevant data columns": ["mpg", "cubicinches", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["correlation", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider other factors such as horsepower when analyzing the variation of MPG with displacement.", "Ambiguity resolution": "Focus solely on the relationship between MPG and displacement by region.", "Data transformations": "df_grouped = df.groupby('country')[['mpg', 'cubicinches']].corr()", "Data transformation operation": ["groupby", "correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How has horsepower changed over time in each region", "Relevant data columns": ["hp", "year", "country"], "Data column classification": ["keyword", "inferred", "data value mention"], "Low-level visualization task": ["Trend", "Compare"], "Low-level visualization task classification": ["Inferred", "Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_grouped = df.groupby(['country', 'year'])['hp'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average profit for each state", "Relevant data columns": ["State", "Profit"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "state_profit_avg = df.groupby('State')['Profit'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the sales forecast for each date", "Relevant data columns": ["Order Date", "Sales Forecast"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need to aggregate sales forecasts by day or show individual orders.", "Ambiguity resolution": "Aggregate sales forecasts by order date.", "Data transformations": "df.groupby('Order Date')['Sales Forecast'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Density of sales across regions and their profitability", "Relevant data columns": ["Region", "Sales", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether density refers to geographical distribution or statistical density", "Ambiguity resolution": "Assume density refers to statistical density of sales and profit across regions", "Data transformations": "df_region_sales_profit = df[['Region', 'Sales', 'Profit']].copy(); df_region_sales_profit['Sales_Density'] = df_region_sales_profit.groupby('Region')['Sales'].transform(lambda x: x / x.sum()); df_region_sales_profit['Profitability'] = df_region_sales_profit['Profit'] / df_region_sales_profit['Sales'];", "Data transformation operation": ["groupby", "transform", "calculate"], "New Column Name": ["Sales_Density", "Profitability"], "Derivation Specification": "'Sales_Density' = regional sales / total sales in region, 'Profitability' = profit / sales", "Missing Data Column": ""}, {"query": "What is the average profit of different segments on the ship modes of transport", "Relevant data columns": ["Profit", "Segment", "Ship Mode"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_grouped = df.groupby(['Segment', 'Ship Mode'])['Profit'].mean()", "Data transformation operation": ["groupby", "average"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Can you create a graph showing sales and profit by region", "Relevant data columns": ["Region", "Sales", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compare", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_sales_profit = df.groupby('Region')[['Sales', 'Profit']].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Where are storms most common depending on the time of year", "Relevant data columns": ["month", "lat", "long"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider other factors like category/status of storms.", "Ambiguity resolution": "Focus on overall distribution of storms without considering their categories/status", "Data transformations": "storms_per_month = df.groupby('month')['status'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there more storms in recent years", "Relevant data columns": ["year", "name", "status"], "Data column classification": ["keyword", "infered", "keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether recent years' refers to a specific time period or the latest available data.", "Ambiguity resolution": "Assume recent years' means the most recent years in the dataset.", "Data transformations": "df_yearly_counts = df.groupby('year')['name'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What month has the strongest hurricanes", "Relevant data columns": ["month", "category", "wind"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The strength of hurricane is subjective and could refer to either wind speed or another factor.", "Ambiguity resolution": "Use wind speed as the measure of hurricane strength", "/Data transformations": "df.groupby('month')['wind'].max()", "@Data transformation operation": ["groupby", "aggregate max"], "New Column Name": "", "Derivation Specification": "", "Miscellaneous Data Columns": ""}, {"query": "How has wind speed changed over time", "Relevant data columns": ["wind", "year", "month", "day", "hour"], "Data column classification": ["keyword", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["trend"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we want overall trends, or daily/monthly/yearly changes.", "Ambiguity resolution": "Assuming overall trend across entire timeframe is desired", "Data transformations": "df[['hour', 'day', month', 'year', 'wind']].resample('D')['wind'].mean()", "Data transformation operation": ["resample", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which hurricane lasted the longest", "Relevant data columns": ["name", "year", "month", "day", "hour"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only storms with certain categories (like tropical storm) or all types.", "Ambiguity resolution": "Consider all types of hurricanes/storms", "Data transformations": "df[['name','year','month','day','hour']].groupby('name')['hour'].apply(lambda x : max(x)-min(x))", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "storm_duration", "Derivation Specification": "((df.groupby('name')['hour'].max() - df.groupby('name')['hour'].min()).astype(int)", "Missing Data Column": ""}, {"query": "What is the relationship between level of education and crime rate", "Relevant data columns": ["education", "police", "intent"], "Data column classification": ["keyword", "keyword", "infered"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need to consider only certain types of crimes.", "Ambiguity resolution": "Consider overall crime rates regardless of type.", "Data transformations": "df[['Education', 'Police']].corr()", "Data transformation operation": ["correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any correlations between crime types and geographic location", "Relevant data columns": ["incident_characteristics", "latitude", "longitude"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "crime_data = df[['incident_characteristics', 'latitude', 'longitude']].dropna()", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the distribution for non-violent crimes based on age", "Relevant data columns": ["incident_age", "incident_characteristics"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'non-violent' crime is ambiguous and could refer to various types of incidents.", "Ambiguity resolution": "Assume non-violent crimes exclude homicides, suicides, and undetermined intents.", "Data transformations": "filtered_data = data[(data['incident_characteristics']!='Homicide') & (data['incident_characteristics']!='Suicide')] ; grouped_data = filtered_data.groupby('incident_age')['incident_id'].count()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many incidents of gun violence result in death (Ie what proportion are fatal vs non-fatal)", "Relevant data columns": ["incident_id", "date", "state", "city_or_county", "address", "n_killed", "n_injured"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "fatal_incidents = df[(df['n_killed']>0)]; non_fatal_incidents = df[(df['n_injured']>0)&(df['n_killed']==0)]", "Data transformation operation": ["filter", "logical operation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are males or females more likely to die of gun violence", "Relevant data columns": ["sex", "intent"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["relationship", "comparision"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('police')['sex'].value_counts()", "Data transformation operation": ["groupby", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the distribution of births across all districts in 2017", "Relevant data columns": ["District Name", "Number", "Year"], "Data column classification": ["inferred", "keyword", "inferred"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_2017 = df[df['Year']==2017]; district_births = df_2017[['District Name', 'Number']].copy()", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "retrieve the neighborhood with more than 100 female births in ciutat vella in 2013", "Relevant data columns": ["District Name", "Neighborhood Name", "Gender", "Number", "Year"], "Data column classification": ["keyword", "keyword", "keyword", "data value mention", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The query mentions 2013 but the dataset only has 2017 data.", "Ambiguity resolution": "Assume the query wants data from any available year since 2013 data is not present", "Data transformations": "df_female_ciutat_vella_2017 = df[(df['Year']==2017)&(df['District Name']=='Ciutat Vella')&(df['Gender']=='Girls')] ; result_df = df_female_ciutat_vella_2017[df_female_ciutat_vella_2017['Number']>100][['Neighborhood Name', 'Number']]", "Data transformation operation": ["filter", "compare", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "barcelona 's districts, please list each", "Relevant data columns": ["District Code", "District Name"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "districts_list = df[['District Code', 'District Name']].drop_duplicates()", "Data transformation operation": ["select", "distinct"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the most recent version of androids \" discover color \"", "Relevant data columns": ["Android Ver"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether 'Discover Color' refers to a specific app or feature.", "Ambiguity resolution": "", "Data transformations": "df.loc[df['Android Ver'] == df['Android Ver'].max()]", "Data transformation operation": ["sort", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me a list of all the free business apps that have received rating that were higher than a 45", "Relevant data columns": ["Category", "Rating", "Price", "Type"], "Data column classification": ["keyword", "keyword", "keyword", "inferenced"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "free_business_apps = df[(df['Category']=='BUSINESS')&(df['Price']=='Free')&(df['Rating']>4.5)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what 's the price distribution in beauty apps", "Relevant data columns": ["Price", "Category", "Genres"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether only free or paid Beauty Apps should be considered.", "Ambiguity resolution": "Consider both free and paid Beauty Apps.", "Data transformations": "beauty_apps_df = df[(df['Category']=='BEAUTY') | (df['Genres']==\"Beauty\")] ; beauty_price_distribution = beauty_apps_df['Price'].value_counts()", "Data transformation operation": ["filter", "groupby", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the app with the most abnormal pattern", "Relevant data columns": ["App", "Rating", "Reviews", "Installs"], "Data column classification": ["keyword", "inferred", "inferred", "inferred"], "Low-level visualization task": ["find anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what constitutes an 'abnormal' pattern.", "Ambiguity resolution": "Define anomaly as significant deviation from mean or median rating/reviews/installs", "Data transformations": "from scipy import stats; anomalies = df[(np.abs(stats.zscore(df[['Rating', 'Reviews', 'Installs']])) > 3).any(axis=1)]", "Data transformation operation": ["z-score calculation", "filtering"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "according to population, what is the rank of each of region", "Relevant data columns": ["Population", "Region"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "ranked_regions = df.sort_values(by='Population', ascending=False).reset_index(drop=True)", "Data transformation operation": ["sort", "reset index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the number of hospitals located in manyara", "Relevant data columns": ["Region", "Hospital"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['Region']=='Manyara', ['Hospital']].values[0]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the number of clinics that are in mara", "Relevant data columns": ["Region", "Clinic"], "Data column classification": ["data value mention", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "Mara region is missing from the given dataset", "Ambiguity resolution": "The answer cannot be determined without including the Mara region in the dataset.", "Data transformations": "None since the required information is not available in the dataset", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Mara region's data"}, {"query": "enter the regions from this table", "Relevant data columns": ["Region"], "Data column classification": ["data value mention"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Region']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the population range needs to be discovered", "Relevant data columns": ["Population"], "Data column classification": ["keyword"], "Low-level visualization task": ["range", "discover"], "Low-level visualization task classification": ["keyword", "inferenced"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider the entire range of populations or focus on certain segments/percentiles.", "Ambiguity resolution": "Determine the range by calculating percentiles/min-max values.", "Data transformations": "df.describe()['Population']", "Data transformation operation": ["summary statistic"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you list all the results in the table about the movie \" about schmidt  \"", "Relevant data columns": ["nominee film"], "Data column classification": ["data value mention"], "Low-level visualization task": ["retrieve value", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['nominee film']=='About Schmidt']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me who won the best performance by an actor in a motion picture - drama award at the 60th ceremony", "Relevant data columns": ["category", "nominee film", "win", "ceremony"], "Data column classification": ["inferred", "inferred", "keyword", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The question asks about the winner of the 'best performance by an actor' but the given dataset does not contain information about actors, only films", "Ambiguity resolution": "Assume the query actually means to ask about winners in general categories, rather than specifically the 'actor' one", "Data transformations": "result_df = df[(df['ceremony']==60)&(df['category']==\"Best Motion Picture - Drama\")&(df['win']==True)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "i would like to review the dispersement of the amount of nominations", "Relevant data columns": ["nominee", "category", "year_film", "ceremony"], "Data column classification": ["inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether you want to see distribution by categories, ceremonies, films, or overall total nominations", "Ambiguity resolution": "Count number of nominees for each unique combination of category and ceremony, then plot the distribution", "Data transformations": "nominations_per_category_ceremony = df.groupby(['category', 'ceremony']).size()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what was the number of candidates that were nominated for best performance by an actor in a motion picture -drama at he 60th ceremony", "Relevant data columns": ["category", "ceremony", "nominee"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["count"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The question asks about nominees for best performance by an actor but the data does not contain information about actors. It only contains information about films.", "Ambiguity resolution": "Assume the question refers to the total number of nominations in the drama category at the 60th ceremony", "Data transformations": "df[(df['ceremony']==60)&(df['category']=='Best Motion Picture - Drama')]['nominee'].count()", "Data transformation operation": ["filter", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me what movie won best original score in a motion picture in 1997", "Relevant data columns": ["category", "year_award", "nominee film", "win"], "Data column classification": ["keyword", "data value mention", "keyword", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["exact match", "exact match"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df[(df['year_award']==1997)&(df['category']=='Best Original Score')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "find all the types of genetic diseases with greater than 1,000 patients", "Relevant data columns": ["ALBINO", "AUTISM", "DEAF-MUTE", "DEAF-BLIND", "MENTALLY IMPAIRED", "PHYSICAL IMPAIRED", "VISUALLY IMPAIRED"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether only one type of disease needs to exceed 1,000 patients or any combination of them.", "Ambiguity resolution": "Check each type separately", "Data transformations": "result_df = df[(df[['ALBINO','AUTISM','DEAF-MUTE','DEAF-BLIND','MENTALLY IMPAIRED','PHYSICAL IMPAIRED','VISUALLY IMPAIRED']] > 1000).any(axis=1)]", "Data transformation operation": ["filter", "compare"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "does this data represent outliers in the number of patients", "Relevant data columns": ["REGION", "ALBINO", "AUTISM"], "Data column classification": ["inferred", "number of patients"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'outlier' could imply different statistical methods such as Z-score method, Modified Z-score method, Interquartile Range(IQR), Density-Based Spatial Clustering of Applications with Noise(DBSCAN)", "Ambiguity resolution": "", "Data transformations": "from scipy import stats; z_scores = np.abs(stats.zscore(df)); threshold = 3; outliers = abs(z_scores) > threshold", "Data transformation operation": ["calculate z-scores", "thresholding"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "take out the regions with a number of patients larger than 500", "Relevant data columns": ["REGION", "ALBINO", "AUTISM"], "Data column classification": ["inferred", "inferred", "inferred"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["directed_by_user"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_regions = df[(df[['ALBINO', 'AUTISM', 'DEAF-MUTE', 'DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']] > 500).any(axis=1)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there an obvious clustering", "Relevant data columns": ["REGION", "ALBINO", "AUTISM"], "Data column classification": ["inferred", "inferred", "inferred"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what type of clustering is being referred to (e.g., hierarchical, k-means), and whether any pre-processing steps need to be taken.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the games are sorted by experts by their date", "Relevant data columns": ["date game", "player name", "goals"], "Data column classification": ["inferred", "inferred", "keyword"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you show me the list sorted by study time ( longest to shortest )", "Relevant data columns": ["studytime"], "Data column classification": ["keyword"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='studytime', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me which students have fathers that are teachers", "Relevant data columns": ["Fjob", "famrel"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['Fjob']=='teacher') & (df['famrel']!='no')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "retrieve the students with fathers who work as teachers", "Relevant data columns": ["Fjob", "guardian"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df['Fjob']=='teacher') & (df['guardian']=='father')]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a correlation between happiness scores and other attributes", "Relevant data columns": ["Happiness Score", "Economy (GDP per Capita)", "Family", "Health (Life Expectancy)", "Freedom", "Trust (Government Corruption)", "Generosity", "Dystopia Residual"], "Data column classification": ["keyword", "inferenced", "inferenced", "inferenced", "inferenced", "inferenced", "inferenced", "inferenced"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider individual correlations or multiple correlations at once.", "Ambiguity resolution": "Compute pairwise correlations among variables and then analyze the results.", "Data transformations": "corr_matrix = df[['Happiness Score', 'Economy (GDP per Capita)', 'Family', 'Health (Life Expectancy)', 'Freedom', 'Trust (Government Corruption)', 'Generosity', 'Dystopia Residual']].corr()", "Data transformation operation": ["compute correlation matrix"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me any clustering there may be in the gdp that has a happiness score of larger than 5", "Relevant data columns": ["Happiness Score", "Economy (GDP per Capita)", "Region"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of clustering is vague and requires further clarification", "Ambiguity resolution": "Perform density-based clustering on GDP per capita values where Happiness Score > 5", "Data transformations": "filtered_df = df[(df['Happiness Score']>5)]; filtered_df[['Economy (GDP per Capita)','Region']].apply(lambda x: x.astype(float))", "Data transformation operation": ["filter", "cast_to_float"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "within the last year have any countries experienced a sudden decrease in happiness score", "Relevant data columns": ["Happiness Score", "Country", "Region"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["filter", "determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what constitutes a sudden decrease' and whether the focus is on absolute change or relative change.", "Ambiguity resolution": "Use a threshold-based approach to detect anomalies; Calculate percentage changes from previous year", "Data transformations": "last_year_data = df.sort_values(by='Happiness Score', ascending=False).drop_duplicates(subset='Country', keep='first')[['Country', 'Happiness Score]]; prev_year_data = df.sort_values(by='Happiness Score', ascending=True).drop_duplicates(subset='Country', keep='last')[['Country', 'Happiness Score']; diff_scores = pd.merge(last_year_data, prev_year_data, on='Country')['Happiness Score_x'] - ['Happiness Score_y']; pct_change = (diff_scores / ['Happiness Score_y']) * 100;", "Data transformation operation": ["sort", "drop duplicates", "merge", "calculate difference", "calculate percentage change"], "New Column Name": "pct_happiness_decrease", "Derivation Specification": "(happiness_score_current_year - happiness_score_prev_year) / happiness_score_prev_year * 100", "Missing Data Column": ""}, {"query": "can you tell me in what range will the number of countries in each region fall", "Relevant data columns": ["Region"], "Data column classification": ["keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_counts = df['Region'].value_counts()", "Data transformation operation": ["count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show a list of similarly rated books", "Relevant data columns": ["averageRating", "title"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["find similarities"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear what rating threshold defines similarity.", "Ambiguity resolution": "Define a range around the target book's rating to determine similar ratings", "Data transformations": "similar_books = df[(df['averageRating'] >= target_rating - 0.5) & (df['averageRating'] <= target_rating + 0.5)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "dark horse comic has how many books", "Relevant data columns": ["title", "publisher"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether Dark Horse Comic refers to a specific author/publisher or just any book from Dark Horse Comics.", "Ambiguity resolution": "Assume Dark Horse Comic refers to the publisher named 'Dark Horse Comics'. Filter by publisher.", "Data transformations": "filtered_df = df[df['publisher']=='Dark Horse Comics']; count_books = filtered_df.shape[0]", "Data transformation operation": ["filter", "shape"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "put the readings in order according to their pm 10 values", "Relevant data columns": ["PM10 Value", "Station"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='PM10 Value')", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me the count of missing readings in this table", "Relevant data columns": ["Station", "Air Quality", "O3 Value", "NO2 Value", "PM10 Value"], "Data column classification": ["inferred", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["count", "filter"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.count() - df.isnull().sum()", "Data transformation operation": ["count", "isnull", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the data attribute that has the most na values, for example the hardest data points to collect", "Relevant data columns": ["O3 Hour", "NO2 Hour", "PM10 Hour"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "describe the change in air quality over one day  describe the change in each air pollutant", "Relevant data columns": ["Generated", "O3 Value", "NO2 Value", "PM10 Value", "Air Quality"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["determine range", "characterize distribution", "compare"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider all stations separately or aggregate them somehow", "Ambiguity resolution": "Aggregate readings from multiple stations into daily averages", "Data transformations": "daily_avg_o3 = df.resample('D', on='Generated')['O3 Value'].mean();daily_avg_no2 = df.resample('D', on='Generated')['NO2 Value'].mean();daily_avg_pm10 = df.resample('D', on='Generated')['PM10 Value'].mean();air_quality_trends = df.groupby('Generated')['Air Quality'].value_counts().unstack()", "Data transformation operation": ["resample", "groupby", "value counts", "unstack"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you search all available values for pm10 quality", "Relevant data columns": ["PM10 Quality"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "pm10_quality_values = df['PM10 Quality'].dropna().unique()", "Data transformation operation": ["filter", "unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "across the monitored region, what is the distribution of records for good air quality", "Relevant data columns": ["Air Quality", "Station"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["determine range", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "good_air_quality_records = df[df['Air Quality']=='Good']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "for the center forward position, what was the highest market value for the 2011 -2012 season", "Relevant data columns": ["Position", "Market_value", "Season"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["find extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "center_forward_players = df[(df['Position']=='Centre-Forward') & (df['Season']==\"2010-2011\")]; max_market_value_player = center_forward_players.loc=center_forward_players['Market_value'].idxmax()", "Data transformation operation": ["filter", "groupby", "idxmax"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what percentage of the blount county, alabama population is white", "Relevant data columns": ["White", "County", "State"], "Data column classification": ["keyword", "data value mention", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['County']==\"Blount County\") & (df['State']==\"Alabama\"), ['White']]['White'].iloc[0]", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "sort all the counties in connecticut by the percentages of the hispanic population", "Relevant data columns": ["County", "State", "Hispanic"], "Data column classification": ["inferred", "inferred", "keyword"], "Low-level visualization task": ["sort", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear why only Connecticut counties were specified when the data includes other states", "Ambiguity resolution": "Filter out non-Connecticut counties from the data", "/Data transformations": "connecticut_counties = df[df['State']=='Connecticut']; sorted_connecticut_counties = connecticut_counties.sort_values(by='Hispanic', ascending=False)", "<Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the sales distribution of type 4046 in 2015", "Relevant data columns": ["type", "year", "Total Volume"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the user wants to see the overall volume distribution or compare it with other types.", "Ambiguity resolution": "Assuming they want to visualize the total volume distribution for type 4046 in 2015.", "Data transformations": "filtered_df = df[(df['type']==4046) & (df['year']==2015)]; filtered_df[['Total Volume']].describe()", "Data transformation operation": ["filter", "select", "summary statistic calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "state the average income of postgraduate students in each country", "Relevant data columns": ["Postgraduate Income", "Country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_grouped = df.groupby('Country')['Postgraduate Income'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "arrange the students by grade and furnish me with a list", "Relevant data columns": ["Grade", "Student"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Grade')", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the distribution of the total points of the students", "Relevant data columns": ["Total Points"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Total Points']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "was the same midterm exam given to velma paul and glynis caine", "Relevant data columns": ["First Name", "Last Name", "Mid-term exams"], "Data column classification": ["data value mention", "data value mention", "keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The person 'glynis caine' does not exist in the provided dataset.", "Ambiguity resolution": "Assume the correct full name is available in the dataset", "Data transformations": "None needed since we're only checking if two students had the same mid-term exam scores", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "glynis caine (does not exist in the dataset)"}, {"query": "provide the total sum of all the separated, divorced, and widowed people in lindi", "Relevant data columns": ["Regions", "Separated", "Divorced", "Widowed"], "Data column classification": ["inferred", "keyword", "keyword", "keyword"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["targeted"], "Ambiguity in the query": "Lindi region is missing from the given dataset.", "Ambiguity resolution": "Since Lindi is not present in the dataset, we cannot provide the exact count. However, we can guide the user to either add the required data or clarify which region they meant instead.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Lindi"}, {"query": "can you tell me how mara attributes are distributed", "Relevant data columns": ["Regions"], "Data column classification": ["data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's ambiguous whether Mara refers to a specific region or attribute distribution in general.", "Ambiguity resolution": "Assume Mara is one of the regions in the dataset.", "Data transformations": "mara_data = df.loc[df['Regions']=='Mara']", "<Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there similarities between gdp per capita and suicide rates", "Relevant data columns": ["gdp_per_capita ($)", "suicides/100k pop"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compare", "find anomalies", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['gdp_per_capita ($)', suicides/100k pop']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "were there any countries with abnormally low suicide rates", "Relevant data columns": ["country", "suicides_no", "population", "suicides/100k pop"], "Data column classification": ["inferred", "keyword", "keyword", "keyword"], "Low-level visualization task": ["determine range", "characterize distribution", "find anomalies"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'abnormally' could mean different things depending on the statistical method used.", "Ambiguity resolution": "Use standard deviation from the mean to detect anomalies", "Data transformations": "df['z_score_suicide_rate'] = ((df['suicides/100k pop'] - df['suicides/100k pop'].mean())/df['suicides/100k pop'].std()); abnormal_rates = df[(np.abs(df['z_score_suicide_rate']) > 2)]", "Data transformation operation": ["calculate z-score", "filter"], "New Column Name": "z_score_suicide_rate", "Derivation Specification": "(x - mu)/sigma where x is the suicides/100k pop', mu is the mean of suicides/100k pop', sigma is the std dev of suicides/100k pop'", "Mising Data Column": ""}, {"query": "would there be any clustering of countries in terms of suicide rates", "Relevant data columns": ["country", "suicides_no", "population", "suicides/100k pop"], "Data column classification": ["inferred", "keyword", "keyword", "keyword"], "Low-level visualization task": ["retrieve value", "group by dimension reduction", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider only certain demographics like age groups or sexes while analyzing the clustering.", "Ambiguity resolution": "Consider overall suicide rate for each country without demographic filters", "Data transformations": "df_country_level_suicide_rate = df.groupby('country')['suicides/100k pop'].mean().reset_index()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "for the gdp of china, has it gone up or down over the last decade", "Relevant data columns": ["country", "year", "gdp_for_year ($)"], "Data column classification": ["keyword", "inferred", "keyword"], "Low-level visualization task": ["trend"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'last decade' could refer to any period of ten consecutive years, but without more information about when exactly this question is being asked.", "Ambiguity resolution": "Assuming the current date is known, determine the range of years from ten years ago until now", "Data transformations": "china_gdp_data = df[(df['country']=='China') & ((df['year']>=(datetime.now().year - 10))&(df['year']<=datetime.now().year))] ; china_gdp_trend = china_gdp_data.sort_values(by='year')['gdp_for_year ($)']", "Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "has there been an increase or decrease in the gdp of china over the last 10 years", "Relevant data columns": ["country", "year", "gdp_for_year ($)"], "Data column classification": ["data value mention", "inferred", "keyword"], "Low-level visualization task": ["trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only China or any other countries too.", "Ambiguity resolution": "", "<Data transformations": "china_gdp_data = df[(df['country']=='China') & ((df['year']>= max(df['year']) - 10) & (df['year']<= max(df['year'])))]", "<Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you provide a list of school names in geita", "Relevant data columns": ["NAME", "REGION"], "Data column classification": ["data value mention", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_schools = df[(df['REGION']=='GEITA')] ['NAME']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what group of nations of have the most games", "Relevant data columns": ["country"], "Data column classification": ["inferred"], "Low-level visualization task": ["grouping", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether 'group of nations' refers to individual countries or a collection of countries.", "Ambiguity resolution": "Assume 'group of nations' means individual countries and count the number of games played by each country.", "Data transformations": "df_country_counts = df.value_counts('country')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how can the population of ashley be illustrated to show distribution across five years", "Relevant data columns": ["County", "July 1, 2000 Population", "July 1, 2001 Population", "July 1, 2002 Population"], "Data column classification": ["data value mention", "keyword", "keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "ashley_data = df.loc[df['County']=='Ashley'][['July 1, 2000 Population','July 1, 2001 Population','July 1, 2002 Population']].T", "Data transformation operation": ["filter", "transpose"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me the average population rating for ashley in the year 2000", "Relevant data columns": ["County", "July 1, 2000 Population"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["retrieve value", "filter"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "ashley_population_2000 = df.loc[df['County']==\"Ashley\", ['July 1, 2000 Population']].values[0]", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me a university that has more than 30 faculties and more than 50 teachers", "Relevant data columns": ["Name", "Num"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["filter", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The terms faculty and teacher are ambiguous since they do not match any exact column names.", "Ambiguity resolution": "Assume faculty refers to the 'Type' column and teacher refers to the 'Tuition' column", "Data transformations": "df[(df['Num']>30)&(df['Tuition']>50)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "faculties"}, {"query": "show me the gdp ranking of european countries", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["ranking"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The original dataset does not contain European countries' GDP information.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "European Countries' GDP Information"}, {"query": "to cluster the states in the us, i wish to use middle income", "Relevant data columns": ["Median Income 2007", "State"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether other variables such as life expectancy or smoking habits will also be considered during clustering.", "Ambiguity resolution": "Only consider median income when performing clustering.", "Data transformations": "df[['State', 'Median Income 2007']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do all the countries in africa have a lower average pci than all the countries in europe", "Relevant data columns": ["Median Income 2007", "State"], "Data column classification": ["keyword", "not relevant but needed for filtering"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'countries' does not match any column header. It's unclear whether we need to consider only certain types of entities.", "Ambiguity resolution": "Assume states' refer to geographic regions within continents rather than independent nations", "Data transformations": "african_states = df.loc[df['State'].str.contains('Africa|Algeria|Angola|Benin|Botswana|Burkina Faso|Burundi|Cameroon|Cape Verde|Central African Republic|Chad|Comoros|Congo|DRC|Djibouti|Egypt|Equatorial Guinea|Eritrea|Ethiopia|Gabon|Gambia|Ghana|Guinea|Guinea-Bissau|Kenya|Lesotho|Liberia|Libya|Mali|Mauritania|Mauritius|Morocco|Mozambique|Namibia|Niger|Rwanda|Sao Tome and Principe|Senegal|Seychelles|Sierra Leone|Somalia|South Africa|South Sudan|Sudan|Swaziland|Tanzania|Togo|Tunisia|Uganda|Zambia|Zimbabwe')] ; european_states = df.loc[df['State'].str.contains('Austria|Belgium|Bulgaria|Croatia|Cyprus|Czech Republic|Denmark|Estonia|Finland|France|Germany|Greece|Hungary|Iceland|Italy|Latvia|Liechtenstein|Lithuania|Luxembourg|Malta|Monaco|Montenegro|Netherlands|North Macedonia|Norway|Poland|Portugal|Romania|Russia|San Marino|Serbia|Slovakia|Slovenia|Spain|Sweden|Switzerland|Turkey|UK|Vatican City')] ; african_pci_avg = african_states['Median Income 2007'].mean() ;"}, {"query": "what are the minimum and maximum populations of the chinese provinces", "Relevant data columns": ["Population"], "Data column classification": ["keyword"], "Low-level visualization task": ["filter", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The data does not contain Chinese provinces but US states.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a typical film lengths group", "Relevant data columns": [], "Data column classification": [], "Ambiguity in the query": "The term 'typical' is ambiguous and could refer to mean, median or mode. Also, 'film length' is missing from the given dataset.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Film Length", "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"]}, {"query": "the chart teaches them the horsepower range", "Relevant data columns": ["horsepower"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "None needed since the original dataframe already has the required information.", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}]