[{"query": "what's the production budget for movies in different years", "Relevant data columns": ["Production Budget", "Release Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Release Year')['Production Budget'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between release year and average production budget", "Relevant data columns": ["Release Year", "Production Budget"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "production_budget_avg_per_year = df.groupby('Release Year')['Production Budget'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What major genre had the lowest average worldwide gross", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_df = df.groupby('Major Genre')['Worldwide Gross'].mean().reset_index()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many movies are there are of each creative type", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Creative Type')['Title'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the total worldwide gross for each major genre across time", "Relevant data columns": ["Worldwide Gross", "Major Genre", "Release Year"], "Data column classification": ["keyword", "keyword", "inferenced"], "Low-level visualization task": ["compute derived value", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_over_time = df.groupby(['Major Genre', 'Release Year'])['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a relationship between production budget and worldwide gross for each content rating", "Relevant data columns": ["Production Budget", "Worldwide Gross", "Content Rating"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Content Rating')[['Production Budget', 'Worldwide Gross']].corr()", "Data transformation operation": ["groupby", "calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a relationship between IMDB rating and rotten tomatoes rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "None needed, just plot the two ratings against each other.", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How production budge changes over release years", "Relevant data columns": ["Production Budget", "Release Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Release Year', 'Production Budget']].groupby('Release Year')['Production Budget'].plot()", "Data transformation operation": ["groupby"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What was the average production budget of movies by year", "Relevant data columns": ["Production Budget", "Release Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Release Year')['Production Budget'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which genre movie makes most worldwide gross", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Find Maximum", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_df = df.groupby('Major Genre')['Worldwide Gross'].sum().reset_index()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are IMDb rating and rotten tomatoes rating related", "Relevant data columns": ["IMDB Rating", "Rotten Tomatoes Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "corr_coef = df[['IMDB Rating', 'Rotten Tomatoes Rating']].corr().iloc[0,1]", "Data transformation operation": ["calculate correlation coefficient"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the worldwide gross distribution per genre", "Relevant data columns": ["Worldwide Gross", "Major Genre"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_dist = df.groupby('Major Genre')['Worldwide Gross'].describe()", "Data transformation operation": ["groupby", "summary stats"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what's the breakdown of production budget by creative type per content rating", "Relevant data columns": ["Production Budget", "Creative Type", "Content Rating"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['Content Rating', 'Creative Type'])['Production Budget'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much did each type of movie earn in across the whole world", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross = df.groupby('Major Genre')['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Compare imdb rating to rotten tomatoes rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "None needed, both ratings already exist in separate columns.", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which creative types have the most movies", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Creative Type')['Title'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many movies are of each length", "Relevant data columns": ["Running Time"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.value_counts('Running Time')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Help me see outliers in IMDB and Rotten Tomatoes ratings", "Relevant data columns": ["IMDB Rating", "Rotten Tomatoes Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import numpy as np; Q1_IMDB = df['IMDB Rating'].quantile(0.25); Q3_IMDB = df['IMDB Rating'].quantile(0.75); IQR_IMDB = Q3_IMDB - Q1_IMDB; lower_bound_IMDB = Q1_IMDB - 1.5*IQR_IMDB; upper_bound_IMDB = Q3_IMDB + 1.5*IQR_IMDB; outliers_IMDB = df[(df['IMDB Rating'] < lower_bound_IMDB) | (df['IMDB Rating'] > upper_bound_IMDB)]; Q1_RT = df['Rotten Tomatoes Rating'].quantile(0.25); Q3_RT = df['Rotten Tomatoes Rating'].quantile(0.75); IQR_RT = Q3_RT - Q1_RT; lower_bound_RT = Q1_RT - 1.5*IQR_RT; upper_bound_RT = Q3_RT + 1.5*IQR_RT; outliers_RT = df[(df['Rotten Tomatoes Rating'] < lower_bound_RT) | (df['Rotten Tomatoes Rating'] > upper_bound_RT)]", "Data transformation operation": ["quantile", "calculate IQR", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much did major genres gross in total", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize", "compute derived value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross = df.groupby('Major Genre')['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many movies are there in 20 minute bins of running time", "Relevant data columns": ["Running Time"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "bins = np.arange(80, 140, 20); bin_counts = df.groupby(pd.cut(df['Running Time'], bins=bins)).size()", "Data transformation operation": ["cut", "groupby"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many movies are there for each creative type", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Creative Type')['Title'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which creative types had the most movies", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.value_counts('Creative Type')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Show me the variation in the amount ordered by different entities in different orders", "Relevant data columns": ["Production Budget", "Major Genre", "Creative Type", "Release Year", "Title"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "data value mention"], "Low-level visualization task": ["characterize distribution", "sort"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'entities' could refer to either genres, creative types, release years, or even titles.", "Ambiguity resolution": "Consider multiple options for defining entities - genre-wise, type-wise, yearly basis, title-wise variations in production budget", "Data transformations": "genre_wise_variation = df.groupby('Major Genre')['Production Budget'].describe(); type_wise_variation = df.groupby('Creative Type')['Production Budget'].describe(); yearly_variation = df.groupby('Release Year')['Production Budget'].describe()", "Data transformation operation": ["groupby", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "relation between rotten tomatoes rating and IMDB rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "relation between rotten tomatoes and IMDB ratings", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many films of each creative type", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df['Count']=1; df_count = df.groupby('Creative Type')['Count'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "Count", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Cumulative gross for each content rating, by major genre", "Relevant data columns": ["Content Rating", "Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize", "correlate"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['Content Rating', 'Major Genre'])['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "summarize"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Relationship of Rotten Tomatoes rating to IMDB rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']] ", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a correlation between acceleration and horsepower", "Relevant data columns": ["timeto60", "hp"], "Data column classification": ["synonym", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['timeto60', 'hp']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many heavy cars are in the dataset", "Relevant data columns": ["weightlbs"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'heavy' is ambiguous without a clear definition.", "Ambiguity resolution": "Define 'heavy' as weights above a certain threshold (e.g., mean + std)", "Data transformations": "import numpy as np; heavy_cars_weight_threshold = np.mean(df['weightlbs']) + np.std(df['weightlbs']); heavy_cars_count = len(df[(df['weightlbs']>heavy_cars_weight_threshold)])", "Data transformation operation": ["calculate mean", "calculate standard deviation", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any American 5 cylinder cars", "Relevant data columns": ["country", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "american_cars = df[(df['country']=='US.') & (df['cylinders']==5)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does displacement relate to fuel economy for cars from Europe v USA", "Relevant data columns": ["cubicinches", "mpg", "country"], "Data column classification": ["keyword", "keyword", "data_value_mention"], "Low-level visualization task": ["correlate", "compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "eu_cars = df[df['country']=='Europe']; us_cars = df[df['country']=='US']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the correlation between displacement and MPG of cars with different origins", "Relevant data columns": ["cubicinches", "mpg", "country"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['cubicinches','mpg','country']].groupby('country')[['cubicinches','mpg']].corr()", "Data transformation operation": ["groupby", "calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a correlation between cars' horsepower and acceleration", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp','timeto60']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many cylinders do cars manufactured in different countries have", "Relevant data columns": ["cylinders", "country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we want to show overall distribution of cylinder count by country or average/median cylinder count.", "Ambiguity resolution": "Show both overall distribution and median cylinder count by country.", "Data transformations": "df_country_cylinder_dist = df[['country', 'cylinders']].groupby('country')['cylinders'].value_counts().reset_index(name='count'); df_median_cylinder_count_by_country = df.groupby('country')['cylinders'].median().reset_index(name='median_cylinders')", "Data transformation operation": ["groupby", "value counts", "median"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many cars do each country manufacture", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_country_counts = df.groupby('country')['mpg'].count().reset_index(name='counts')", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What's the mileage for cars based on the number of cylinders present", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['mpg', 'cylinders']].groupby('cylinders')['mpg'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how is acceleration related to horsepower", "Relevant data columns": ["timeto60", "hp"], "Data column classification": ["synonym", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['timeto60', 'hp']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many models are proudced by each country", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize", "Compare"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('country')['mpg'].count()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much do various cars weigh", "Relevant data columns": ["weightlbs"], "Data column classification": ["keyword"], "Low-level visualization task": ["Retrieval"], "Low-level visualization task classification": ["Inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['weightlbs']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the range of weights for all cars", "Relevant data columns": ["weightlbs"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = [df['weightlbs'].min(), df['weightlbs'].max()]", "Data transformation operation": ["minimum", "maximum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "where do the cars originate from", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['country']].value_counts()", "Data transformation operation": ["aggregation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How has AVG (Horsepower) evolved over time | Segregate it by the car origin", "Relevant data columns": ["hp", "year", "country"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["Trend", "Summarize"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "avg_hp_by_year_country = df.groupby(['year', 'country'])['hp'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does AVG (Weight) evolve over the years", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('year')['weightlbs'].mean()", "Data transformation operation": ["groupby", "average"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many cars are from each region", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_counts = df['country'].value_counts()", "Data transformation operation": ["aggregation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average weight of cars by model year", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('year')['weightlbs'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How has the average weight of cars changed over the years", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "average_weight_per_year = df.groupby('year')['weightlbs'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How do the company earn in each state", "Relevant data columns": ["Profit", "State"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize", "dependency"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "state_profit = df.groupby('State')['Profit'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What were the total sales for each date in each category", "Relevant data columns": ["Order Date", "Sales", "Category"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_grouped = df.groupby(['Order Date', 'Category'])['Sales'].sum().reset_index()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average profit of each ship mode divided by segment", "Relevant data columns": ["Ship Mode", "Segment", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compute derived value", "summarize", "compare"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_avg_profit_ship_mode_segment = df.groupby(['Ship Mode', 'Segment'])['Profit'].mean().reset_index()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many orders were placed for each order quantity", "Relevant data columns": ["Quantity", "Order ID"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "order_quantity_counts = df.value_counts('Quantity')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many orders were placed for each sub-category", "Relevant data columns": ["Sub-Category", "Order ID"], "Data column classification": ["keyword", "inferenced"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "order_counts = df.groupby('Sub-Category')['Order ID'].nunique()", "Data transformation operation": ["groupby", "count_unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the sales trend of the different product categories", "Relevant data columns": ["Sales", "Product Name", "Category"], "Data column classification": ["keyword", "inferred", "keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to aggregate sales by category over time.", "Ambiguity resolution": "Aggregate sales by category and plot over time.", "Data transformations": "import matplotlib.pyplot as plt; import seaborn as sns; df[['Category', 'Order Date', 'Sales']].groupby([pd.Grouper(key='Order Date', freq='M'), 'Category']).sum().unstack().plot(kind='line'); plt.show()", "Data transformation operation": ["groupby", "resample", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many products are ordered in single quantity", "Relevant data columns": ["Quantity"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "single_quantity_orders = df[df['Quantity']==1]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What are the profits across different states", "Relevant data columns": ["Profit", "State"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "state_profit_df = df.groupby('State')['Profit'].sum().reset_index()", "Data transformation operation": ["groupby", "sum", "reset index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What product category has more orders placed", "Relevant data columns": ["Product Name", "Quantity", "Category"], "Data column classification": ["inferred", "keyword", "keyword"], "Low-level visualization task": ["summarize", "compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "category_orders = df.groupby('Category')['Quantity'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the correlation between sales and profit by region", "Relevant data columns": ["Sales", "Profit", "Region"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_grouped = df.groupby('Region')[['Sales', 'Profit']].corr()", "Data transformation operation": ["groupby", "corr"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What months are hurricanes most common", "Relevant data columns": ["month"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "hurricane_months = df.value_counts('month')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Where are storms most common depending on the time of year", "Relevant data columns": ["month", "lat", "long"], "Data column classification": ["inferred", "keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution", "Trend"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "storm_counts_by_month = df.groupby(['month']).size()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there more storms in recent years", "Relevant data columns": ["year"], "Data column classification": ["keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term \"recent\" could refer to any time period.", "Ambiguity resolution": "Define recent years by calculating a moving average over time", "Data transformations": "import numpy as np; df['year_recent'] = np.where((df['year'] >= df['year'].quantile(0.75)), True, False); recent_storms_count = df.loc[df['year_recent']]['name'].value_counts()", "Data transformation operation": ["conditional statement", "value count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What does the distribution of the storms look like", "Relevant data columns": ["name", "status", "category"], "Data column classification": ["inferred", "keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['status','category']].value_counts()", "Data transformation operation": ["aggregation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the main factor depending on different status (wind, time, pressure, or etc)", "Relevant data columns": ["status", "category", "wind", "pressure"], "Data column classification": ["keyword", "keyword", "inferenced", "inferenced"], "Low-level visualization task": ["correlation", "relationship"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to focus on one particular type of status or look at overall patterns.", "Ambiguity resolution": "", "Data transformations": "dfpivot = df.pivot_table(index='status',values=['wind','pressure})", "Data transformation operation": ["pivot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What was the name of the earliest storm", "Relevant data columns": ["name", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "earliest_storm_name = df.loc[df['year'].idxmin()]['name']", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many hurricanes", "Relevant data columns": ["category"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "hurricane_count = (df['category']=='hurricane').sum()", "Data transformation operation": ["filter", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the name of the largest storm", "Relevant data columns": ["name", "wind", "ts_diameter", "hu_diameter"], "Data column classification": ["keyword", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'largest' could refer to either wind speed or diameter.", "Ambiguity resolution": "Assume 'largest' refers to max wind speed unless specified otherwise.", "Data transformations": "storm_max_wind = df.loc[df['wind'].idxmax()]", "Data transformation operation": ["find extreme"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What storm had the greatest diameter of tropical storm strength winds", "Relevant data columns": ["name", "ts_diameter", "category"], "Data column classification": ["inferred", "keyword", "keyword"], "Low-level visualization task": ["Find Maximum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's ambiguous whether we need to consider only rows where category equals 'tropical storm'", "Ambiguity resolution": "Filter out rows where category does not equal 'tropical storm' ", "Data transformations": "filtered_df = df[(df['category']=='tropical storm')] ; filtered_df.loc[filtered_df['ts_diameter'].idxmax()]", "Data transformation operation": ["filter", "sort_by_value"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a correlation between wind speed and air pressure", "Relevant data columns": ["wind", "pressure"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['wind', 'pressure']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a correlation between the duration of the storm and wind speed", "Relevant data columns": ["name", "year", "month", "day", "hour", "wind"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of duration of the storm is ambiguous since storms typically last over multiple days.", "Ambiguity resolution": "Define the start time of a storm as when its status changes from non-tropical depression/storm to tropical depression/storm and end time as vice versa", "Data transformations": "storms_df = df[(df.status!= 'non-tropical depression') & (df.status!= 'non-tropical storm')]; storms_df['start_time'] = storms_df.groupby('name')['hour'].transform('first'); storms_df['end_time'] = storms_df.groupby('name')['hour'].transform('last'); storms_df['duration_hours'] = storms_df['end_time'] - storms_df['start_time']", "Data transformation operation": ["filter", "groupby", "transform", "calculate difference"], "New Column Name": "duration_hours", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What lat/long locations are most likely to experience hurricanes", "Relevant data columns": ["lat", "long"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to focus only on hurricane categories or consider other types of storms too.", "Ambiguity resolution": "Filter out non-hurricane rows from the dataset", "Data transformations": "hurricanes_only_df = df[(df['category']!='-1') & (df['status']!='tropical depression')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average storm length", "Relevant data columns": ["name", "year", "month", "day", "hour"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider storms separately by their names.", "Ambiguity resolution": "Consider separate storms as individual entities when calculating average storm lengths", "Data transformations": "storms = df.groupby('name')[['year', month', 'day', 'hour']].apply(lambda x: ((x.iloc[-1] - x.iloc[0]).total_seconds())/3600)", "Data transformation operation": ["groupby", "apply", "subtract", "divide"], "New Column Name": "storm_length_hours", "Derivation Specification": "(end_time - start_time).total_seconds()/3600", "Missing Data Column": ""}, {"query": "What is the relationship, if any, between wind and pressure", "Relevant data columns": ["wind", "pressure"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['wind','pressure']] ", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Average tropical storm diameter", "Relevant data columns": ["ts_diameter", "category"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "storm_data = df[df['category'] == 'tropical storm']; avg_ts_diameter = storm_data['ts_diameter'].mean()", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between storm day and hu_diameter", "Relevant data columns": ["day", "hu_diameter"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['day', 'hu_diameter']].dropna()", "Data transformation operation": ["select", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any repeat names of storms", "Relevant data columns": ["name"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Duplicate Values"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "storm_names_counts = df['name'].value_counts()", "Data transformation operation": ["count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What month has the strongest hurricanes", "Relevant data columns": ["month", "category"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "hurricane_months = df.loc[(df['status']!='tropical depression'), ['month','wind']].groupby('month')['wind'].max()", "Data transformation operation": ["filter", "groupby", "aggregation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How has wind speed changed over time", "Relevant data columns": ["wind", "year", "month", "day", "hour"], "Data column classification": ["keyword", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['year', month', 'day', 'hour', 'wind']].groupby([pd.Grouper(key='year'), pd.Grouper(freq='M')]).mean()", "Data transformation operation": ["groupby", "resample", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which hurricane lasted the longest", "Relevant data columns": ["name", "year", "month", "day", "hour"], "Data column classification": ["keyword", "keyword", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'hurricane' could refer to any row where the status' is either 'tropical depression' or 'tropical storm'", "Ambiguity resolution": "Filter rows where status' is either 'tropical depression' or 'tropical storm'; Calculate duration by grouping consecutive hours for each unique 'name'", "Data transformations": "storms_df = df[(df['status']=='tropical depression') | (df['status']=='tropical storm)]; storms_df['datetime'] = pd.to_datetime(storms_df[['year','month','day','hour']].assign(DAY=lambda x:x.day.astype(str).str.zfill(2))); storms_duration = storms_df.resample('H',on='datetime')['name'].count().reset_index()", "Data transformation operation": ["filter", "merge", "resample", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between level of education and crime rate", "Relevant data columns": ["education", "intent"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['education']).agg({'intent': ['count']}))", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the most frequent place of violent crime", "Relevant data columns": ["city_or_county"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "counts = df['city_or_county'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the distribution for non-violent crimes based on age", "Relevant data columns": ["incident_id", "date", "state", "city_or_county", "address", "n_killed", "n_injured", "congressional_district", "gun_stolen", "gun_type", "incident_characteristics", "latitude", "location_description", "longitude", "n_guns_involved", "state_house_district", "state_senate_district"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["characterize distribution", "filter"], "Low-level visualization task classification": ["keyword", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "non_violent_crimes_by_age = df[(~df['incident_characteristics'].str.contains('Shot')) & (~df['incident_characteristics'].str.contains('Dead')) & (~df['incident_characteristics'].str.contains('Murder'))]; non_violent_crimes_by_age_grouped = non_violent_crimes_by_age.groupby('Age')['incident_id'].count()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What city has the highest crime rate", "Relevant data columns": ["city_or_county"], "Data column classification": ["keyword"], "Low-level visualization task": ["Retrieving Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "crime_rate_per_city = df.groupby('city_or_county')['incident_id'].count().sort_values(ascending=False)", "Data transformation operation": ["groupby", "count", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many gun violence incidents are there each year", "Relevant data columns": ["incident_id", "date"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df['year'] = df['date'].dt.year; df_yearly_counts = df.groupby('year')['incident_id'].count()", "Data transformation operation": ["extract", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many incidents of gun violence result in death (Ie what proportion are fatal vs non-fatal)", "Relevant data columns": ["incident_id", "date", "state", "city_or_county", "address", "n_killed", "n_injured"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred", "keyword", "keyword"], "Low-level visualization task": ["aggregation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "fatal_incidents = df[(df['n_killed']>0)]; non_fatal_incidents = df[(df['n_injured']>0)&(df['n_killed']==0)];", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are males or females more likely to die of gun violence", "Relevant data columns": ["sex", "intent"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df.intent.str.contains('Suicide|Homicide|Accidental'))]; male_deaths = df[df.sex=='M']['intent'].value_counts(); female_deaths = df[df.sex=='F']['intent'].value_counts()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are most gun death because of suicide", "Relevant data columns": ["intent"], "Data column classification": ["keyword"], "Low-level visualization task": ["proportion"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.intent.value_counts()", "Data transformation operation": ["value count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Did most gun violence happen inside home", "Relevant data columns": ["place"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution", "find proportion"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_place_data = df[df['place']!='NaN']; proportion_inside_home = filtered_place_data[filtered_place_data['place']=='Home']['incident_id'].count() / filtered_place_data['incident_id'].count()", "Data transformation operation": ["filter", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the correlation between education levels and suicide rates", "Relevant data columns": ["education", "intent"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_grouped = df.groupby(['education']).agg({'intent': ['count', mean']}); corr_matrix = df_grouped.corr()", "Data transformation operation": ["groupby", "aggregate", "corr"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which state/year has the most gun deaths", "Relevant data columns": ["state", "year"], "Data column classification": ["keyword", "inferenced"], "Low-level visualization task": ["retrieval", "extreme value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['state', 'year']).sum()['Firearm deaths (People)']", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which neighborhood in ciutat vella has more than 100 females born in the year 2013", "Relevant data columns": ["Neighborhood Name", "District Name", "Gender", "Number", "Year"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "data value mention"], "Low-level visualization task": ["Filter", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df['District Name']=='Ciutat Vella') & (df['Year']==2013) & (df['Gender']=='Females')] ; result = df[df['Number']>100]['Neighborhood Name']", "Data transformation operation": ["filter", "conditional selection"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "barcelona 's districts, please list each", "Relevant data columns": ["District Code", "District Name"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["Retreive Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "districts_df = df[['District Code', 'District Name']].drop_duplicates()", "Data transformation operation": ["distinct", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what neighborhood had 56 boys born in 2017", "Relevant data columns": ["Neighborhood Name", "Number", "Gender", "Year"], "Data column classification": ["keyword", "data value mention", "data value mention", "data value mention"], "Low-level visualization task": ["Filter", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['Year']==2017)&(df['Gender']=='Boys')&(df['Number']==56)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the total number of categories", "Relevant data columns": ["Category"], "Data column classification": ["keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "category_counts = df['Category'].nunique()", "Data transformation operation": ["count_unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "does a app exist that is much different than the others", "Relevant data columns": ["App", "Category", "Rating", "Reviews"], "Data column classification": ["data value mention", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of \"much different\" is subjective and requires further clarification.", "Ambiguity resolution": "Use statistical methods such as z-score calculation to determine outliers.", "Data transformations": "from scipy import stats; z_scores = np.abs(stats.zscore(df[['Rating', 'Reviews']], axis=0)); outlier_apps = df[(np.abs(z_scores)>3).any(axis=1)]", "Data transformation operation": ["statistical method"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the title of the biggest app", "Relevant data columns": ["App"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term \"biggest\" could refer to any attribute such as size, installs, ratings.", "Ambiguity resolution": "Assume by default the largest refers to the most installed apps ", "Data transformations": "largest_app = df.loc[df['Installs'].idxmax()]", "Data transformation operation": ["sort", "get max index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me free or paid apps have a higher mean rating", "Relevant data columns": ["Price", "Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "free_apps = df[df['Price']=='Free']; paid_apps = df[df['Price']!='Free']; free_mean_rating = free_apps['Rating'].mean(); paid_mean_rating = paid_apps['Rating'].mean()", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which genres are included in the dataset", "Relevant data columns": ["Genres"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Genres']].drop_duplicates()", "Data transformation operation": ["select", "distinct"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the app that costs the most", "Relevant data columns": ["Price"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[df['Price'].idxmax()]", "Data transformation operation": ["sort", "get max index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a relationship between the android version of an app and its installations", "Relevant data columns": ["Android Ver", "Installs"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Android Ver', 'Installs']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "when taking different android versions into account, does that have any impact on installation", "Relevant data columns": ["Android Ver", "Installs"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the question refers to individual apps or overall trends across multiple apps.", "Ambiguity resolution": "Aggregate install counts by Android version groups.", "Data transformations": "android_ver_groups = df.groupby(pd.cut(df['Android Ver'], bins=[4.0, 4.1, 4.4, 5.0]))['Installs'].sum()", "Data transformation operation": ["groupby", "binning", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the attribute ' 'rating ' ' be affected ' 'installation", "Relevant data columns": ["Rating", "Installs"], "Data column classification": ["direct mention", "direct mention"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rating', 'Installs']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which app has a rating that doesn 't follow a trend between installations, rating and number of reviews", "Relevant data columns": ["Rating", "Installs", "Reviews"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of 'not following a trend' is ambiguous - does it mean outside certain standard deviations from the regression line?", "Ambiguity resolution": "Use statistical methods such as linear regression to model relationships between variables, then identify outliers.", "Data transformations": "import statsmodels.api as sm; X = df[['Installs', 'Reviews ]]; y = df['Rating']; X = sm.add_constant(X); est = sm.OLS(y,X).fit()", "Data transformation operation": ["linear regression"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the app with the most abnormal pattern", "Relevant data columns": ["App"], "Data column classification": ["data value mention"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what constitutes an abnormal pattern.", "Ambiguity resolution": "Use statistical methods such as standard deviation and mean absolute error to determine apps with unusual patterns in their metrics.", "Data transformations": "from scipy import stats; anomalies = []; for col in ['Rating', 'Reviews', 'Size', 'Installs']: df_col = df[col]; mean, std = stats.norm.fit(df_col); anomalies.extend((np.abs(stats.zscore(df_col)) > 2).tolist()); anomaly_app = df.loc[np.argmax(anomalies), 'App'];", "Data transformation operation": ["calculate statistic", "iterate over columns", "identify outliers"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are there an unusually high number of reviews for any of the apps", "Relevant data columns": ["Reviews"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import numpy as np; df['Reviews_logscale'] = np.log10(df['Reviews']+1)", "Data transformation operation": ["transform"], "New Column Name": "Reviews_logscale", "Derivation Specification": "np.log10(df['Reviews']+1)", "Missing Data Column": ""}, {"query": "what is the distribution of the number based on shape of installations", "Relevant data columns": ["Installs"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import matplotlib.pyplot as plt; df['Installs'].plot(kind='hist'); plt.show()", "Data transformation operation": ["visualization"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there an effect on price caused by the app 's genre", "Relevant data columns": ["Price", "Genres"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Price', 'Genres']].groupby('Genres')['Price'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a correlation between apps with more installations and higher ratings", "Relevant data columns": ["Installs", "Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Installs', 'Rating']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the most pricey apps by release date, recent to oldest", "Relevant data columns": ["Price", "Last Updated"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Sort", "Compute Derived Value", "Filter"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", " Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Last Updated', ascending=False); df_price_sorted = df[(df['Price']!='Free')&(df['Price']!='NaN')] ", "Data transformation operation": ["sort", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "find out any app that is distinctive from the rest", "Relevant data columns": ["App", "Category", "Rating", "Reviews", "Size", "Installs", "Type", "Price", "Content Rating", "Genres", "Last Updated", "Current Ver", "Android Ver"], "Data column classification": ["keyword", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of distinctiveness might mean multiple things such as most popular, highest rated, largest size etc.", "Ambiguity resolution": "Identify unusual patterns in individual features and overall trends", "Data transformations": "df.describe() and visualize distribution plots for numerical variables; boxplots or scatterplots for categorical vs numerical relationships", "Data transformation operation": ["summary stats", "visualizations"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "list the top 10 gaming apps sorted from highest to lowest installations", "Relevant data columns": ["Category", "Installs"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["sort", "filter", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether non-gaming apps need to be excluded from the result", "Ambiguity resolution": "Filter out non-gaming apps first", "Data transformations": "gaming_apps_df = df[df['Category']=='GAME']; sorted_gaming_apps_df = gaming_apps_df.sort_values(by='Installs', ascending=False).head(10)", "Data transformation operation": ["filter", "sort", "limit"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the price distribution of all the beauty apps", "Relevant data columns": ["Category", "Price"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether 'beauty' refers to a specific genre or category.", "Ambiguity resolution": "Assume 'beauty' falls under 'Lifestyle' category", "Data transformations": "lifestyle_apps = df[(df['Category'] == 'LIFESTYLE')] ; lifestyle_prices = lifestyle_apps['Price']", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name any apps that can support any version of android lower than 40", "Relevant data columns": ["Android Ver", "App"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['Android Ver'].str.contains('and up|1\\.6')]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "according to population, what is the rank of each of region", "Relevant data columns": ["Population", "Region"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Region','Population']].sort_values(by='Population', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "look up regions that names start with the letter a", "Relevant data columns": ["Region"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_regions = df[df['Region'].str.startswith('A')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "make a list of the number of total hfs in descending order", "Relevant data columns": ["Total HFs"], "Data column classification": ["keyword"], "Low-level visualization task": ["sort", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "sorted_df = df.sort_values(by='Total HFs', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average count of hospitals", "Relevant data columns": ["Hospital"], "Data column classification": ["keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "hospital_counts_avg = df['Hospital'].mean()", "Data transformation operation": ["calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which region has the lowest population ratio of hf", "Relevant data columns": ["ration of population over HF", "Region"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["Find Minimum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[df['ration of population over HF'].idxmin()]", "Data transformation operation": ["sort", "min"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "enter the regions from this table", "Relevant data columns": ["Region"], "Data column classification": ["data_value_mention"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Region']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "look for the region that has the most people living in it", "Relevant data columns": ["Region", "Population"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['Population'].idxmax()]", "Data transformation operation": ["sort", "get max index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the population range needs to be discovered", "Relevant data columns": ["Population"], "Data column classification": ["keyword"], "Low-level visualization task": ["Determine Range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "population_range = [df['Population'].min(), df['Population'].max()]", "Data transformation operation": ["summary statistic calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do any regions have their population ratio over 20 hf", "Relevant data columns": ["ration of population over HF"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['ration of population over HF']>2]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "out of the winners for best performance by an actor in a motion picture - musical or comedy from 2003 to 2020, the most abnormal age belongs to which actor", "Relevant data columns": ["category", "year_award", "nominee"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['category']=='Best Performance by an Actor in a Motion Picture - Musical or Comedy') & (df['win']==True)]; filtered_df[['year_award','nominee']].merge(actor_ages,on='nominee')", "Data transformation operation": ["filter", "merge"], "New Column Name": "age_abnormality", "Derivation Specification": "(actor_age-mean_actor_age)/std_actor_age where mean_actor_age and std_actor_age are computed over the ages of actors winning in the specified time period ", "Missing Data Column": "actor_age"}, {"query": "what was the gender of all actors among all the final winners in the 60th ceremony", "Relevant data columns": ["ceremony", "win"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["Filter", "Compute Derived Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear where actor information will come from since only nominees and films are present in the given dataset.", "Ambiguity resolution": "Assume actor information would need to be retrieved externally or merged into this dataset", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "actor information"}, {"query": "tell me who won the best performance by an actor in a motion picture - drama award at the 60th ceremony", "Relevant data columns": ["category", "ceremony", "win", "nominee"], "Data column classification": ["inferred", "data value mention", "inferred", "inferred"], "Low-level visualization task": ["Filter", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['category']=='Best Performance by an Actor in a Motion Picture - Drama') & (df['ceremony']==60)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in the 60th ceremony, the award for best performance by an actor in a motion picture was won by whom", "Relevant data columns": ["ceremony", "category", "nominee", "win"], "Data column classification": ["data value mention", "keyword", "inferred", "inferred"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df['ceremony']==60) & ((df['category']=='Best Performance by an Actor in a Motion Picture'))]; winner_nominee = df.loc[df['win']==True,'nominee']", "Data transformation operation": ["filter", "loc"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what was the number of candidates that were nominated for best performance by an actor in a motion picture -drama at he 60th ceremony", "Relevant data columns": ["ceremony", "category", "nominee"], "Data column classification": ["data value mention", "keyword", "inferred"], "Low-level visualization task": ["Filter", "Compute Derived Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_data = df[(df['ceremony']==60) & (df['category']=='Best Performance by an Actor in a Motion Picture - Drama')] ; result = filtered_data.shape[0]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the total number of movies released in the year 1998", "Relevant data columns": ["year_film"], "Data column classification": ["keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['year_film']==1998]['nominee film'].nunique()", "Data transformation operation": ["filter", "unique count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me what movie won best original score in a motion picture in 1997", "Relevant data columns": ["year_award", "category", "nominee film", "win"], "Data column classification": ["inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['year_award']==1997)&(df['category']=='Best Original Score')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the correlation between the nomination and the age of a star", "Relevant data columns": ["nominee"], "Data column classification": ["inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The query does not specify what kind of correlation is expected, also age of a star is not present in the given dataset.", "Ambiguity resolution": "Assume that the correlation refers to statistical correlation coefficient, but since the age of stars is missing from the dataset, we need to make assumptions about where to get this information from.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "star_age", "Derivation Specification": "(assuming we could fetch birth dates of nominees from another source)", "Missing Data Column": "birth date/year of nominees, or age of stars"}, {"query": "find all the types of genetic diseases with greater than 1,000 patients", "Relevant data columns": ["ALBINO", "AUTISM", "DEAF-MUTE", "DEAF-BLIND", "MENTALLY IMPAIRED", "PHYSICAL IMPAIRED", "VISUALLY IMPAIRED"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Filter", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_data = df[(df[['ALBINO', 'AUTISM', 'DEAF-MUTE', 'DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']] > 1000).any(axis=1)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the maximum and minimum number of patients with autism across all regions", "Relevant data columns": ["REGION", "AUTISM"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_autism_max_min = df[['REGION','AUTISM']].groupby('REGION')['AUTISM'].agg(['max', min']).reset_index()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "does this data represent outliers in the number of patients", "Relevant data columns": ["REGION", "ALBINO", "AUTISM", "DEAF-MUTE", "DEAF-BLIND", "MENTALLY IMPAIRED", "PHYSICAL IMPAIRED", "VISUALLY IMPAIRED"], "Data column classification": ["inferred", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "from scipy import stats; outliers = {} \nfor col in ['ALBINO', 'AUTISM', 'DEAF-MUTE', 'DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']: \noutliers[col] = np.abs(stats.zscore(df[col])) > 3;", "Data transformation operation": ["z-score calculation", "filtering"], "New Column Name": "outliers", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what was the total amount of goals scored in the game that liverpool played in", "Relevant data columns": ["goals", "game"], "Data column classification": ["keyword", "inferenced from context"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'Liverpool' does not appear anywhere in the given dataset.", "Ambiguity resolution": "Since the team names were not provided, we cannot accurately determine the desired game.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "team"}, {"query": "can you name an unusual reason for choosing this school", "Relevant data columns": ["reason"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[:, ['reason']].value_counts() ", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the youngest students in the dataset", "Relevant data columns": ["age"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Extremum", "Retreive Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "youngest_students = df.loc[df['age']==df['age'].min()]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the types of jobs the student 's mothers have", "Relevant data columns": ["Mjob"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Mjob']].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "would more time spent on studying reduce travel time for students", "Relevant data columns": ["studytime", "traveltime"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['studytime', 'traveltime']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name me a country that 's happiness score does not coincide with the region it belongs to", "Relevant data columns": ["Happiness Score", "Region", "Country"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compare", "filter"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear how to define when a country's happiness score doesn't coincide with its region.", "Ambiguity resolution": "Compare average happiness scores by regions against individual country happiness scores within those regions.", "Data transformations": "region_scores = df.groupby('Region')['Happiness Score'].mean(); df['score_diff_from_region_avg'] = df.apply(lambda row: abs(row['Happiness Score'] - region_scores.loc[row['Region']]), axis=1)", "Data transformation operation": ["groupby", "calculate mean", "apply function"], "New Column Name": "score_diff_from_region_avg", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me, in terms of economy, what is the range across all countries", "Relevant data columns": ["Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Determine Range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Country','Economy (GDP per Capita)']].describe()", "Data transformation operation": ["describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what countries, other than finland, have higher happiness scores and lower gdp", "Relevant data columns": ["Happiness Score", "Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["filter", "compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['Happiness Score']>df.loc[df['Country']=='Finland','Happiness Score'][0]) & (df['Economy (GDP per Capita)']<df.loc[df['Country']=='Finland','Economy (GDP per Capita)'][0])] ", "Data transformation operation": ["filter", "compare"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the area in the previous decade that increased rapidly in the happiness score", "Relevant data columns": ["Region", "Happiness Score"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Find Trend"], "Low-level visualization task classification": ["Inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the increase in happiness score refers to absolute change or relative change.", "Ambiguity resolution": "Assume the question asks about regions where the happiness score has shown the largest growth rate in the past decade.", "Data transformations": "df.sort_values(by='Happiness Score').groupby('Region')['Happiness Score'].pct_change().reset_index()", "Data transformation operation": ["sort", "groupby", "calculate percentage change"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the range of happiness score in western europe", "Relevant data columns": ["Happiness Score", "Region"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "western_europe_data = df[df['Region']=='Western Europe']; western_europe_happiness_scores = western_europe_data['Happiness Score']", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "please identify the parameters of the happiness score in western europe", "Relevant data columns": ["Happiness Score", "Region"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "western_europe_data = df[df['Region']=='Western Europe'][['Happiness Score']] ", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name the continent that contains the greatest number of countries that are top 10 on the happiness index", "Relevant data columns": ["Region", "Happiness Rank"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "top_10_regions = df.loc[df['Happiness Rank'] <= 10]['Region']; region_counts = top_10_regions.value_counts() ", "Data transformation operation": ["filter", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do any countries have happiness scores that don 't match with their gdp", "Relevant data columns": ["Happiness Score", "Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Happiness Score', 'Economy (GDP per Capita)', 'Country']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "of all the countries trust score, which country has the lowest", "Relevant data columns": ["Trust (Government Corruption)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[df['Trust (Government Corruption)'].idxmin()]", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name the country that scores the least on trust", "Relevant data columns": ["Trust (Government Corruption)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Find Minimum", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "trust_min_country = df.loc[df['Trust (Government Corruption)'].idxmin()]['Country']", "Data transformation operation": ["sort", "retrieve value"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the range across all the countries in terms of economy", "Relevant data columns": ["Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["Determine Range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Country', 'Economy (GDP per Capita)']].describe()", "Data transformation operation": ["describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "organize the countries based on happiness score, with the score limit on each group being 10", "Relevant data columns": ["Happiness Score", "Country"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["sort", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether groups should be created by dividing the range into equal parts or by setting fixed limits.", "Ambiguity resolution": "Divide the range of happiness scores into bins of size 0.7 (since 7.6 - 0 = 7.6 / 10 \u2248 0.76)", "Data transformations": "bins = [0, 7.0, 7.1]; grouped_data = df.groupby(pd.cut(df['Happiness Score'], bins=bins))", "Data transformation operation": ["cut", "groupby"], "New Column Name": "happiness_group", "Derivation Specification": "pd.cut(df['Happiness Score'], bins=[0, 7.0, 7.1])", "Missing Data Column": ""}, {"query": "for all the regions, can you show me the pattern of the happiness score", "Relevant data columns": ["Region", "Happiness Score"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_happiness_pattern = df.groupby('Region')['Happiness Score'].plot(kind='bar')", "Data transformation operation": ["groupby", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what are all the countries that have a happiness score similar to fineland  5 is an acceptable error score", "Relevant data columns": ["Happiness Score", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["retrieval by similarity"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "similar_finland_happiness_scores = df[(np.abs(df['Happiness Score'] - df.loc[df['Country']=='Finland', 'Happiness Score'].values[0]) <= 0.05)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "rank countries high to low by their family score", "Relevant data columns": ["Family", "Country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["sort", "retrieve value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Family', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what dimension of the happiness index has the maximum fluctuation", "Relevant data columns": ["Happiness Index dimensions"], "Data column classification": ["inferenced from context"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what constitutes a dimension of the happiness index.", "Ambiguity resolution": "Assume the dimensions refer to the categories like economy, family, health, freedom, trust, generosity, dystopia residual.", "Data transformations": "variances = [df[['Economy (GDP per Capita)', 'Family', 'Health (Life Expectancy)', 'Freedom', 'Trust (Government Corruption)', 'Generosity', 'Dystopia Residual']].var()]; max_variance_column = variances.idxmax()", "Data transformation operation": ["calculate variance", "find maximum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "across all regions, what is the happiness score pattern", "Relevant data columns": ["Region", "Happiness Score"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_happiness_scores = df.groupby('Region')['Happiness Score'].describe()", "Data transformation operation": ["groupby", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the health score is highest in which country", "Relevant data columns": ["Health (Life Expectancy)", "Country"], "Data column classification": ["keyword", "inferenced"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result=df.loc[df['Health (Life Expectancy)'].idxmax()]", "Data transformation operation": ["find max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the highest health score is held by which country", "Relevant data columns": ["Health (Life Expectancy)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['Health (Life Expectancy)'].idxmax()]", "Data transformation operation": ["sort", "get max index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the distribution for the book ratings", "Relevant data columns": ["averageRating"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['averageRating']].describe()", "Data transformation operation": ["describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the book ratings distribution", "Relevant data columns": ["averageRating"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['averageRating']].value_counts()", "Data transformation operation": ["value count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which author has worked with dark horse comics most frequently", "Relevant data columns": ["authors"], "Data column classification": ["keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The query doesn't specify whether we need to count only unique books or total books by an author.", "Ambiguity resolution": "Count total books by an author from Dark Horse Comics", "Data transformations": "dark_horse_comics_authors = df[(df['publisher']=='Dark Horse Comics')]; frequency_count = dark_horse_comics_authors['authors'].value_counts()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "please go and get all of the books written in english", "Relevant data columns": ["language"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "english_books = df[df['language']=='en']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are there outliers in the book ratings", "Relevant data columns": ["averageRating"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import numpy as np; Q1 = df['averageRating'].quantile(0.25); Q3 = df['averageRating'].quantile(0.75); IQR = Q3 - Q1; outliers = df[(df['averageRating'] < Q1 - 1.5*IQR) | (df['averageRating'] > Q3 + 1.5*IQR)]", "Data transformation operation": ["calculate quantiles", "identify outliers"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many books have been released by dark horse comics", "Relevant data columns": ["publisher"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "dark_horse_comics_books = df[df['publisher']=='Dark Horse Comics']; result = dark_horse_comics_books.shape[0]", "Data transformation operation": ["filter", "shape"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the most expensive book and who published it", "Relevant data columns": ["pageCount", "publisher"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[df['pageCount'].idxmax()]", "Data transformation operation": ["sort", "get max index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "please look at the o3 data and find the minimum number", "Relevant data columns": ["O3 Value"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Minimum", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "o3_min_value = df['O3 Value'].min()", "Data transformation operation": ["min"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me a day with extremely bad air quality", "Relevant data columns": ["O3 Quality", "NO2 Quality", "PM10 Quality"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "it's unclear whether 'extremely bad' refers to a specific threshold or ranking", "Ambiguity resolution": "", "Data transformations": "bad_air_quality_days = df[(df[['O3 Quality', 'NO2 Quality', 'PM10 Quality']].apply(lambda x: x.str.contains('Bad|Very Bad')).any(axis=1))]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what days had really bad air quality", "Relevant data columns": ["Station", "Air Quality"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "bad_air_quality_days = df[df['Air Quality']!='Good']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you search all available values for pm10 quality", "Relevant data columns": ["PM10 Quality"], "Data column classification": ["keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Generated','Station','Latitude','Longitude','PM10 Quality']].dropna()", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are the o3 value and the pm10 value dependent on each other", "Relevant data columns": ["O3 Value", "PM10 Value"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "corr_matrix = df[['O3 Value', 'PM10 Value']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me a reason why top backcourt players have a higher market value than the top frontcourt player", "Relevant data columns": ["Position", "Market_value"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'top' could refer to multiple definitions such as average, total, or peak.", "Ambiguity resolution": "Define 'top' as referring to the mean/average market value for both backcourt and frontcourt positions", "Data transformations": "backcourt_players = df[(df['Position']=='Right Winger') | (df['Position']=='Attacking Midfield')]; frontcourt_players = df[(df['Position']!='Centre-Back') & ((df['Position']=='Centre-Forward'))]; avg_market_backourt = backcourt_players['Market_value'].mean(); avg_market_frontcout = frontcourt_players['Market_value'].mean()", "Data transformation operation": ["filter", "groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which player had an abnormal transfer_fee", "Relevant data columns": ["Transfer_fee"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "from scipy import stats; Q1 = df['Transfer_fee'].quantile(0.25); Q3 = df['Transfer_fee'].quantile(0.75); IQR = Q3 - Q1; outlier_bound = Q3 + 1.5*IQR;", "Data transformation operation": ["calculate quantiles", "detect outliers"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how old was david when he was transferred in 2010", "Relevant data columns": ["Name", "Age", "Season"], "Data column classification": ["data value mention", "keyword", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "david_players = df[df['Name'].str.contains('David')]; result = david_players[david_players['Season']=='2010-2011']['Age']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what player had a market value of 50,000,000 and was transferred for 58,500,000 in the 2010\u201a\u00c4\u00ec2011", "Relevant data columns": ["Market_value", "Transfer_fee", "Season"], "Data column classification": ["data value mention", "data value mention", "data value mention"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['Market_value']==50000000.0) & (df['Transfer_fee']==58500000) & (df['Season']=='2010-2011')]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "for the center forward position, what was the highest market value for the 2011 -2012 season", "Relevant data columns": ["Position", "Market_value", "Season"], "Data column classification": ["keyword", "keyword", "inferenced from season range"], "Low-level visualization task": ["Find Maximum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "center_forward_players = df[(df['Position']=='Centre-Forward') & ((df['Season'] >= '2011') & (df['Season'] <= '2012'))]; max_market_value_player = center_forward_players.loc[center_forward_players['Market_value'].idxmax()] ", "Data transformation operation": ["filter", "logical indexing", "locate max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the numbers of the transferred players in different leagues in the 2010 -2011 season", "Relevant data columns": ["League_from", "League_to"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "league_transfers_count = df.value_counts(['League_from']).to_dict()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average transfer_fee for players who transferred to the premier league", "Relevant data columns": ["Transfer_fee", "League_to"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "premier_league_transfers = df[df['League_to']=='Premier League']; avg_transfer_fee_premierleague = premier_league_transfers['Transfer_fee'].mean()", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which player was the oldest that was transferred", "Relevant data columns": ["Age"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "oldest_player_age = df.loc[df['Age'].idxmax()]", "Data transformation operation": ["idxmax"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the distribution of the leagues who paid for transferred players in 2010", "Relevant data columns": ["League_to", "Season"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "league_distribution = df.loc[(df['Season']=='2010-2011'), ['League_to']].value_counts()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are you aware of any clustering of the seasons in which players were transferred to the premier league", "Relevant data columns": ["Season", "League_to"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'clustering' could imply either identifying patterns within individual season transfers or aggregating multiple seasons into clusters.", "Ambiguity resolution": "Assume the latter interpretation - grouping seasons by transfer activity.", "Data transformations": "season_transfer_counts = df.value_counts('Season')['Season']", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do you feel that midfield players have a lower market value than front court players", "Relevant data columns": ["Position", "Market_value"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The terms midfield players' and 'front court players' need clarification as they might refer to broader categories like defensive/attacking positions rather than just those exact phrases.", "Ambiguity resolution": " Clarify position categorization into defense, offense, and midfield ", "Data transformations": "df[['Position', 'Market_value']].groupby('Position')['Market_value'].median()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "name movies released in 2017", "Relevant data columns": ["release_year", "title"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['release_year']==2017), ['title']] ", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is the normal distribuition satisfied by the length of the movies", "Relevant data columns": ["duration"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import scipy.stats as stats; result = stats.normaltest(df['duration'])", "Data transformation operation": ["normal test"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "sort the movies by length", "Relevant data columns": ["duration"], "Data column classification": ["keyword"], "Low-level visualization task": ["Sort"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "sorted_df = df.sort_values(by='duration')", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how long is the run time of average r -rated movies", "Relevant data columns": ["rating", "duration"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "rRatedMovies = df[(df['rating']=='R')]; avgDuration = rRatedMovies['duration'].mean()", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me the numbers of movies that were released in 2017", "Relevant data columns": ["release_year"], "Data column classification": ["keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["Targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['release_year']==2017]", "Data transformation operation": ["Filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is the running time of movies recently longer than it used to be", "Relevant data columns": ["duration", "release_year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "recent_movies_duration = df[df['release_year']>2010]['duration']; past_movies_duration = df[(df['release_year']<2010)&(df['release_year']>1950)]['duration']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do movie tags and duration have a connection", "Relevant data columns": ["listed_in", "duration"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['listed_in', 'duration']].corr()", "Data transformation operation": ["correlate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "determine if the running time of movies has increased in recent years", "Relevant data columns": ["duration", "release_year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need to consider only certain types of movies or all movies in general.", "Ambiguity resolution": "Consider all movie genres together", "Data transformations": "df[['release_year', 'duration']].groupby('release_year')['duration'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "does any movies not have a description", "Relevant data columns": ["description"], "Data column classification": ["keyword"], "Low-level visualization task": ["existence check"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df['description'].notnull().any()", "Data transformation operation": [" existence check"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "at what point was data added to the table for netflix", "Relevant data columns": ["date_added"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['date_added']].head()", "Data transformation operation": ["select", "head"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the percentage of the white population in blount county, alabama", "Relevant data columns": ["White", "County"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['County'] == 'Blount County'), ['White']] / df.loc[(df['County'] == 'Blount County'), ['TotalPop']] * 100", "Data transformation operation": ["filter", "calculate percentage"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me which county has the greatest number of female residents", "Relevant data columns": ["County", "Women"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['Women'].idxmax()]", "Data transformation operation": ["find max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "calculate the average black population for each state", "Relevant data columns": ["State", "Black"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "state_black_avg = df.groupby('State')['Black'].mean()", "Data transformation operation": ["groupby", "average"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you tell me if there is any correlation between the number of undergraduate and postgraduate students", "Relevant data columns": ["Undergraduate", "Postgraduate"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Undergraduate', 'Postgraduate']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "rank the grades from highest to lowest according to the average score", "Relevant data columns": ["Grade", "Student Average"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Sort", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Student Average', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the median score of the cw1 class", "Relevant data columns": ["CW 1"], "Data column classification": ["keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "cw1_median = df['CW 1'].median()", "Data transformation operation": ["calculate median"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do you know the median score of all students in cw1", "Relevant data columns": ["CW 1"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "cw1_median = df['CW 1'].median()", "Data transformation operation": ["calculate statistic"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how many students received an a", "Relevant data columns": ["Grade"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['Grade']=='A')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "arrange the students by grade and furnish me with a list", "Relevant data columns": ["Grade", "Student"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["sort", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "sorted_df = df.sort_values(by='Grade')", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "was the same midterm exam given to velma paul and glynis caine", "Relevant data columns": ["First Name", "Last Name", "Mid-term exams"], "Data column classification": ["data value mention", "data value mention", "keyword"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The question does not specify what exactly means 'the same' midterm exam.", "Ambiguity resolution": "Compare mid-term exam scores between Velma Paul and Glynis Caine", "Data transformations": "df.loc[(df['First Name']=='Velma') | (df['First Name']=='Glynis'))[['Mid-term exams']]", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Glynis Caine"}, {"query": "does simiyu have a similar structure of peope as that of katavi", "Relevant data columns": ["Regions"], "Data column classification": ["data value mention"], "Low-level visualization task": ["similarity"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether Simiyu and Katavi refer to regions in the given dataset.", "Ambiguity resolution": "", "Data transformations": "simiyu_data = df.loc[df['Regions'] == 'Simiyu']; katavi_data = df.loc[df['Regions'] == 'Katavi']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me how mara attributes are distributed", "Relevant data columns": ["Regions"], "Data column classification": ["data value mention"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the distribution refers to a particular attribute like marital status or total population.", "Ambiguity resolution": "", "Data transformations": "mara_data = df.loc[df['Regions']=='Mara']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is the total attribute of one area equal to the sum of the other attributes in any area", "Relevant data columns": ["Total", "Never Married", "Married", "Living Together", "Separated", "Divorced", "Widowed"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Never Married', 'Married', 'Living Together', 'Separated', 'Divorced', 'Widowed']].sum(axis=1).eq(df['Total'])", "Data transformation operation": ["sum", "equal"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there similarities between gdp per capita and suicide rates", "Relevant data columns": ["gdp_per_capita ($)", "suicides/100k pop"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate", "similarity"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['gdp_per_capita ($)', suicides/100k pop']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the country with the lowest suicide rate is", "Relevant data columns": ["country", "suicides/100k pop"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Find Minimum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result=df.loc[df['suicides/100k pop'].idxmin()]", "Data transformation operation": ["sort", "get index of min value"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "create a list showing the ages of people who committed suicide in albania", "Relevant data columns": ["age", "suicides_no", "country"], "Data column classification": ["keyword", "inferred", "data value mention"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "albania_suicide_data = df[(df['country']=='Albania')] ; albania_ages_list = albania_suicide_data['age'].tolist()", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "for the gdp of china, has it gone up or down over the last decade", "Relevant data columns": ["country", "year", "gdp_for_year ($)"], "Data column classification": ["data value mention", "inferred", "keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The phrase 'last decade' could refer to any period of ten consecutive years within the available data range.", "Ambiguity resolution": "Identify the most recent year in the dataset and consider the previous nine years as the last decade.", "Data transformations": "china_gdp_data = df[(df['country']=='China')] ; last_decade_gdp = china_gdp_data[china_gdp_data['year']>=(china_gdp_data['year'].max()-10)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do the pass rate and the ownership of schools have any correlation", "Relevant data columns": ["PASS_RATE", "OWNERSHIP"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['PASS_RATE', 'OWNERSHIP']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "list the values of kwema modern pr  school 's change_p in all the years", "Relevant data columns": ["NAME", "CHANGE_PREVIOUS_YEAR", "YEAR_OF_RESULT"], "Data column classification": ["data value mention", "keyword", "keyword"], "Low-level visualization task": ["Retreive Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "kwema_modern_pr_school_data = df[(df['NAME']=='KWEMA MODERN PR. SCHOOL')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which of these school have a pass rate of over 90", "Relevant data columns": ["PASS_RATE"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["Inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['PASS_RATE']>90]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "compare the number of tall buildings in hong kong with taiwan", "Relevant data columns": ["name", "Building/City", "Country/Region"], "Data column classification": ["inferred", "inferred", "keyword"], "Low-level visualization task": ["Compare"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we're considering only top-ranked buildings or any building in general.", "Ambiguity resolution": "Filter by Country/Region and count the number of rows for each region", "Data transformations": "hong_kong_buildings = df[df['Country/Region']=='Hong Kong']; taiwan_buildings = df[df['Country/Region']=='Taiwan']; num_hk_buildings = len(hong_kong_buildings); num_tw_buildings = len(taiwan_buildings)", "Data transformation operation": ["filter", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what location has the highest number of tall buildings", "Relevant data columns": ["Building/City", "Country/Region"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "city_counts = df.groupby('Building/City')['Rank'].count().reset_index(name='Count')", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the oldest user was born in what year", "Relevant data columns": ["birthyear"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Minimum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "oldest_birth_year = df['birthyear'].min()", "Data transformation operation": ["min"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the distribution of travel times between wells st & elm st and lake shore dr & ohio st", "Relevant data columns": ["tripduration", "from_station_name", "to_station_name"], "Data column classification": ["keyword", "data value mention", "data value mention"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "wells_to_lake_shore_trips = df[(df['from_station_name']=='Wells St & Elm St') | (df['from_station_name']=='Lake Shore Dr & Ohio St')] | ((df['to_station_name']=='Wells St & Elm St') | (df['to_station_name']=='Lake Shore Dr & Ohio St'))]; filtered_trip_durations = wells_to_lake_shore_trips['tripduration']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the relationship between age and travel time", "Relevant data columns": ["birthyear", "tripduration"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['birthyear','tripduration']].dropna()", "Data transformation operation": ["select", "dropna"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "if you were to average it out, how upbeat would you say the songs are", "Relevant data columns": ["Energy", "Danceability"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "avg_energy = df['Energy'].mean(); avg_danceability = df['Danceability'].mean()", "Data transformation operation": ["calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "describe the popularity of the loudest song", "Relevant data columns": ["Loudness..dB..", "Popularity"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution", "Retrieval"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "loudest_song_index = df.idxmax()['Loudness..dB..']; loudest_song_popularity = df.loc[loudest_song_index, 'Popularity']", "Data transformation operation": ["idxmax", "loc"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in terms of length, how long is \" beautiful people \"", "Relevant data columns": ["Length.", "Track.Name"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['Track.Name']=='Beautiful People (feat. Khalid)'),'Length.'] ", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are there singers who span multiple genres", "Relevant data columns": ["Artist.Name", "Genre"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["cluster", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The question asks about singers but doesn't specify whether they need to appear in multiple rows with different genres.", "Ambiguity resolution": "Group by artist and check for artists with more than one unique genre", "Data transformations": "artist_genres = df.groupby('Artist.Name')['Genre'].nunique().reset_index()", "Data transformation operation": ["groupby", "count_unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "please indicate the friendly tournament matches in which the home team beat the away team", "Relevant data columns": ["home_team", "away_team", "home_score", "away_score", "tournament"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["filter", "compute derived value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_matches = df[(df['tournament']=='Friendly') & (df['home_score']>df['away_score'])][['date','home_team', 'away_team', 'home_score', 'away_score']]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "based on the number of matches, can you tell me what the distribution of cities is", "Relevant data columns": ["city"], "Data column classification": ["keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "cities_count = df['city'].value_counts()", "Data transformation operation": ["count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how likely is it that, if i was born in 2000, i was born in a county with no less than 20,000 people", "Relevant data columns": ["County", "April 1, 2000 Population"], "Data column classification": ["inferred", "data value mention"], "Low-level visualization task": ["Filter", "Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df['April 1, 2000\\nPopulation'] >= 20000)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me a university that has more than 30 faculties and more than 50 teachers", "Relevant data columns": ["Name", "Num"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether 'faculties' refers to the 'Type' column or if it means something else.", "Ambiguity resolution": "Assume 'faculties' refers to the 'Num' column.", "Data transformations": "filtered_df = df[(df['Num']>30)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the universities cover which locations", "Relevant data columns": ["Location"], "Data column classification": ["keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Name','Location']].drop_duplicates()", "Data transformation operation": ["select", "distinct"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is the speed of economic development relative to the population of each country", "Relevant data columns": ["Median Income 2007", "Population 2007"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider other factors affecting economic development besides median income.", "Ambiguity resolution": "", "Data transformations": "df[['Median Income 2007', 'Population 2007']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the gdp ranking of european countries", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["Sort", "Compare", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The dataset does not contain European countries' GDP information.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "European Countries' GDP Information"}, {"query": "do all the countries in africa have a lower average pci than all the countries in europe", "Relevant data columns": ["Median Income 2007", "State"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["Compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The question does not specify whether PCI refers to Median Income or another metric.", "Ambiguity resolution": "", "Data transformations": "african_states = df.loc[df['State'].str.contains('Africa')]; european_states = df.loc[df['State'].str.contains('Europe')]; african_pci_avg = african_states['Median Income 2007'].mean(); european_pci_avg = european_states['Median Income 2007'].mean()", "Data transformation operation": ["filter", "groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what are the minimum and maximum populations of the chinese provinces", "Relevant data columns": ["Population"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term Chinese Provinces does not match any column headers. It seems like they meant US states instead.", "Ambiguity resolution": "Assume they mean US States instead of Chinese Provinces.", "Data transformations": "min_population = df['Population 2007'].min(); max_population = df['Population 2007'].max()", "Data transformation operation": ["min", "max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do countries with high populations wish to slow down population growth", "Relevant data columns": ["Place", "State", "July 1, 2002 Population"], "Data column classification": ["inferred", "inferred", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'countries' seems out of place since the given dataset appears to contain US cities rather than countries.", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='July 1, 2002 Population', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the state which may have the largest average population in the next year", "Relevant data columns": ["State", "July 1, 2002 Population"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["compute derived value", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "next_year_population = df.groupby('State')['July 1, 2002 Population'].apply(lambda x: x + ((x - df['July 1, 2001 Population']).mean()))", "Data transformation operation": ["groupby", "calculate difference", "average"], "New Column Name": "Next Year Average Population", "Derivation Specification": "(current population - previous population).mean()", "Missing Data Column": ""}, {"query": "are the students who are younger more likely to use wechat", "Relevant data columns": ["age", "social App"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "wechat_users_age = df.loc[df['social App'] == 'wechat']['age']; non_wechat_users_age = df.loc[df['social App']!= 'wechat']['age']", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which movie is the highest -grossing", "Relevant data columns": ["Movie", "Revenue ($)"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['Revenue ($)].idxmax()]", "Data transformation operation": ["sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how much revenue did \" titanic \" earn", "Relevant data columns": ["Movie", "Revenue ($)"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "revenue_titanic = df.loc[df['Movie']=='Titanic', 'Revenue ($)']", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Relationship between IMDB Rating and Rotten Tomatoes Rating", "Relevant data columns": ["IMDB Rating", "Rotten Tomatoes Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['IMDB Rating', 'Rotten Tomatoes Rating']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Movie gross and budge relationship based on genre", "Relevant data columns": ["Major Genre", "Worldwide Gross", "Production Budget"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlate", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to aggregate/transform the data by genre or perform any filtering.", "Ambiguity resolution": "Group the data by major genres and compute aggregates for worldwide gross and production budget.", "Data transformations": "genre_gross_budget = df.groupby('Major Genre')[['Worldwide Gross', 'Production Budget']].describe()", "Data transformation operation": ["groupby", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me imdb rating versus rotten tomatoes rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].plot.scatter(x='Rotten Tomatoes Rating', y='IMDB Rating')", "Data transformation operation": ["scatter plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What creative type of movie had the highest production budget for each content rating", "Relevant data columns": ["Creative Type", "Content Rating", "Production Budget"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only unique combinations of creative types and content ratings.", "Ambiguity resolution": "Group by both creative type and content rating, then aggregate production budgets.", "Data transformations": "creative_type_content_rating_budget_max = df.loc[df.groupby(['Content Rating','Creative Type'])['Production Budget'].idxmax()]", "Data transformation operation": ["groupby", "aggregate", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between production budget and worldwide gross for each major genre", "Relevant data columns": ["Production Budget", "Worldwide Gross", "Major Genre"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate data by major genres or analyze individual films.", "Ambiguity resolution": "Group data by major genres and plot relationships between production budgets and worldwide gross for each genre.", "Data transformations": "genre_gross_budget_corr = df.groupby('Major Genre')[['Production Budget', 'Worldwide Gross']].corr()", "Data transformation operation": ["groupby", "correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What major genre had the highest average worldwide gross", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_avg = df.groupby('Major Genre')['Worldwide Gross'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much did average worldwide gross vary by major genre", "Relevant data columns": ["Worldwide Gross", "Major Genre"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider only certain genres or all available genres.", "Ambiguity resolution": "Consider all unique Major Genres in the dataset", "Data transformations": "genre_gross_avg = df.groupby('Major Genre')['Worldwide Gross'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which creative type had the most movies", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.value_counts('Creative Type')", "Data transformation operation": ["value_counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which creative type had the fewest movies", "Relevant data columns": ["Creative Type"], "Data column classification": ["keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "creative_type_counts = df['Creative Type'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the distribution of running times for each movie", "Relevant data columns": ["Running Time"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Running Time']].describe()", "Data transformation operation": ["summary statistic calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Movie run time distribution", "Relevant data columns": ["Running Time"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the desired visualization is a general overview of running times or a more detailed exploration.", "Ambiguity resolution": "Assume a general overview is desired.", "Data transformations": "df[['Running Time']].describe()", "Data transformation operation": ["summary statistic calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What's the average production budget of the different rated movies, separated by creative type", "Relevant data columns": ["Production Budget", "Content Rating", "Creative Type"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only certain ratings (R/PG-13/PG), but the phrase 'different rated' suggests considering multiple rating categories separately.", "Ambiguity resolution": "Separate data into groups according to their Content Ratings and then perform aggregation on Production Budget within these groups.", "Data transformations": "df.groupby(['Content Rating', 'Creative Type'])['Production Budget'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how does Rotten Tomatoes Rating change as IMDB Rating", "Relevant data columns": ["Rotten Tomatoes Rating", "IMDB Rating"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the total worldwide gross earned by each major genre and content rating", "Relevant data columns": ["Worldwide Gross", "Major Genre", "Content Rating"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize", "compute derived value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross = df.groupby(['Major Genre', 'Content Rating'])['Worldwide Gross'].sum().reset_index()", "Data transformation operation": ["groupby", "sum", "reset_index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "For each genre and rating, what is the total world-wide gross earnings", "Relevant data columns": ["Major Genre", "Content Rating", "Worldwide Gross"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross = df.groupby(['Major Genre', 'Content Rating'])['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much money did movies of each genre and rating make", "Relevant data columns": ["Major Genre", "Content Rating", "Worldwide Gross"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the question wants separate aggregations by genre and rating, or combined.", "Ambiguity resolution": "Perform aggregation separately by genre and rating, then combine results.", "Data transformations": "genre_gross = df.groupby('Major Genre')['Worldwide Gross'].sum(); rating_gross = df.groupby('Content Rating')['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What was the average budget for each content rating and creative type, as multiple column charts", "Relevant data columns": ["Content Rating", "Creative Type", "Production Budget"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Characterize Distribution", "Compare"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need separate bar charts for each combination of content rating and creative type", "Ambiguity resolution": "Create separate bar charts for each unique pair of content rating and creative type, showing their corresponding mean production budgets", "Data transformations": "budget_by_rating_type = df.groupby(['Content Rating', 'Creative Type'])['Production Budget'].mean().reset_index()", "Data transformation operation": ["groupby", "mean", "reset_index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average production budget in each year", "Relevant data columns": ["Production Budget", "Release Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_grouped = df.groupby('Release Year')['Production Budget'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "On average, how much was earned by movies of each genre", "Relevant data columns": ["Major Genre", "Worldwide Gross"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "genre_gross_avg = df.groupby('Major Genre')['Worldwide Gross'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What was the average worldwide gross of movies by genre", "Relevant data columns": ["Worldwide Gross", "Major Genre"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only unique genres or multiple sub-genres under one major genre.", "Ambiguity resolution": "Group by distinct major genres", "Data transformations": "genre_gross_avg = df.groupby('Major Genre')['Worldwide Gross'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "gross across genres regarding content rating", "Relevant data columns": ["Worldwide Gross", "Content Rating", "Major Genre"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution", "Compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate the worldwide gross by genre first or directly correlate the two variables.", "Ambiguity resolution": "Aggregate the worldwide gross by genre and then analyze its relation with content rating.", "Data transformations": "genre_gross = df.groupby('Major Genre')['Worldwide Gross'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what's the distribution of running times by movie", "Relevant data columns": ["Running Time", "Title"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Title', 'Running Time']].groupby('Title')['Running Time'].describe()", "Data transformation operation": ["groupby", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "worldwide gross for each genre for each year 1995 to now", "Relevant data columns": ["Release Year", "Major Genre", "Worldwide Gross"], "Data column classification": ["inferenced", "keyword", "keyword"], "Low-level visualization task": ["summarize", "characterize distribution", "compute derived value", "compare"], "Low-level visualization task classification": ["inferred", "inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The phrase 'to now' implies including current and future years, but the dataset only contains past data.", "Ambiguity resolution": "Limit the analysis up to the latest available release year in the dataset", "Data transformations": "df[(df['Release Year'] >= 1995)].groupby(['Release Year', 'Major Genre'])['Worldwide Gross'].sum().reset_index()", "Data transformation operation": ["filter", "groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Relation between worldwide gross and production budget for each major genre", "Relevant data columns": ["Worldwide Gross", "Production Budget", "Major Genre"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to perform any aggregation or grouping on the data before visualizing the relation.", "Ambiguity resolution": "Group by Major Genre and visualize the relation between mean/median Worldwide Gross and mean/median Production Budget.", "Data transformations": "genre_gross_budget_relation = df.groupby('Major Genre')[['Worldwide Gross', 'Production Budget']].describe()", "Data transformation operation": ["groupby", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which cylinder cars have the highest fuel economy", "Relevant data columns": ["cylinders", "mpg"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Filter", "Find Extremum"], "Low-level visualization task classification": ["synonym", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we want overall highest fuel economy or grouped by number of cylinders.", "Ambiguity resolution": "Group by number of cylinders first then find highest fuel economy within each group.", "Data transformations": "df_grouped = df.groupby('cylinders')['mpg'].idxmax()", "Data transformation operation": ["groupby", "argmax"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which countries have the most cars in this dataset", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term most cars' implies count but it's unclear whether we need to perform any grouping by other variables like year.", "Ambiguity resolution": "Grouping by country will give us the desired result", "Data transformations": "df_country_count = df.groupby('country')['mpg'].count().reset_index(name='Count')", "Data transformation operation": ["groupby", "count"], "New Column Name": "Count", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Which countries have the highest acceleration for cars of different cylinders", "Relevant data columns": ["country", "cylinders", "timeto60"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compute derived value", "filter", "sort", "compare"], "Low-level visualization task classification": ["inferred", "inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only the fastest car from each country-cylinder combination or average/aggregate them somehow.", "Ambiguity resolution": "Rank the combinations by their best time-to-60 performance", "Data transformations": "df_ranked = df.sort_values(by='timeto60').reset_index(drop=True); grouped_data = df_ranked.groupby(['country','cylinders']).head(1)", "Data transformation operation": ["sort", "groupby", "head"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How do the horsepowers of the cars from different regions change with years", "Relevant data columns": ["hp", "year", "country"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The exact nature of the change over time is unspecified.", "Ambiguity resolution": "Plot horsepower against year separately by region.", "Data transformations": "df.pivot_table(index='year', columns='country', values='hp')", "Data transformation operation": ["pivot_table"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "The distribution of the number of cylinders of cars based on different origins", "Relevant data columns": ["cylinders", "country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the distribution refers to individual cylinder counts or grouped distributions by origin", "Ambiguity resolution": "Group cylinder count by origin", "Data transformations": "df.groupby(['country', 'cylinders']).size().reset_index(name='Count')", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "count the number of cars based on their origins", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize", " retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data_transformations": "df_country_counts = df.value_counts('country')", "Data_transformation_operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the correlation between horsepower and acceleration", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp', 'timeto60']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how does displacement relate to mpg for individual models, partitioned by country", "Relevant data columns": ["cubicinches", "mpg", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate data within each country before analyzing the relation between displacement and mpg.", "Ambiguity resolution": "Plot separate scatter plots for each country, showing the relationship between displacement and mpg.", "Data transformations": "df_grouped_country = df.groupby('country')[['cubicinches', mpg']].plot(kind='scatter', x='cubicinches', y='mpg')", "Data transformation operation": ["groupby", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how does weight relate to acceleration for car models, small multiples by origin", "Relevant data columns": ["weightlbs", "timeto60", "country"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlate", "dependency"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import matplotlib.pyplot as plt\"                    + \"fig, ax = plt.subplots(3)\"                    + \"for i, c in enumerate(df.country.unique()):\"                    + \"    temp_df = df.loc[df.country==c]\"                    + \"    ax[i].scatter(temp_df.weightlbs, temp_df.timeto60)\"                    + \"    ax[i].title.set_text(c)", "Data transformation operation": ["groupby", "scatter plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how does horsepower relate to acceleration for individual car models", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider other factors such as weight and cylinder count when analyzing the relation between horsepower and acceleration.", "Ambiguity resolution": "Control for potential confounding variables like weight and cylinder count while examining the relation between horsepower and acceleration.", "Data transformations": "df[['hp', 'timeto60']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Compare the number of models in USA, Japan and Europe", "Relevant data columns": ["country"], "Data column classification": ["keyword"], "Low-level visualization task": ["compare"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "model_counts = df['country'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Does higher horsepower mean lower acceleration", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp', 'timeto60']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Compare car cylinder count against acceleration across countries", "Relevant data columns": ["cylinders", "timeto60", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["correlate", "compare"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider only certain types of cars or models while comparing the cylinder count and acceleration.", "Ambiguity resolution": "Consider all available car models from different countries", "Data transformations": "df[['cylinders', 'timeto60', 'country']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Does higher cylinder count mean mean lower mileage", "Relevant data columns": ["cylinders", "mpg"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether other factors like horsepower, weight, and country also influence the relation between cylinders and mileage.", "Ambiguity resolution": "Control for these variables when analyzing the relation between cylinders and mileage", "Data transformations": "df[['cylinders', mpg']].corr()", "Data transformation operation": ["calculate correlation coefficient"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does mileage relate to cylinder count", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['mpg','cylinders']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average MPG for different cylinders", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('cylinders')['mpg'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relation between horsepower and acceleration", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp', 'timeto60']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how weight varies each year", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['year', 'weightlbs']].groupby('year')['weightlbs'].plot()", "Data transformation operation": ["groupby"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How has horsepower changed over time by country", "Relevant data columns": ["hp", "year", "country"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate horsepower data within each country across multiple years.", "Ambiguity resolution": "Perform aggregation within each country across multiple years.", "Data transformations": "df_grouped = df.groupby(['country', 'year'])['hp'].mean().reset_index()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Have cars gotten lighter over time", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider only certain types of cars or overall trends.", "Ambiguity resolution": "Consider overall trends without distinguishing between car types.", "Data transformations": "df.sort_values(by='year')[['year', 'weightlbs']].groupby('year')['weightlbs'].mean()", "Data transformation operation": ["sort", "groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average weight of cars over time", "Relevant data columns": ["weightlbs", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Trend", "Compute Derived Value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['year', 'weightlbs']].groupby('year')['weightlbs'].mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the distribution of weight across all cars", "Relevant data columns": ["weightlbs"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['weightlbs']].describe()", "Data transformation operation": ["summary stats"], "New Column Name": "", "Derivation Specification": "", "Miscellaneous Data Column": ""}, {"query": "Compare AVG (Acceleration) with Cylinders | Segregate the cylinders by their origin", "Relevant data columns": ["timeto60", "cylinders", "country"], "Data column classification": ["synonym", "keyword", "keyword"], "Low-level visualization task": ["Correlate", "Summarize", "Filter"], "Low-level visualization task classification": ["Keyword", "Inferred", "Inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether 'origin' refers to the country where the car is from or something else", "Ambiguity resolution": "Assume 'origin' means the country where the car is from", "Data transformations": "df[['cylinders', 'timeto60', 'country']].groupby(['cylinders', 'country']).agg({'timeto60': ['mean']}", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does the acceleration of cars from different countries vary by the number of cylinders", "Relevant data columns": ["timeto60", "cylinders", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["correlate", "dependency"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider other factors affecting car acceleration besides cylinder count.", "Ambiguity resolution": "Consider only direct relationship between cylinder count and acceleration.", "Data transformations": "df[['cylinders', 'timeto60', 'country']].groupby(['country', 'cylinders']).mean()", "Data transformation operation": ["groupby", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does acceleration vary by weight for cars from different regions", "Relevant data columns": ["timeto60", "weightlbs", "country"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider other factors like engine power, number of cylinders while analyzing acceleration vs weight.", "Ambiguity resolution": "Initially focus only on acceleration and weight, then later add more variables for further exploration", "Data transformations": "df[['country', 'timeto60', 'weightlbs']].groupby('country')['timeto60', 'weightlbs'].corr()", "Data transformation operation": ["groupby", "correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average MPG for cars with different cylinders", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('cylinders')['mpg'].mean()", "Data transformation operation": ["groupby", "average"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does MPG vary by the number of cylinders in a car", "Relevant data columns": ["mpg", "cylinders"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['mpg','cylinders']].groupby('cylinders')['mpg'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does acceleration change with horsepower", "Relevant data columns": ["hp", "timeto60"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['hp', 'timeto60']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does acceleration behave compared to horsepower", "Relevant data columns": ["timeto60", "hp"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether any filtering or aggregation is needed.", "Ambiguity resolution": "No need for filtering or aggregation, just plot the two variables against each other.", "Data transformations": "df[['timeto60', 'hp']] ", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how does MPG compare to displacement, broken out by region", "Relevant data columns": ["mpg", "cubicinches", "country"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlate", "compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the user wants to see overall trends between MPG and displacement or focus on differences within regions.", "Ambiguity resolution": "Generate separate visualizations for each region to show relationships between MPG and displacement.", "Data transformations": "df[['mpg', 'cubicinches', 'country']].groupby('country').plot(kind='scatter', x='cubicinches', y='mpg')", "Data transformation operation": ["groupby", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "For each region, how does a car's MPG vary with displacement", "Relevant data columns": ["mpg", "cubicinches", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["correlate", "dependency"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether 'displacement' refers specifically to 'cubic inches'", "Ambiguity resolution": "'Displacement' likely means 'cubic inches'. Group by country.", "Data transformations": "df_grouped = df.groupby('country')[['mpg', 'cubicinches']].corr()", "Data transformation operation": ["groupby", "correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How has horsepower changed over time in each region", "Relevant data columns": ["hp", "year", "country"], "Data column classification": ["keyword", "inferred", "data value mention"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to aggregate horsepower by average/total within regions or show individual datapoints.", "Ambiguity resolution": "Aggregate horsepower by average within regions", "Data transformations": "df_grouped = df.groupby(['country', 'year'])['hp'].mean().reset_index()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the breakdown of cars by the number of cylinders in each region", "Relevant data columns": ["cylinders", "country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution", "cluster"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the breakdown refers to count, proportion or other metrics.", "Ambiguity resolution": "Assume the breakdown refers to the distribution of counts of cars by cylinder type in each region", "Data transformations": "df_country_cylinder_breakdown = df.groupby(['country', 'cylinders']).size().reset_index(name='Count')", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many cars have various numbers of cylinders in each region", "Relevant data columns": ["cylinders", "country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize", "dependency"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'various' implies counting but does not specify whether we need to count unique cylinder counts or total occurrences.", "Ambiguity resolution": "Count total occurrences of each number of cylinders by country", "Data transformations": "df_country_cylinder_counts = df.groupby(['country', 'cylinders']).size().reset_index(name='counts')", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much is the average of profit of each state", "Relevant data columns": ["Profit", "State"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the states refer to distinct geographic regions within the same country.", "Ambiguity resolution": "Assume the states refer to distinct geographic regions within the same country.", "Data transformations": "df.groupby('State')['Profit'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How much was sold each day for each category", "Relevant data columns": ["Order Date", "Sales", "Category"], "Data column classification": ["inferred", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only certain days or categories.", "Ambiguity resolution": "Consider all available dates and categories.", "Data transformations": "df.groupby([pd.Grouper(key='Order Date', freq='D'), 'Category'])['Sales'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average profit for each state", "Relevant data columns": ["State", "Profit"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('State')['Profit'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between profit and sales", "Relevant data columns": ["Profit", "Sales"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Profit', 'Sales']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the sales forecast for each date", "Relevant data columns": ["Order Date", "Sales Forecast"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to aggregate the sales forecast by date or just retrieve individual forecasts.", "Ambiguity resolution": "Group the data by order date and summarize the sales forecast for each date.", "Data transformations": "df.groupby('Order Date')['Sales Forecast'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the relationship between sales and profit for each region", "Relevant data columns": ["Region", "Sales", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Region')[['Sales', 'Profit']].plot(kind='scatter')", "Data transformation operation": ["groupby"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the total profit for each region, based on ship status", "Relevant data columns": ["Region", "Ship Status", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby(['Region', 'Ship Status'])['Profit'].sum()", "Data transformation operation": ["groupby", "summarize"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many products have 3 or more quantity ordered", "Relevant data columns": ["Product Name", "Quantity"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['Quantity'] >= 3]; result = filtered_df.shape[0]", "Data transformation operation": ["filter", "shape"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Density of sales across regions and their profitability", "Relevant data columns": ["Region", "Sales", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["characterize distribution", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether density refers to geographical distribution or concentration of sales", "Ambiguity resolution": "Assume density means concentration of sales, so aggregation by region will provide insights into regional performance", "Data transformations": "df_region_sales = df.groupby('Region')['Sales'].sum(); df_region_profit = df.groupby('Region')['Profit'].mean()", "Data transformation operation": ["groupby", "sum", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "sales forecast between Jan 2016 and July 2017", "Relevant data columns": ["Order Date", "Sales Forecast"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["summarize", "characterize distribution", "trend"], "Low-level visualization task classification": ["inferred", "inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The exact date range boundaries are ambiguous.", "Ambiguity resolution": "Filter by dates from January 1st, 2016 to July 31st, 2017.", "Data transformations": "filtered_df = df[(df['Order Date'] >= '2016-01-01') & (df['Order Date'] <= '2017-07-31')]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "I want to know how many orders there are by the quantity of the order", "Relevant data columns": ["Quantity", "Order ID"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["summarize", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "order_counts_by_quantity = df.value_counts('Quantity')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is our profit based on shipping mode by customer segment", "Relevant data columns": ["Profit", "Ship Mode", "Segment"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize", "correlate"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to aggregate profit at order level or consider total profit.", "Ambiguity resolution": "Aggregate profit by ship mode and customer segment", "Data transformations": "df_grouped = df.groupby(['Ship Mode', 'Segment'])['Profit'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the sales vs profit ratio of the four regions", "Relevant data columns": ["Region", "Sales", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["compute derived value", "correlate"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider total sales and profits for each region or average sales and profits.", "Ambiguity resolution": "Consider total sales and profits for each region.", "Data transformations": "region_sales_profit = df.groupby('Region')[['Sales', 'Profit']].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "sales_to_profit_ratio", "Derivation Specification": "region_sales_profit['sales_to_profit_ratio'] = region_sales_profit['Sales'] / region_sales_profit['Profit']", "Missing Data Column": ""}, {"query": "What is the average profit of each state", "Relevant data columns": ["State", "Profit"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the average profit refers to overall states' profits or state-wise average profit by category/product.", "Ambiguity resolution": "Assuming state-wise average profit calculation", "Data transformations": "state_wise_profit_avg = df.groupby('State')['Profit'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the sales vs profit ratio of all the zones", "Relevant data columns": ["Region", "Sales", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The concept of 'ratio' could imply multiple calculations.", "Ambiguity resolution": " Calculate average sales and profit for each region then divide them ", "Data transformations": "zone_profit_sales_ratio = df.groupby('Region')[['Sales', 'Profit']].mean().apply(lambda x: x['Sales']/x['Profit'])", "Data transformation operation": ["groupby", "calculate mean", "divide"], "New Column Name": "profit_to_sales_ratio", "Derivation Specification": "sales/profit", "Missing Data Column": ""}, {"query": "What is the average profit of different segments on the ship modes of transport", "Relevant data columns": ["Profit", "Segment", "Ship Mode"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the question wants averages by segment only or by both segment and ship mode.", "Ambiguity resolution": "Average profit will be computed separately for each combination of segment and ship mode.", "Data transformations": "df.groupby(['Segment', 'Ship Mode'])['Profit'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how much is the profit for sales for each", "Relevant data columns": ["Profit", "Sales"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate by any specific category (e.g., region, product, customer)", "Ambiguity resolution": "Perform aggregation by various categories to explore the data", "Data transformations": "df.groupby(['Region', 'Product Name', 'Customer Name'])[['Profit', 'Sales']].sum()", "Data transformation operation": ["groupby", "summarize"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Can you create a graph showing sales and profit by region", "Relevant data columns": ["Region", "Sales", "Profit"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["summarize", "compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_groupedBy_region = df.groupby('Region')[['Sales', 'Profit']].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the most frequent status over the year", "Relevant data columns": ["status", "year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_status_count = df.value_counts('status')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What storm produced the greatest air pressure", "Relevant data columns": ["name", "pressure"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Find Minimum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result_df = df.loc[df['pressure'].idxmin()]", "Data transformation operation": ["find min"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many storms are named Caroline", "Relevant data columns": ["name"], "Data column classification": ["keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "storm_count = df.loc[df['name']=='Caroline'].shape[0]", "Data transformation operation": ["filter", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What storm produced the least air pressure", "Relevant data columns": ["name", "pressure"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Find Minimum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df.loc[df['pressure'].idxmin()]['name']; result_pressure = df.loc[df['pressure'].idxmin()]['pressure']", "Data transformation operation": ["sort", "get index", "access row"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What storm had the greatest diameter of hurricane strength winds", "Relevant data columns": ["name", "ts_diameter", "hu_diameter"], "Data column classification": ["inferred", "keyword", "keyword"], "Low-level visualization task": ["Find Maximum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we're looking at tropical storms or hurricanes specifically.", "Ambiguity resolution": "Filter out non-hurricane categories", "Data transformations": "hurricanes_only = df[(df['category']>0)&(df['status']!='tropical depression')] ; result = hurricanes_only.loc[hurricanes_only['hu_diameter'].idxmax()]", "Data transformation operation": ["filter", "sort", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How many storms occur per year, on average", "Relevant data columns": ["year", "name"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider multiple records of same storm in a single year.", "Ambiguity resolution": "Count unique names within each year", "Data transformations": "storm_counts_per_year = df.groupby('year')['name'].nunique()", "Data transformation operation": ["groupby", "nunique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "On average, what is the first date that a tropical cyclone (tropical depression, tropical storm, or hurricane) forms on every year", "Relevant data columns": ["year", "month", "day", "status"], "Data column classification": ["keyword", "keyword", "keyword", "synonym"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'first date' could refer to either the earliest recorded date for any tropical cyclone type or the average of these dates.", "Ambiguity resolution": "Interpret 'first date' as the average of the earliest dates for each tropical cyclone type", "Data transformations": "df_min_date_per_year = df.loc[df.groupby('year')['day'].idxmin()][['year', month', 'day']].reset_index(drop=True); avg_first_date_per_year = df_min_date_per_year.mean(axis=0)", "Data transformation operation": ["groupby", "idxmin", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Where have all hurricanes been recorded on the globe Where are they more common", "Relevant data columns": ["lat", "long", "status", "category"], "Data column classification": ["keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution", "Find Anomalies", "Dependency"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider only hurricane records with certain categories (e.g., tropical storms) or all types of storms.", "Ambiguity resolution": "Filter out non-hurricane records by selecting rows where category equals 'hurricane' or status equals 'hurricane'. Use these filtered records to create spatial distribution visualizations.", "Data transformations": "filtered_df = df[(df['status']=='hurricane') | (df['category']=='hurricane)]; grouped_lat_long = filtered_df.groupby(['lat', 'long']).size().reset_index(name='counts')", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What are lengths/timings of hurricane seasons in different regions of the world", "Relevant data columns": ["year", "month"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to consider other factors like location or categorization of storms.", "Ambiguity resolution": "Focus only on months when hurricanes occur most frequently", "Data transformations": "df_monthly_counts = df.resample('M')['name'].count()", "Data transformation operation": ["resample", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the average time that it takes to go from depression to storm", "Relevant data columns": ["status", "category", "year", "month", "day", "hour"], "Data column classification": ["keyword", "keyword", "inferenced", "inferenced", "inferenced", "inferenced"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "depression_to_storm_time = ((df.loc[(df['category']=='storm'), ['year','month','day','hour']].reset_index(drop=True) - df.loc[(df['category']!='storm') & (df['status']==\"tropical depression\"), ['year','month','day','hour']].reset_index(drop=True)).abs().mean()", "Data transformation operation": ["filter", "subtract", "absolute", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "How does wind change over the course of each hurricane", "Relevant data columns": ["name", "wind", "year", "month", "day", "hour"], "Data column classification": ["keyword", "keyword", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to aggregate the wind speeds by day/month/year or analyze them individually.", "Ambiguity resolution": "Group the data by hurricane (name), then plot the wind speed over time (hour/day).", "Data transformations": "df.sort_values(by='hour').groupby('name')['wind'].plot()", "Data transformation operation": ["sort", "groupby", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What is the maximum pressure of a certain hurricane", "Relevant data columns": ["name", "pressure"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["Find Maximum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the question refers to any hurricane or a specific one.", "Ambiguity resolution": "Assume the question asks about a general hurricane unless specified otherwise.", "Data transformations": "result_df = df.loc[df.groupby('name')['pressure'].idxmax()]", "Data transformation operation": ["groupby", "idxmax"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Relationship between position and the strength of the hurricane", "Relevant data columns": ["lat", "long", "wind", "pressure", "category"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Correlate", "Dependency"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider other factors like time, direction, speed, etc.", "Ambiguity resolution": "Focus on spatial relationships ignoring temporal aspects", "Data transformations": "df[['lat', 'long', 'wind', 'pressure', 'category']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Average time for each hurricane status", "Relevant data columns": ["status", "hour"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["summarize", "compute derived value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider the entire duration of each hurricane status or just average hours spent at each status.", "Ambiguity resolution": "Calculate total hours spent at each status by summing up consecutive records for each status then divide by count of records", "Data transformations": "df_status_hour_avg = df.groupby('status')['hour'].value_counts().to_frame('count').reset_index().groupby('status')['count'].transform(lambda x : x.sum() / x.count()).reset_index(name='avg_hours')", "Data transformation operation": ["groupby", "value counts", "transform"], "New Column Name": "avg_hours", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any correlations between crime types and geographic location", "Relevant data columns": ["incident_characteristics", "state", "city_or_county", "latitude", "longitude"], "Data column classification": ["keyword", "keyword", "keyword", "inferred", "inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we need to aggregate crime types at the state level or consider individual cities/counties.", "Ambiguity resolution": "Aggregate crime types at both state and city levels.", "Data transformations": "df_state_level = df.groupby('state')['incident_characteristics'].value_counts().reset_index(); df_city_level = df.groupby(['state', 'city_or_county'])['incident_characteristics'].value_counts().reset_index()", "Data transformation operation": ["groupby", "value counts", "reset index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any correlations in violent or non-violent crimes based on congressional district and year", "Relevant data columns": ["incident_id", "date", "state", "city_or_county", "congressional_district", "year"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "keyword", "inferred"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the question refers to specific types of crime (violent/non-violent)", "Ambiguity resolution": "Assume general crime rates including both violent and non-violent crimes", "Data transformations": "df = df.groupby(['congressional_district', 'year']).size().reset_index(name='crime_rate')", "Data transformation operation": ["groupby", "count"], "New Column Name": "crime_rate", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is there a somewhat even distribution between the year and congressional district", "Relevant data columns": ["Years", "congressional_district"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation", "dependency", "distribution"], "Low-level visualization task classification": ["keyword", "keyword", "keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether we want to check for equality or just any kind of balance.", "Ambiguity resolution": "Check for rough proportionality.", "Data transformations": "year_counts = df.value_counts('Years'); cdistrict_counts = df.value_counts('congressional_district'); joint_dist = pd.crosstab(df['Years'], df['congressional_district'])", "Data transformation operation": ["value counts", "crosstab"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Are there any significant correlations between any 2 variables in the dataset", "Relevant data columns": ["all columns"], "Data column classification": ["keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "import pandas as pd; corr_matrix = df.corr()", "Data transformation operation": ["corr"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "What\u2019s the frequency of gun violence incidents with multiple victims", "Relevant data columns": ["incident_id", "date", "state", "city_or_county", "address", "n_killed", "n_injured", "congressional_district", "gun_stolen", "gun_type", "incident_characteristics", "latitude", "location_description", "longitude", "n_guns_involved", "state_house_district", "state_senate_district"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred", "keyword", "keyword", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['n_killed']>0)|(df['n_injured']>0)].groupby('year')['incident_id'].count()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "Is one sex more likely to perpetrate gun violence", "Relevant data columns": ["sex", "intent", "police", "incident_characteristics"], "Data column classification": ["keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we're looking at perpetrators or victims of gun violence.", "Ambiguity resolution": "Focus on incidents where individuals were involved in gun violence as perpetrators.", "Data transformations": "df = df[(df['intent']!='Undetermined') & ((df['police']==1) | (df['incident_characteristics'].str.contains('Perpetrator')))]", "Data transformation operation": ["filter", "boolean indexing"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"Query": "How have homicide rates increased over time?", "Relevant data columns": ["Homicide (People)", "Years"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.plot(x='Years', y='Homicide (People)')", "Data transformation operation": ["plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "", "query": "How have homicide rates increased over time"}, {"query": "What type of gun violence has seen the most growth over the years", "Relevant data columns": ["Years", "Homicide (People)", "Suicide (People)", "Unintentional (People)", "Legal intervention (People)", "Undetermined (People)"], "Data column classification": ["keyword", "inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_melt = pd.melt(df, id_vars='Years', var_name='Type', value_name='Count'); df_growth_rate = df_melt.groupby('Type')['Count'].pct_change().reset_index(name='Growth Rate')", "Data transformation operation": ["melt", "groupby", "calculate percentage change"], "New Column Name": "Growth Rate", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me a list of neighborhoods with the number of male births from least to most", "Relevant data columns": ["Neighborhood Name", "Number"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["sort", "retrieve value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Number', ascending=True)[['Neighborhood Name', 'Number']]", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the distribution of births across all districts in 2017", "Relevant data columns": ["District Name", "Number", "Year"], "Data column classification": ["inferred", "keyword", "data value mention"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_2017 = df[df['Year']==2017]; df_district_distribution = df_2017[['District Name', 'Number']].copy()", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "let me know if there are groups of neighborhoods with similar birth gender ratios", "Relevant data columns": ["Neighborhood Name", "Gender", "Number"], "Data column classification": ["inferred", "keyword", "inferred"], "Low-level visualization task": ["cluster", "similarity"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether only boys or both genders need to be considered while comparing neighborhood gender ratios", "Ambiguity resolution": "Consider both genders when calculating neighborhood gender ratios", "Data transformations": "df_grouped = df.groupby(['District Name', 'Neighborhood Name']).apply(lambda x: x['Number'][x['Gender']=='Boys']/x['Number'].sum()); clusters = df_grouped.reset_index().groupby('level_1')['Number'].apply(pd.Series.kmeans, n_clusters=3).fit()", "Data transformation operation": ["groupby", "apply", "reset_index", "k-means clustering"], "New Column Name": "gender_ratio_cluster", "Derivation Specification": "df_grouped['gender_ratio_cluster'] = clusters.labels_; df_merged = pd.merge(df, df_grouped[['Neighborhood Name', 'gender_ratio_cluster']], on='Neighborhood Name')", "Missing Data Column": ""}, {"query": "retrieve the neighborhood with more than 100 female births in ciutat vella in 2013", "Relevant data columns": ["District Name", "Neighborhood Name", "Gender", "Number", "Year"], "Data column classification": ["keyword", "keyword", "keyword", "data value mention", "data value mention"], "Low-level visualization task": ["filter", "compute derived value", "find extremum"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The query asks about 2013 but the given dataset only contains 2017.", "Ambiguity resolution": "Assuming the same pattern holds true for 2013 as well", "Data transformations": "df_female_ciutat_vella_2013 = df[(df['Year']==2013)&(df['District Name']=='Ciutat Vella')&(df['Gender']=='Female')] ; result_df = df_female_ciutat_vella_2013[df_female_ciutat_vella_2013['Number']>100][['Neighborhood Name','Number']]", "Data transformation operation": ["filter", "selection"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the distribution of all births in all districts between 2013 and 2017", "Relevant data columns": ["District Code", "District Name", "Neighborhood Code", "Neighborhood Name", "Gender", "Number", "Year"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred", "keyword", "inferred"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to aggregate birth numbers by district or neighborhood level.", "Ambiguity resolution": "Aggregate at both levels and compare distributions", "Data transformations": "birth_data_13_to_17 = df[(df['Year'] >= 2013) & (df['Year'] <= 2017)]; district_birth_distribution = birth_data_13_to_17.groupby('District Code')['Number'].value_counts().reset_index(name='Birth Count'); neighborhood_birth_distribution = birth_data_13_to_17.groupby(['District Code', 'Neighborhood Code'])['Number'].value_counts().reset_index(name='Birth Count')", "Data transformation operation": ["filter", "groupby", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what 's the size of \" kids paint free - drawing fun \"", "Relevant data columns": ["App", "Size"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['App']==\"Kids Paint Free - Drawing Fun\"), ['Size']].values[0]", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the total amount of genres", "Relevant data columns": ["Genres"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to count unique genres or just get the sum of genre occurrences.", "Ambiguity resolution": "Count unique genres.", "Data transformations": "genres_count = df['Genres'].nunique()", "Data transformation operation": ["nunique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what apps have a perfect rating and a lot of reviews", "Relevant data columns": ["Rating", "Reviews", "App"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["filter", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['Rating']==5.0) & (df['Reviews']>10000)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "see if you can locate the most recent gaming app", "Relevant data columns": ["Category", "Last Updated"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Filter", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether most recent' refers to the last updated date or something else.", "Ambiguity resolution": "Assume most recent' means the latest update date", "Data transformations": "gaming_apps = df[(df['Category']=='GAME')] ; sorted_gaming_apps = gaming_apps.sort_values(by='Last Updated', ascending=False)", "Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which apps have support for versions of android lower than 40", "Relevant data columns": ["Android Ver"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "android_lower_than_40 = df[df['Android Ver'].str.contains('and up|1\\.6|2\\.1')] ", "Data transformation operation": ["filter", "string contains"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "describe shape of the distribution for the number of installations", "Relevant data columns": ["Installs"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df['Installs']", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the most recent version of androids \" discover color \"", "Relevant data columns": ["Android Ver"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Extremum", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'Discover Color' does not seem relevant to any column in the given dataset.", "Ambiguity resolution": "Assume the request refers to the latest available Android Version instead of Discover Color", "Data transformations": "latest_android_version = max(df['Android Ver'])", "Data transformation operation": ["maximum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me a list of all the free business apps that have received rating that were higher than a 45", "Relevant data columns": ["Category", "Rating", "Price"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["filter", "compute derived value", "sort", "summarize"], "Low-level visualization task classification": ["inferred", "inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "free_business_apps_high_rated = df[(df['Category']=='BUSINESS') & (df['Price']=='Free') & (df['Rating']>4.5)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what 's the price distribution in beauty apps", "Relevant data columns": ["Price", "Category"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'beauty apps' is ambiguous as it doesn't match any category directly.", "Ambiguity resolution": "Assume 'Lifestyle' category includes Beauty Apps", "Data transformations": "beauty_apps_df = df[(df['Category']=='LIFESTYLE')] ; beauty_price_dist = beauty_apps_df['Price'].value_counts()", "Data transformation operation": ["filter", "select", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the number of hospitals located in manyara", "Relevant data columns": ["Region", "Hospital"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "Manyara region is missing from the given dataset.", "Ambiguity resolution": "Check if Manyara exists in another dataset or clarify the correct spelling/region", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Manyara region"}, {"query": "which 10 regions have the most health centers", "Relevant data columns": ["Region", "Health Centre"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='Health Centre', ascending=False).head(10)[['Region', 'Health Centre']]", "Data transformation operation": ["sort", "head"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the number of clinics that are in mara", "Relevant data columns": ["Region", "Clinic"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "Mara region is not present in the given dataset.", "Ambiguity resolution": "Since Mara region does not exist in the dataset, we need to either remove the query or clarify which region Mara refers to.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what 's the distribution of the entire hfs", "Relevant data columns": ["Total HFs"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Total HFs']].describe()", "Data transformation operation": ["summary statistics"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "remove any regions with a population ratio of hf lower than 15", "Relevant data columns": ["Population", "ration of population over HF", "Region"], "Data column classification": ["inferred", "keyword", "data value mention"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['ration of population over HF'] >= 1.5]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me the movie that received the most nominations", "Relevant data columns": ["nominee film", "category"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "counts_nominees = df.value_counts('nominee film')", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you organize the results of the table by sorting the list according to the age of the stars", "Relevant data columns": ["nominee"], "Data column classification": ["inferred"], "Low-level visualization task": ["Sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The query does not specify how to determine the age of the stars.", "Ambiguity resolution": "Assume that the age of the stars will need to be looked up externally since it's not present in the given dataset.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "age of the stars"}, {"query": "can you list all the results in the table about the movie \" about schmidt  \"", "Relevant data columns": ["nominee film"], "Data column classification": [["data value mention"]], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['nominee film']=='About Schmidt']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "i would like to review the dispersement of the amount of nominations", "Relevant data columns": ["category", "nominee film"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether you want to look at the distribution by category or overall.", "Ambiguity resolution": "Assuming we're looking at both the distribution overall and within categories.", "Data transformations": "df_nomination_counts = df.groupby('category')['nominee film'].count().reset_index(name='counts')", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which actor was nominated for the most awards", "Relevant data columns": ["nominee", "category", "year_award"], "Data column classification": ["inferred", "keyword", "inferred"], "Low-level visualization task": ["Compute Derived Value", "Find Extremum"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The term 'actor' is ambiguous because it's not explicitly stated in the dataset.", "Ambiguity resolution": "Assume 'nominee' refers to actors/directors/etc. being nominated for awards", "Data transformations": "award_counts = df.groupby('nominee')['category'].count().reset_index(name='counts')", "Data transformation operation": ["groupby", "count"], "New Column Name": "counts", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can the actors nationality impact the outcome", "Relevant data columns": ["nominee", "win"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'outcome' is ambiguous, could refer to either winning or losing an award.", "Ambiguity resolution": "Clarify whether 'outcome' refers to winning or losing an award.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "actor_nationality"}, {"query": "is there an outlier within the value distribution of albinism that causes the result to be skewed", "Relevant data columns": ["ALBINO"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Anomalies", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "albino_series = df['ALBINO']; albino_outliers = albino_series[(np.abs(stats.zscore(albino_series)) > 3)]", "Data transformation operation": ["calculate z-score", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the spatial and temporal correlation of albinism", "Relevant data columns": ["REGION", "ALBINO"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The question does not specify whether to look at correlations within regions over time or between regions.", "Ambiguity resolution": "Assume we want to explore both types of correlations.", "Data transformations": "df.set_index('REGION')['ALBINO']; region_correlations = df.corr(); temporal_correlations = df.pivot_table(index='YEAR', values='ALBINO', aggfunc='corr')", "Data transformation operation": ["pivot", "corr", "set index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "take out the regions with a number of patients larger than 500", "Relevant data columns": ["REGION", "ALBINO", "AUTISM"], "Data column classification": ["inferred", "inferred", "inferred"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's ambiguous whether the count refers to any particular impairment type or overall total.", "Ambiguity resolution": "Assume the count refers to the sum of all impairments.", "Data transformations": "filtered_regions = df[(df[['DEAF-MUTE','DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']].sum(axis=1)) <= 500] ", "Data transformation operation": ["sum", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "looking at the number of people in all regions with a visual impairment, what is the median", "Relevant data columns": ["REGION", "VISUALLY IMPAIRED"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_visually_impaired = df[['REGION', 'VISUALLY IMPAIRED']].copy(); df_visually_impaired['VISUALLY IMPAIRED'] = df_visually_impaired['VISUALLY IMPAIRED'].astype(float); median_visual_impairment = df_visually_impaired['VISUALLY IMPAIRED'].median()", "Data transformation operation": ["filter", "cast", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "does the value distribution of albinism look skewed", "Relevant data columns": ["ALBINO"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['ALBINO']].describe()", "Data transformation operation": ["summary statistics"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there an obvious clustering", "Relevant data columns": ["REGION", "ALBINO", "AUTISM", "VISUALLY IMPAIRED"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "from sklearn.cluster import KMeans;kmeans = KMeans(n_clusters=8);kmeans.fit(df[['ALBINO', 'AUTISM', 'DEAF-MUTE', 'DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']]);labels = kmeans.labels_", "Data transformation operation": ["cluster"], "New Column Name": "Cluster Label", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "kindly rate the regions on the basis of the number of patients", "Relevant data columns": ["REGION", "ALBINO", "AUTISM", "DEAF-MUTE", "DEAF-BLIND", "MENTALLY IMPAIRED", "PHYSICAL IMPAIRED", "VISUALLY IMPAIRED"], "Data column classification": ["inferred", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["sort", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether the rating should be done separately for each type of patient or overall.", "Ambiguity resolution": "Rate the regions based on the total number of patients across all categories.", "Data transformations": "total_patients_per_region = df.sum(axis=1).reset_index()", "Data transformation operation": ["sum", "transpose"], "New Column Name": "Total Patients", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "they want to know what tactic is most effective during football", "Relevant data columns": ["goals", "tactic"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether effectiveness should be measured by total number of goals scored or average goals scored per attempt.", "Ambiguity resolution": "Measure both total number of goals scored and average goals scored per attempt to determine the most effective tactic", "Data transformations": "goal_counts = df.groupby('tactic')['goals'].sum(); avg_goal_rates = df.groupby('tactic')['goals'].mean() / df.groupby('tactic')['shooting attempts'].mean()", "Data transformation operation": ["groupby", "sum", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "were you aware of the most recent news", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["retrieve value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The query does not seem to relate to the given dataset about players' performances.", "Ambiguity resolution": "It seems like the query is asking about general awareness of current events rather than something specific to the dataset.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the clubs should be arranged by their shooting attempts", "Relevant data columns": ["shooting attempts", "player name"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether the arrangement should be ascending or descending order", "Ambiguity resolution": "Arrange in descending order since higher shooting attempts indicate better performance", "Data transformations": "df.sort_values(by='shooting attempts', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "the games are sorted by experts by their date", "Relevant data columns": ["date", "game", "shooting attempts", "goals", "player name", "tactic"], "Data column classification": ["inferred", "inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": [], "Low-level visualization task classification": [], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "rank these clubs by their shooting attempts", "Relevant data columns": ["shooting attempts", "player name"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Sort"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='shooting attempts', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can lower study times among students cause greater failure rates in class", "Relevant data columns": ["studytime", "failures"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['studytime', 'failures']].corr()", "Data transformation operation": ["correlation calculation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you show me the list sorted by study time ( longest to shortest )", "Relevant data columns": ["studytime"], "Data column classification": ["keyword"], "Low-level visualization task": ["Sort"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='studytime', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "find the distribution by age", "Relevant data columns": ["age"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['age']].value_counts().plot(kind='bar')", "Data transformation operation": ["value counts", "plot bar chart"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me which students have fathers that are teachers", "Relevant data columns": ["Fjob"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_filtered = df[df['Fjob']=='teacher']", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "retrieve the students with fathers who work as teachers", "Relevant data columns": ["Fjob", "famrel"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Retrieval"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df['Fjob']=='teacher') & (df['famrel']!='no')]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "i 'm wondering would the travel time decrease for students if they spent more time studying", "Relevant data columns": ["traveltime", "studytime"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['traveltime', studytime']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "please help me identify the least common age", "Relevant data columns": ["age"], "Data column classification": ["keyword"], "Low-level visualization task": ["Find Anomalies", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.age.value_counts().idxmin()", "Data transformation operation": ["value count", "argmin"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the country with the lowest trust score", "Relevant data columns": ["Trust (Government Corruption)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Find Minimum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "trust_score_min = df.loc[df['Trust (Government Corruption)'].idxmin()]", "Data transformation operation": ["sort", "find min"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a correlation between happiness scores and other attributes", "Relevant data columns": ["Happiness Score", "Economy (GDP per Capita)", "Family", "Health (Life Expectancy)", "Freedom", "Trust (Government Corruption)", "Generosity", "Dystopia Residual"], "Data column classification": ["keyword", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether correlations need to be computed separately for each region or globally.", "Ambiguity resolution": "Compute global correlations; compute regional correlations for further exploration", "Data transformations": "corr_matrix = df.corr()[['Happiness Score']]", "Data transformation operation": ["compute correlation matrix"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me any clustering there may be in the gdp that has a happiness score of larger than 5", "Relevant data columns": ["Happiness Score", "Economy (GDP per Capita)", "Region"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["Cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether 'clustering' means grouping by region or identifying patterns in GDP vs Happiness Score.", "Ambiguity resolution": "Assuming clustering refers to pattern identification in GDP vs Happiness Score.", "Data transformations": "filtered_df = df[(df['Happiness Score']>5)]; clustered_gdp_happiness = filtered_df[['Economy (GDP per Capita)','Happiness Score']].groupby('Economy (GDP per Capita)').plot(kind='scatter')", "Data transformation operation": ["filter", "groupby", "plot"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "within the last year have any countries experienced a sudden decrease in happiness score", "Relevant data columns": ["Happiness Score", "Country", "Region"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'last year' could refer to either the most recent available year or a specific time range.", "Ambiguity resolution": "Assume the most recent available year and compare with previous year's scores", "Data transformations": "latest_year = max(df['Year']); prev_year = latest_year - 1; latest_scores = df[df['Year']==latest_year]['Happiness Score']; prev_scores = df[(df['Year']==prev_year)&(df['Country'].isin(latest_scores.index))]['Happiness Score']; decreased_scores = latest_scores[latest_scores < prev_scores]; decreased_countries = list(decreased_scores.index)", "Data transformation operation": ["sort", "compare", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "out of all the countries, which ones have a happiness score higher then finland", "Relevant data columns": ["Happiness Score", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "finland_happiness_score = df.loc[df['Country']=='Finland', 'Happiness Score']; result_df = df[df['Happiness Score']>finland_happiness_score]", "Data transformation operation": ["filter", "compare"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me in what range will the number of countries in each region fall", "Relevant data columns": ["Region"], "Data column classification": ["keyword"], "Low-level visualization task": ["determine range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "region_counts = df['Region'].value_counts()", "Data transformation operation": ["groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show all the countries with happiness scores higher than 5", "Relevant data columns": ["Happiness Score", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[(df['Happiness Score']>5)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the distribution of the health score as it is presented in different regions", "Relevant data columns": ["Health (Life Expectancy)", "Region"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Region','Health (Life Expectancy)']].groupby('Region')['Health (Life Expectancy)'].plot.kde()", "Data transformation operation": ["groupby", "plot kde"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me the average gdp of countries in western europe", "Relevant data columns": ["Economy (GDP per Capita)", "Region"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "western_europe_gdp_avg = df.loc[df['Region']=='Western Europe']['Economy (GDP per Capita)'].mean()", "Data transformation operation": ["filter", "calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "organize the countries by their region", "Relevant data columns": ["Region", "Country"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["sort", "cluster"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.groupby('Region')['Country'].apply(list); df.pivot_table(index='Region', aggfunc=lambda x: ''.join(x))", "Data transformation operation": ["groupby", "pivot_table"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the range of economy across all the countries", "Relevant data columns": ["Economy (GDP per Capita)", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Determine Range"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result = df[['Country', 'Economy (GDP per Capita)']].copy(); result['Range'] = [f'Economy Range: ({min}", "Data transformation operation": ["copy", "compute range"], "New Column Name": "Range", "Derivation Specification": "min_economy = df['Economy (GDP per Capita)'].min(); max_economy = df['Economy (GDP per Capita)'].max();", "Missing Data Column": ""}, {"query": "can we conclude that higher happiness comes from higher freedom", "Relevant data columns": ["Happiness Score", "Freedom"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlation"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Happiness Score', 'Freedom']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "retrieve the country that has had a sudden decrease in happiness score within a year", "Relevant data columns": ["Happiness Score", "Country", "Region"], "Data column classification": ["keyword", "keyword", "inferred"], "Low-level visualization task": ["Find Anomalies", "Compare", "Trend"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear what constitutes a sudden' decrease in happiness score.", "Ambiguity resolution": "Define a threshold for percentage change in happiness score between consecutive years.", "Data transformations": "df.sort_values(by='Year')['Happiness Score'].pct_change().reset_index()", "Data transformation operation": ["sort", "calculate percent change"], "New Column Name": "happiness_score_pct_change", "Derivation Specification": "(df['Happiness Score'].shift(1) - df['Happiness Score']) / df['Happiness Score'].shift(1)", "Missing Data Column": ""}, {"query": "can you rearrange the table by book rating in descending order", "Relevant data columns": ["averageRating"], "Data column classification": ["keyword"], "Low-level visualization task": ["Sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='averageRating', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what books have low ratings that seem suspect", "Relevant data columns": ["averageRating", "title", "authors"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["filter", "characterize distribution", "find anomalies"], "Low-level visualization task classification": ["inferred", "inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what constitutes a 'low' rating and what makes a book suspect'", "Ambiguity resolution": "Determine threshold for low ratings and define criteria for suspicious books", "Data transformations": "df = df[(df['averageRating'] < 3.5) | ((df['averageRating'].isnull()))][['title', 'authors', 'averageRating']]", "Data transformation operation": ["filter", "logical operator", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "of fiction books, which are written in english", "Relevant data columns": ["categories", "language"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether the query wants only Juvenile Fiction or all types of fiction.", "Ambiguity resolution": "Filter by categories containing 'Fiction' and language equal to 'en'", "Data transformations": "filtered_df = df[(df['categories'].str.contains('Fiction')) & (df['language']=='en')]", "Data transformation operation": ["filter", "contains"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show a list of similarly rated books", "Relevant data columns": ["title", "averageRating"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Retreive Value", "Filter", "Compare"], "Low-level visualization task classification": ["Inferred", "Inferred", "Keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what rating threshold is considered similar", "Ambiguity resolution": "Determine a suitable range around the average rating to define similarity", "Data transformations": "similarly_rated_books = df[(df['averageRating'] >= target_rating - tolerance) & (df['averageRating'] <= target_rating + tolerance)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "produce a list of book titles published during the current year", "Relevant data columns": ["title", "publishedDate"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["filter", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear what \"current year\" refers to.", "Ambiguity resolution": "Assume the current year is the latest year available in the dataset.", "Data transformations": "df.loc[(df['publishedDate'].dt.year == max(df['publishedDate'].dt.year)), ['title']]", "Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "dark horse comic has how many books", "Relevant data columns": ["title", "publisher"], "Data column classification": ["inferred", "inferred"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether Dark Horse Comic refers to a publisher or author.", "Ambiguity resolution": "Assume Dark Horse Comic is a publisher and count number of books by that publisher.", "Data transformations": "filtered_df = df[df['publisher']=='Dark Horse Comic']; book_count = filtered_df.shape[0]", "Data transformation operation": ["filter", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in terms of the readings, group the similar timestamps for the sants", "Relevant data columns": ["Station", "Generated", "O3 Hour", "NO2 Hour", "PM10 Hour"], "Data column classification": ["data value mention", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Cluster", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the grouping should be done by hour only or by date as well", "Ambiguity resolution": "Group by both date and time components", "Data transformations": "df_sants = df[df['Station']=='Barcelona - Sants']; df_sants['datetime'] = pd.to_datetime(df_sants['Generated']); df_sants_grouped = df_sants.resample('H', on='datetime')[['O3 Hour', 'NO2 Hour', 'PM10 Hour']].mean()", "Data transformation operation": ["filter", "resample", "mean"], "New Column Name": "datetime", "Derivation Specification": "pd.to_datetime(df_sants['Generated'])", "Missing Data Column": ""}, {"query": "for o3, what is the distribution value", "Relevant data columns": ["O3 Value"], "Data column classification": ["synonym"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the entire range of values should be considered or only certain parts.", "Ambiguity resolution": "Consider the full range of O3 Values", "Data transformations": "o3_distribution = df['O3 Value'].value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in the whole table, show me the best record of pm10", "Relevant data columns": ["PM10 Value", "Station", "Generated"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether 'best' refers to the maximum or minimum value.", "Ambiguity resolution": "Assuming 'best' means the maximum value.", "Data transformations": "pm10_max_row = df.loc[df['PM10 Value'].idxmax()]", "Data transformation operation": ["find max"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "based on their pollution, group the locations together that are similar", "Relevant data columns": ["Station", "O3 Value", "NO2 Value", "PM10 Value", "Air Quality"], "Data column classification": ["inferred", "keyword", "keyword", "keyword", "inferred"], "Low-level visualization task": ["Cluster", "Similarity"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what kind of similarity measure should be used to determine the grouping of locations.", "Ambiguity resolution": "Use clustering algorithms such as k-means or hierarchical clustering to group stations by air quality metrics.", "Data transformations": "from sklearn.cluster import KMeans; kmeans = KMeans(n_clusters=5); clustered_stations = kmeans.fit_predict(df[['O3 Value', 'NO2 Value', 'PM10 Value']].fillna(0))", "Data transformation operation": ["cluster"], "New Column Name": "Cluster ID", "Derivation Specification": "np.where(clustered_stations==0,'Group A', np.where(clustered_stations==1,'Group B'))", "Missing Data Column": ""}, {"query": "in what manner are good air quality records dispersed throughout the monitored region", "Relevant data columns": ["Station", "Air Quality", "Longitude", "Latitude"], "Data column classification": ["data value mention", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of dispersion and manner could imply various methods of spatial analysis such as clustering, hotspots identification or even interpolation.", "Ambiguity resolution": "Perform Spatial Analysis Techniques to understand patterns of dispersion; Apply clustering algorithms like K-Means or DBSCAN to classify regions by their characteristics.", "Data transformations": "import geopylib; from geopylib import geohash; df['geohash'] = geohash.encode(lat=df['Latitude'], lon=df['Longitude'], precision=6); clustered_data = df.groupby(by='geohash')['Air Quality'].apply(lambda x: x.value_counts(normalize=True))", "Data transformation operation": ["encode", "groupby", "value counts"], "New Column Name": "", "Derivation Specification": "", "Miscellaneous Column": ""}, {"query": "are there any outliers in pm10 readings from a temporal perspective", "Relevant data columns": ["PM10 Value", "Generated"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_PM10 = df[['Generated', 'PM10 Value']].copy(); df_PM10['Generated'] = pd.to_datetime(df_PM10['Generated'])", "Data transformation operation": ["select", "datetime conversion"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "work out the quality of o3", "Relevant data columns": ["O3 Quality"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "o3_quality_counts = df['O3 Quality'].value_counts()", "Data transformation operation": ["value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "put the readings in order according to their pm 10 values", "Relevant data columns": ["Station", "PM10 Value"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Sort"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='PM10 Value')", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is distribution for pm10 value anything other than normal", "Relevant data columns": ["PM10 Value"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'normal' might refer to a Gaussian distribution but could also mean any non-skewed distribution.", "Ambiguity resolution": "Check for skewness and kurtosis to determine deviation from normalcy.", "Data transformations": "pm10_values = df['PM10 Value']; stats.describe(pm10_values)", "Data transformation operation": ["describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me the count of missing readings in this table", "Relevant data columns": ["O3 Value", "NO2 Value", "PM10 Value"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Find Anomalies"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "missing_count = df.isnull().sum()", "Data transformation operation": ["isnull", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the data attribute that has the most na values, for example the hardest data points to collect", "Relevant data columns": ["O3 Value", "NO2 Value", "PM10 Value"], "Data column classification": ["inferred", "inferred", "inferred"], "Low-level visualization task": ["find pattern"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "nan_counts = df.isnull().sum()", "Data transformation operation": ["isnull", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "describe the change in air quality over one day  describe the change in each air pollutant", "Relevant data columns": ["Station", "Air Quality", "O3 Value", "NO2 Value", "PM10 Value", "Generated"], "Data column classification": ["keyword", "inferred", "keyword", "keyword", "keyword", "inferred"], "Low-level visualization task": ["Trend", "Characterize Distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The time range for describing the changes is ambiguous since only hourly data points are available.", "Ambiguity resolution": "Aggregate hourly data into daily summaries to analyze changes.", "Data transformations": "daily_summary_df = df.resample('D', on='Generated')['Air Quality', 'O3 Value', 'NO2 Value', 'PM10 Value'].mean()", "Data transformation operation": ["resample", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "across the monitored region, what is the distribution of records for good air quality", "Relevant data columns": ["O3 Quality", "NO2 Quality", "PM10 Quality", "Station"], "Data column classification": ["keyword", "keyword", "keyword", "inferred"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the distribution refers to a count of stations with good air quality or a more detailed statistical description.", "Ambiguity resolution": "Count the number of stations with good air quality and describe its distribution.", "Data transformations": "good_air_quality_stations = df[(df['O3 Quality']=='Good') | (df['NO2 Quality']=='Good') | (df['PM10 Quality']=='Good')] ; station_counts = good_air_quality_stations['Station'].value_counts()", "Data transformation operation": ["filter", "merge", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in the premier league how are the transferred players ages distributed", "Relevant data columns": ["Age", "League_to", "Team_to"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'distributed' could imply either showing individual points or aggregating them into groups/bins.", "Ambiguity resolution": "Assume distribution refers to showing the frequency count of age groups", "Data transformations": "premier_league_transfers = df[(df['League_to']=='Premier League')] ; age_distribution = premier_league_transfers['Age'].value_counts()", "Data transformation operation": ["filter", "groupby", "count"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you buy a player with his market value higher than a transfer fee", "Relevant data columns": ["Market_value", "Transfer_fee"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Compare"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[(df['Market_value']>df['Transfer_fee'])]", "Data transformation operation": ["compare"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "list center -backs by what their transfer_fee was", "Relevant data columns": ["Position", "Transfer_fee"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Sort", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "center_backs = df[(df['Position']=='Centre-Back')] ; sorted_center_backs = center_backs.sort_values(by='Transfer_fee') ", "Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there an average run time for movies", "Relevant data columns": ["duration", "type"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["calculate mean"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "movie_durations = df[(df['type']=='Movie')]['duration']; avg_movie_duration = movie_durations.mean()", "Data transformation operation": ["filter", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the dates that netflix released movies", "Relevant data columns": ["date_added"], "Data column classification": ["keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether you want the exact dates or just the years", "Ambiguity resolution": "Assuming you want the exact dates", "Data transformations": "df[['title', release_year', 'date_added']].sort_values(by='date_added')", "Data transformation operation": ["select", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what percentage of the blount county, alabama population is white", "Relevant data columns": ["White", "TotalPop", "County", "State"], "Data column classification": ["keyword", "inferred", "data value mention", "data value mention"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "blount_county_population = df[(df['State']=='Alabama') & (df['County']==\"Blount County\")]; result = (blount_county_population['White'][0] / blount_county_population['TotalPop'][0]) * 100;", "Data transformation operation": ["filter", "divide", "multiply"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "sort all the counties in connecticut by the percentages of the hispanic population", "Relevant data columns": ["County", "State", "Hispanic"], "Data column classification": ["data value mention", "data value mention", "keyword"], "Low-level visualization task": ["Sort", "Filter"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "connecticut_counties = df[df['State']==\"Connecticut\"][['County','Hispanic']].sort_values(by='Hispanic', ascending=False)", "Data transformation operation": ["filter", "sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you tell me the sales distribution of type 4046 in 2015", "Relevant data columns": ["type", "year", "Total Volume"], "Data column classification": ["data value mention", "inferred", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df_type_4046_in_2015 = df[(df['type']==4046)&(df['year']==2015)]; volume_distribution = df_type_4046_in_2015[['Total Volume']].describe()", "Data transformation operation": ["filter", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what are the groups of regions according to three types of avocados sales ratio", "Relevant data columns": ["region", "type", "AveragePrice", "Total Volume"], "Data column classification": ["inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear what exactly constitutes a sales ratio' from the given data, whether it's AveragePrice, TotalVolume, or something else.", "Ambiguity resolution": "Use a combination of AveragePrice and TotalVolume to create a sales ratio metric.", "Data transformations": "df['SalesRatio'] = df['AveragePrice'] / df['Total Volume']; grouped_regions = df.groupby(['region', 'type'])['SalesRatio'].mean().reset_index()", "Data transformation operation": ["derive new column", "groupby", "calculate mean"], "New Column Name": "SalesRatio", "Derivation Specification": "(AveragePrice / TotalVolume)", "Missing Data Column": ""}, {"query": "using the three types of avocado 's sales ratio, provide the groups of regions", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["cluster", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The query does not specify which columns in the dataset correspond to avocado types and their sales ratios.", "Ambiguity resolution": "Identify relevant columns in the dataset that could potentially relate to avocado types and sales ratios", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Columns representing avocado types and sales ratios"}, {"query": "provide the distribution of the sales in 2015 of type 4046", "Relevant data columns": ["Date", "Total Volume", "type", "year"], "Data column classification": ["inferred", "keyword", "data value mention", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['type']==4046) & (df['year']==2015)]; filtered_df[['Total Volume']].describe()", "Data transformation operation": ["filter", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "determine in what year the income of undergraduate students was higher", "Relevant data columns": ["Undergraduate Income", "Year"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Find Maximum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to compare the income within each country or across countries.", "Ambiguity resolution": "Compare the incomes across countries for each year and then find the year with the highest income.", "Data transformations": "df.sort_values(by='Undergraduate Income', ascending=False).reset_index(drop=True)", "Data transformation operation": ["sort", "reset index"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how are postgraduate student numbers distributed every year", "Relevant data columns": ["Postgraduate", "Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["characterize distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the distribution refers to the absolute number of students or proportion/percentage of total students.", "Ambiguity resolution": "Assume the question asks about the distribution of absolute number of students.", "Data transformations": "df[['Year', 'Postgraduate']].groupby('Year')['Postgraduate'].plot(kind='bar')", "Data transformation operation": ["groupby", "plot bar chart"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "state the average income of postgraduate students in each country", "Relevant data columns": ["Postgraduate Income", "Country"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Country','Postgraduate Income']].groupby('Country')['Postgraduate Income'].mean()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the number of postgraduate students for each year", "Relevant data columns": ["Postgraduate", "Year"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Retrieval"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Year','Postgraduate']].groupby('Year')['Postgraduate'].sum()", "Data transformation operation": ["groupby", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in each year, what is the distribution of the number of postgraduates", "Relevant data columns": ["Postgraduate", "Year"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'distribution' could refer to any type of visual representation of the data.", "Ambiguity resolution": "Assume the user wants to visualize the spread of postgraduate numbers across years", "Data transformations": "df[['Year', 'Postgraduate']].groupby('Year')['Postgraduate'].describe()", "Data transformation operation": ["groupby", "describe"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what differences are there among the students who acquired more than 270 points between 2010 -2019", "Relevant data columns": ["Total Points", "Student Average", "First Name", "Last Name", "age", "CW 1", "CW 2", "Mid-term exams", "Final exam"], "Data column classification": ["keyword", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["filter", "characterize distribution"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether only certain years need to be considered within the specified time period.", "Ambiguity resolution": "Filter out rows where the total points are greater than 270 and then compare student characteristics during those years.", "Data transformations": "filtered_data = df[(df['Total Points']>270)]; filtered_data[['First Name','Last Name','age','CW 1','CW 2','Mid-term exams','Final exam']] ", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me all of the categories of grade types", "Relevant data columns": ["Grade"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution", "Retreive Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "grade_types = df['Grade'].unique()", "Data transformation operation": ["unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "use the midterm exam and final exam as the 2nd and 1st keywords respectively in order to assign a rank to every one of the students", "Relevant data columns": ["Mid-term exams", "Final exam"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Sort", "Rank"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the ranking should consider both mid-term and final exams equally or prioritize one over another", "Ambiguity resolution": "Combine scores from mid-term and final exams into a single score", "Data transformations": "df['Combined Score'] = df[['Mid-term exams', 'Final exam']].mean(axis=1); df['Rank'] = df['Combined Score'].rank(ascending=False)", "Data transformation operation": ["combine", "calculate mean", "generate ranks"], "New Column Name": "Combined Score", "Derivation Specification": "average of Mid-term exams and Final exam scores", "Missing Data Column": ""}, {"query": "what did the majority of students receive as a grade", "Relevant data columns": ["Grade"], "Data column classification": ["keyword"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider only non-NaN grades.", "Ambiguity resolution": "Filter out rows with NaN grades.", "Data transformations": "grade_counts = df[pd.notnull(df['Grade'])]['Grade'].value_counts()", "Data transformation operation": ["filter", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "use the final exam as the first keyword and midterm exam as the second keyword to rank all the students", "Relevant data columns": ["Final exam", "Mid-term exams"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Sort", "Compare"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "ranked_students = df.sort_values(by=['Final exam','Mid-term exams'], ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me the scope, among all the students, of the cw2 score", "Relevant data columns": ["CW 2", "Student"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the query wants to see the distribution of CW2 scores overall or compare them between students.", "Ambiguity resolution": "Assume the query wants to visualize the distribution of CW2 scores without comparing between students.", "Data transformations": "df[['CW 2']].describe()", "Data transformation operation": ["summary statistics"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "in cw1, how many students achieved the feat of 100%, or full marks", "Relevant data columns": ["CW 1"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[(df['CW 1']==100)]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "select all cw1 scores not less than 80%", "Relevant data columns": ["CW 1"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df = df[df['CW 1'] >= 80]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the distribution of the total points of the students", "Relevant data columns": ["Total Points"], "Data column classification": ["keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Total']]", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "provide the total sum of all the separated, divorced, and widowed people in lindi", "Relevant data columns": ["Regions", "Separated", "Divorced", "Widowed"], "Data column classification": ["inferred", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Compute Derived Value", "Summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "Lindi region does not exist in the given dataset", "Ambiguity resolution": "Use available regions instead", "Data transformations": "result_df = df[['Separated', 'Divorced', 'Widowed']].sum()", "Data transformation operation": ["sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you see any abnormalities in the suicide rates", "Relevant data columns": ["suicides_no", "population", "country"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what constitutes an abnormality in the suicide rate.", "Ambiguity resolution": "Use statistical methods such as mean and standard deviation to determine outliers in the suicide rate distribution.", "Data transformations": "df['suicide_rate'] = df['suicides_no'] / df['population'] * 100_000; anomalies = np.abs(stats.zscore(df['suicide_rate'])) > 2;", "Data transformation operation": ["calculate", "normalize", "filter"], "New Column Name": "suicide_rate", "Derivation Specification": "df['suicide_rate'] = df['suicides_no'] / df['population'] * 100_000", "Missing Data Column": ""}, {"query": "name the country with the lowest suicide rate", "Relevant data columns": ["country", "suicides/100k pop"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["Find Minimum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "result=df.loc[df['suicides/100k pop'].idxmin()]", "Data transformation operation": ["sort", "minimum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do you know the average number of suicides in europe", "Relevant data columns": ["suicides_no", "country"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether Europe refers to European Union or the geographical continent.", "Ambiguity resolution": "Filter by country names containing 'Europe' or belonging to EU", "Data transformations": "europe_data = df[df['country'].str.contains('Europe|europa', case=False)]; avg_suicides_eu = europe_data['suicides_no'].mean()", "Data transformation operation": ["filter", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "are there any countries with anomalously low suicides rates", "Relevant data columns": ["country", "suicides_no", "population", "suicides/100k pop"], "Data column classification": ["inferred", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the question refers to absolute numbers or relative suicide rates.", "Ambiguity resolution": "Use standardized suicide rate per 100,000 people", "Data transformations": "df['suicide_rate_per_100k_pop_log_scaled'] = np.log(df['suicides/100k pop']); Q1 = df['suicide_rate_per_100k_pop_log_scaled'].quantile(0.25); Q3 = df['suicide_rate_per_100k_pop_log_scaled'].quantile(0.75); IQR = Q3 - Q1; lower_bound = Q1 - 1.5*IQR; upper_bound = Q3 + 1.5*IQR;", "Data transformation operation": ["log scale", "calculate quantiles", "calculate bounds"], "New Column Name": "suicide_rate_per_100k_pop_log_scaled", "Derivation Specification": "np.log(df['suicides/100k pop'])", "Missing Data Column": ""}, {"query": "were there any countries with abnormally low suicide rates", "Relevant data columns": ["country", "suicides_no", "population", "suicides/100k pop"], "Data column classification": ["inferred", "keyword", "keyword", "derived metric"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'abnormal' is subjective and requires definition.", "Ambiguity resolution": "Use statistical methods such as Z-score calculation or density-based outlier detection to define abnormality", "Data transformations": "df['z_score_suicide_rate'] = (df['suicides/100k pop'] - df['suicides/100k pop'].mean()) / df['suicides/100k pop'].std(); anomalies = df[np.abs(df['z_score_suicide_rate']) > 2]", "Data transformation operation": ["calculate mean", "calculate std dev", "subtract", "divide", "absolute value", "compare"], "New Column Name": "z_score_suicide_rate", "Derivation Specification": "(df['suicides/100k pop'] - df['suicides/100k pop'].mean()) / df['suicides/100k pop'].std()", "Missing Data Column": ""}, {"query": "with the suicide larger than 100, determine the ages in albania", "Relevant data columns": ["country", "age", "suicides_no"], "Data column classification": ["data value mention", "inferred", "keyword"], "Low-level visualization task": ["filter", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The phrase 'larger than 100' is ambiguous because it could refer to either the number of suicides or the rate of suicides per 100k population", "Ambiguity resolution": "Interpret 'larger than 100' as referring to the number of suicides", "Data transformations": "albania_data = df[(df['country']=='Albania') & (df['suicides_no']>100)]; result = albania_data[['age']]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the distribution rate of suicide", "Relevant data columns": ["suicides_no", "population"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear whether the distribution refers to the overall rate or by certain demographics such as age groups or sexes.", "Ambiguity resolution": "", "Data transformations": "df['suicide_rate'] = df['suicides_no'] / df['population'] * 100000;", "Data transformation operation": ["calculate"], "New Column Name": "suicide_rate", "Derivation Specification": "(suicides_no / population) * 100000", "Missing Data Column": ""}, {"query": "what is the total number of all suicides in 1999", "Relevant data columns": ["suicides_no", "year"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["Filter", "Compute Derived Value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['year']==1999), ['suicides_no']].sum()", "Data transformation operation": ["filter", "sum"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "would there be any clustering of countries in terms of suicide rates", "Relevant data columns": ["country", "suicides_no", "population", "suicides/100k pop"], "Data column classification": ["inferred", "keyword", "derived metric", "derived metric"], "Low-level visualization task": ["Cluster"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the clustering refers to geographic proximity or demographic similarity.", "Ambiguity resolution": "Perform k-means clustering on derived metrics such as suicide rate", "Data transformations": "df['Suicide Rate (%)'] = df['suicides_no']/df['population']*100000; clustered_data = df[['country','Suicide Rate (%)']].groupby('country')['Suicide Rate (%)'].apply(lambda x: x.values.reshape(-1,1))", "Data transformation operation": ["derive", "groupby", "reshape"], "New Column Name": "Suicide Rate (%)", "Derivation Specification": "df['Suicide Rate (%)'] = df['suicides_no']/df['population']*100000", "Missing Data Column": ""}, {"query": "of all countries, how is the gdp distribution", "Relevant data columns": ["country", "gdp_for_year ($)"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether we need to consider only one year or multiple years while calculating the GDP distribution.", "Ambiguity resolution": "Consider all available years and aggregate them to get the overall GDP distribution", "Data transformations": "df = df.groupby('country')['gdp_for_year ($)'].agg(['mean', std', median']).reset_index()", "Data transformation operation": ["groupby", "aggregate"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "has there been an increase or decrease in the gdp of china over the last 10 years", "Relevant data columns": ["country", "year", "gdp_for_year ($)"], "Data column classification": ["data value mention", "inferred", "keyword"], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "China is not present in the given dataset", "Ambiguity resolution": "Use alternative datasets or sources containing China's GDP information", "Data transformations": "Not applicable since China is not present in the dataset", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "china"}, {"query": "i want to see the distribution of the school rankings in geita in 2006", "Relevant data columns": ["REGION", "RANK", "YEAR_OF_RESULT"], "Data column classification": ["keyword", "keyword", "data value mention"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The query does not specify what type of distribution is desired.", "Ambiguity resolution": "Assume a frequency distribution plot of ranks is intended.", "Data transformations": "geita_data = df[(df['REGION']=='GEITA') & (df['YEAR_OF_RESULT']==2006)]; rank_distribution = geita_data['RANK'].value_counts()", "Data transformation operation": ["filter", "selection", "aggregation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "create a list of schools showing the descending order by change_p", "Relevant data columns": ["NAME", "CHANGE_PREVIOUS_YEAR"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["sort", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.sort_values(by='CHANGE_PREVIOUS_YEAR', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you provide a list of school names in geita", "Relevant data columns": ["NAME", "REGION"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['REGION']=='GEITA']; filtered_df[['NAME']] ", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "determine if there are any schools in neighboring regions that have similar avg_m", "Relevant data columns": ["REGION", "DISTRICT", "AVG_MARK"], "Data column classification": ["keyword", "keyword", "keyword"], "Low-level visualization task": ["Find Similarity"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The concept of neighboring region is ambiguous.", "Ambiguity resolution": "Define neighboring regions by district proximity", "Data transformations": "df_district_avg = df.groupby(['DISTRICT'])['AVG_MARK'].mean().reset_index(); merged_df = pd.merge(df, df_district_avg, left_on='DISTRICT', right_on='DISTRICT', suffixes=('_school', '_district'))", "Data transformation operation": ["groupby", "merge"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what schools have similar avg_m in the neighboring region", "Relevant data columns": ["REGION", "AVG_MARK"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Similarity"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term 'neighboring' could imply geographic proximity but also could mean similarity between regions.", "Ambiguity resolution": "Assume geographic proximity based on latitude and longitude.", "Data transformations": "from scipy.spatial import distance; def calc_distance(lat1, lon1, lat2, lon2): return distance.euclidean((lat1, lon1), (lat2, lon2)); df['DISTANCE_TO_NEIGHBOR'] = df.apply(lambda row: [calc_distance(row.LATITUDE, row.LONGITUDE, other_row.LATITUDE, other_row.LONGITUDE) for _, other_row in df.itertuples()], axis=1); similar_regions = df.sort_values(by='DISTANCE_TO_NEIGHBOR')['REGION']", "Data transformation operation": ["apply", "sort_values"], "New Column Name": "DISTANCE_TO_NEIGHBOR", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average height of the floors of these buildings", "Relevant data columns": ["Meters"], "Data column classification": ["keyword"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "average_floor_height = df['Meters']/df['Stories']", "Data transformation operation": ["divide"], "New Column Name": "Average Floor Height", "Derivation Specification": "(meters)/stories", "Missing Data Column": ""}, {"query": "indicate all the travels taking more than 1000 minutes", "Relevant data columns": ["trip_duration"], "Data column classification": ["keyword"], "Low-level visualization task": ["filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_trips = df[df['tripduration']>1000]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "show me a list of the tripe that take longer than 1,000 minutes", "Relevant data columns": ["trip_id", "tripduration"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["filter", "retrieve value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "filtered_df = df[df['tripduration']>1000][['trip_id', 'tripduration']]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "do you know of any trip that would take longer than 1000 minutes", "Relevant data columns": ["tripduration"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[df['tripduration']>1000]", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which position has the highest average of playing time", "Relevant data columns": ["Pos", "MPG"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "pos_mpg_avg = df.groupby('Pos')['MPG'].mean()", "Data transformation operation": ["groupby", "mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "can you help me find some popular songs", "Relevant data columns": ["Popularity"], "Data column classification": ["keyword"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "sorted_df = df.sort_values(by='Popularity', ascending=False)", "Data transformation operation": ["sort"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me which genres were mentioned", "Relevant data columns": ["Genre"], "Data column classification": ["keyword"], "Low-level visualization task": ["retrieve unique values"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df['Genre'].unique()", "Data transformation operation": ["unique"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what songs of the pop genrea has sam smith released", "Relevant data columns": ["Artist.Name", "Genre"], "Data column classification": ["mention", "mention"], "Low-level visualization task": ["Filter"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['Genre']=='pop') & (df['Artist.Name']==\"Sam Smith\")] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "when the score difference is more than 5, please list the extreme matches to this", "Relevant data columns": ["home_score", "away_score"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Find Anomalies", "Filter"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether we need to consider only certain tournaments or all tournaments.", "Ambiguity resolution": "Consider all tournaments", "Data transformations": "extreme_matches = df[(abs(df['home_score'] - df['away_score'])) > 5][['date', 'home_team', 'away_team', 'home_score', 'away_score']]", "Data transformation operation": ["calculate absolute difference", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "tell me all the tournament matches that the home team won against the away team", "Relevant data columns": ["home_team", "away_team", "home_score", "away_score", "tournament"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["filter", "compute derived value"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "matches_won_by_home_team = df[(df['home_score']>df['away_score'])&(df['tournament']!='')] ", "Data transformation operation": ["compare", "filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "which group of nations won the most games", "Relevant data columns": ["home_team", "away_team", "home_score", "away_score", "country"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "inferred"], "Low-level visualization task": ["summarize"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only the winner team or both teams' wins.", "Ambiguity resolution": "Consider both home and away teams' wins and losses", "Data transformations": "win_loss_data = pd.melt(df, id_vars='date', value_vars=['home_score', 'away_score'], var_name='team_type', value_name='score')[['team_type', 'value']].reset_index(drop=True); win_loss_data.loc[:, 'won'] = np.where(win_loss_data.score > win_loss_data.groupby('date')['score'].transform('mean'), True, False)", "Data transformation operation": ["melt", "groupby", "transform", "conditional assignment"], "New Column Name": "won", "Derivation Specification": "np.where(win_loss_data.score > win_loss_data.groupby('date')['score'].transform('mean'), True, False)", "Missing Data Column": ""}, {"query": "what group of nations of have the most games", "Relevant data columns": ["country"], "Data column classification": ["inferred"], "Low-level visualization task": ["compute derived value", "summarize"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether the term 'nations' refers specifically to 'home_team' and 'away_team'", "Ambiguity resolution": "", "Data transformations": "team_counts = df[['home_team', 'away_team']].stack().value_counts()", "Data transformation operation": ["stack", "value_counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what countries have won a similar number of games", "Relevant data columns": ["country", "home_score", "away_score"], "Data column classification": ["inferred", "keyword", "keyword"], "Low-level visualization task": ["cluster", "similarity"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term similar' is ambiguous - does it mean exactly equal or close within a certain range?", "Ambiguity resolution": "Determine a suitable threshold for defining similarity", "Data transformations": "wins_per_country = df.apply(lambda row: 1 if ((row['home_score']>row['away_score']) & (row['neutral']==False)) | ((row['away_score']>row['home_score']) & (row['neutral'])) else 0, axis=1); wins_per_country = wins_per_country.value_counts()", "Data transformation operation": ["apply", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "how can the population of ashley be illustrated to show distribution across five years", "Relevant data columns": ["County", "State", "July 1, 2000Population", "July 1, 2001Population", "July 1, 2002Population"], "Data column classification": ["data value mention", "inferred", "inferred", "inferred", "inferred"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "ashley_population = df.loc[df['County']=='Ashley'][['July 1, 2000\\Population', 'July 1, 2001\\Population', 'July 1, 2002\\Population']].T", "Data transformation operation": ["filter", "select", "transpose"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "give me the average population rating for ashley in the year 2000", "Relevant data columns": ["County", "July 1, 2000 Population"], "Data column classification": ["data value mention", "data value mention"], "Low-level visualization task": ["Compute Derived Value", "Retrieve Value"], "Low-level visualization task classification": ["inferred", "keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "ashley_data = df.loc[df['County']=='Ashley']; avg_population_2000 = ashley_data['July 1, 2000\\Population'].iloc[0]", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "identify the county that has the least population each year", "Relevant data columns": ["County", "State", "July 1, 2000Population", "July 1, 2001Population", "July 1, 2002Population"], "Data column classification": ["keyword", "keyword", "keyword", "keyword", "keyword"], "Low-level visualization task": ["Find Minimum", "Filter"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear whether we need to consider only one year at a time or compare populations across multiple years.", "Ambiguity resolution": "Consider each year separately and find the county with the least population for each year.", "Data transformations": "year_2000_min_pop_county = df.loc[df['July 1, 2000\\Population'].idxmin()]['County']; year_2001_min_pop_county = df.loc[df['July 1, 2001\\Population'].idxmin()]['County']; year_2002_min_pop_county = df.loc[df['July 1, 2002\\Population'].idxmin()]['County']", "Data transformation operation": ["sort", "argmin"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the average population in 2000", "Relevant data columns": ["April 1, 2000 Population", "County", "State"], "Data column classification": ["keyword", "inferred", "inferred"], "Low-level visualization task": ["Compute Derived Value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "average_population_2000 = df['April 1, 2000 Population'].mean()", "Data transformation operation": ["calculate mean"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "from all of the universities in london, list the one who has the most faculties", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["Find Extremum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The given dataset does not contain any information about universities in London or their number of faculties.", "Ambiguity resolution": "Provide additional data about universities in London including the number of faculties they have.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "University location (to identify universities in London)"}, {"query": "universities with similar number of teachers", "Relevant data columns": ["Num"], "Data column classification": ["keyword"], "Low-level visualization task": ["Cluster", "Similarity"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term similar' is ambiguous and could refer to exact matches or approximate matches.", "Ambiguity resolution": "Determine similarity threshold for number of teachers", "Data transformations": "df[(np.abs(stats.zscore(df['Num'])) < 2)]", "Data transformation operation": ["z-score calculation", "filtering"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the teacher distribution of new york universities", "Relevant data columns": ["Location", "Name"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It is unclear whether the question refers to the distribution of teachers within New York universities or the distribution of universities in New York.", "Ambiguity resolution": "Filter out only universities located in New York and then analyze their teacher distributions.", "Data transformations": "ny_universities = df[df['Location']=='NY']; ny_teacher_distribution = ny_universities[['Type']].value_counts()", "Data transformation operation": ["filter", "value counts"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "would teachers in harvard be considered outliers if the university was in new york", "Relevant data columns": ["Name", "Location", "Tuition"], "Data column classification": ["data value mention", "inferred", "inferred"], "Low-level visualization task": ["Find Anomalies"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's unclear why location being New York affects teacher outlier status", "Ambiguity resolution": "", "Data transformations": "df.loc[(df['Name']=='Harvard University') & (df['Location']!='Cambridge')] ", "Data transformation operation": ["filter"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the number of divisions in harvard university", "Relevant data columns": ["Name", "Num"], "Data column classification": ["data value mention", "keyword"], "Low-level visualization task": ["Retrieve Value"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["targeted"], "Ambiguity in the query": "It's ambiguous whether 'divisions' refers to the 'Rank' or the 'Type'", "Ambiguity resolution": "Assuming 'divisions' refer to the 'Num' column", "Data transformations": "df.loc[df['Name']=='Harvard University', ['Num']].values[0]", "Data transformation operation": ["filter", "select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a regional concentration trend in gdp development", "Relevant data columns": ["Country", "GDP"], "Data column classification": ["inferred", "keyword"], "Low-level visualization task": ["Trend", "Cluster"], "Low-level visualization task classification": ["inferred", "inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The term regional' could refer to geographic proximity or cultural similarity between countries.", "Ambiguity resolution": "Assume geographic proximity as the definition of regionality.", "Data transformations": "No direct transformation required but potentially useful to create a categorical variable for regions based on geographical location", "Data transformation operation": [], "New Column Name": "Region", "Derivation Specification": "( Manual creation of Region category based on geographic location )", "Missing Data Column": ""}, {"query": "how are gdp and mteu correlated", "Relevant data columns": ["mTEU", "GDP"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['mTEU', 'GDP']].corr()", "Data transformation operation": ["calculate correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "what is the propensity of the number of vehicles in japan and korea from the year 2000 to 2010", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["Trend"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "The query mentions Japan and Korea but these countries are not present in the given dataset.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "Number of Vehicles, Country"}, {"query": "does life expectancy have any relation with the percentage of smokers", "Relevant data columns": ["Life Expectancy (by years)", "Percentage of Smokers"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["correlate"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "df[['Life Expectancy (by years)', 'Percentage of Smokers']].corr()", "Data transformation operation": ["correlation"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is the male to female ratio more imbalanced in the last decade in russia", "Relevant data columns": [], "Data column classification": [], "Ambiguity in the query": "The query references Russia but the dataset only contains US states.", "Ambiguity resolution": "", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "", "Low-level visualization task": ["Compare"], "Low-level visualization task classification": ["inferred"]}, {"query": "to cluster the states in the us, i wish to use middle income", "Relevant data columns": ["Median Income 2007", "State"], "Data column classification": ["keyword", "data value mention"], "Low-level visualization task": ["Cluster"], "Low-level visualization task classification": ["keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether other variables will be considered during clustering besides median income.", "Ambiguity resolution": "Consider only median income for clustering.", "Data transformations": "df[['State', 'Median Income 2007']].copy()", "Data transformation operation": ["select"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "could you tell me the continental location of the poorest ( lowest income ) country", "Relevant data columns": ["Median Income 2007", "State"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["Find Minimum"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "poorest_state = df.loc[df['Median Income 2007'].idxmin()]", "Data transformation operation": ["sort", "min"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "when looking at the average income in european countries, what is the variance", "Relevant data columns": ["Median Income 2007", "State"], "Data column classification": ["keyword", "inferred"], "Low-level visualization task": ["compute derived value"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["targeted"], "Ambiguity in the query": "The data does not contain European countries but US states.", "Ambiguity resolution": "Clarify the scope of the question to either consider only the median income of US states or provide separate data for European countries.", "Data transformations": "", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": "European Country"}, {"query": "can you tell me if there is a correlation between revenue and the release year", "Relevant data columns": ["Revenue ($)", "Release Year"], "Data column classification": ["keyword", "keyword"], "Low-level visualization task": ["Correlate"], "Low-level visualization task classification": ["Keyword"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "", "Ambiguity resolution": "", "Data transformations": "corr_matrix = df[['Revenue ($)', 'Release Year']].corr()", "Data transformation operation": ["calculate correlation coefficient"], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}, {"query": "is there a typical film lengths group", "Relevant data columns": [], "Data column classification": [], "Low-level visualization task": ["Characterize Distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It is unclear what is meant by 'typical film lengths' and how it relates to the given dataset.", "Ambiguity resolution": "Assume 'film length' refers to a characteristic duration of movies within certain groups or categories.", "Data transformations": "df['Length'] =... # assume Length column exists or can be derived from other columns", "Data transformation operation": ["derive", "calculate"], "New Column Name": "Film_Length_Group", "Derivation Specification": "# No clear specification, need more information about what constitutes a 'typical film lengths group'", "Missing Data Column": "Length"}, {"query": "the chart teaches them the horsepower range", "Relevant data columns": ["horsepower"], "Data column classification": ["keyword"], "Low-level visualization task": ["distribution"], "Low-level visualization task classification": ["inferred"], "Visualization goal": ["exploratory"], "Ambiguity in the query": "It's unclear whether the chart is showing a specific distribution (e.g. histogram) or just providing information about the horsepower range.", "Ambiguity resolution": "Assume the chart shows a general distribution of horsepower values.", "Data transformations": "None needed, as the data already provides the required information", "Data transformation operation": [], "New Column Name": "", "Derivation Specification": "", "Missing Data Column": ""}]