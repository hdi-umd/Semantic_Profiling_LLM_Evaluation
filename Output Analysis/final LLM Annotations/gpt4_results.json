[
    {
        "query": "Relationship between IMDB Rating and Rotten Tomatoes Rating",
        "Relevant data columns": [
            "IMDB Rating",
            "Rotten Tomatoes Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['IMDB Rating', 'Rotten Tomatoes Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what's the production budget for movies in different years",
        "Relevant data columns": [
            "Production Budget",
            "Release Year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Release Year')['Production Budget'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Movie gross and budget relationship based on genre",
        "Relevant data columns": [
            "Worldwide Gross",
            "Production Budget",
            "Major Genre"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Worldwide Gross', 'Production Budget', 'Major Genre']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me imdb rating versus rotten tomatoes rating",
        "Relevant data columns": [
            "IMDB Rating",
            "Rotten Tomatoes Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['IMDB Rating', 'Rotten Tomatoes Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What creative type of movie had the highest production budget for each content rating",
        "Relevant data columns": [
            "Creative Type",
            "Production Budget",
            "Content Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Content Rating', 'Creative Type'])['Production Budget'].max().reset_index().sort_values(by='Production Budget', ascending=False).drop_duplicates(subset=['Content Rating'])",
        "Data transformation operation": [
            "groupby",
            "aggregate",
            "sort",
            "drop duplicates"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the relationship between production budget and worldwide gross for each major genre",
        "Relevant data columns": [
            "Production Budget",
            "Worldwide Gross",
            "Major Genre"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')[['Production Budget', 'Worldwide Gross']].mean()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the relationship between release year and average production budget",
        "Relevant data columns": [
            "Release Year",
            "Production Budget"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Release Year')['Production Budget'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What major genre had the highest average worldwide gross",
        "Relevant data columns": [
            "Major Genre",
            "Worldwide Gross"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].mean()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What major genre had the lowest average worldwide gross",
        "Relevant data columns": [
            "Major Genre",
            "Worldwide Gross"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].mean().idxmin()",
        "Data transformation operation": [
            "groupby",
            "mean",
            "index of minimum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How much did average worldwide gross vary by major genre",
        "Relevant data columns": [
            "Worldwide Gross",
            "Major Genre"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many movies are there of each creative type",
        "Relevant data columns": [
            "Creative Type"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Creative Type').size()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Which creative type had the most movies",
        "Relevant data columns": [
            "Creative Type"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Creative Type'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Which creative type had the fewest movies",
        "Relevant data columns": [
            "Creative Type"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Creative Type'].value_counts().idxmin()",
        "Data transformation operation": [
            "count",
            "find minimum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the total worldwide gross for each major genre across time",
        "Relevant data columns": [
            "Worldwide Gross",
            "Major Genre",
            "Release Year"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Major Genre', 'Release Year'])['Worldwide Gross'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Is there a relationship between production budget and worldwide gross for each content rating",
        "Relevant data columns": [
            "Production Budget",
            "Worldwide Gross",
            "Content Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Content Rating')[['Production Budget', 'Worldwide Gross']].corr()",
        "Data transformation operation": [
            "groupby",
            "correlation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the distribution of running times for each movie",
        "Relevant data columns": [
            "Running Time",
            "Title"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Title', 'Running Time']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Is there a relationship between IMDB rating and rotten tomatoes rating",
        "Relevant data columns": [
            "IMDB Rating",
            "Rotten Tomatoes Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['IMDB Rating', 'Rotten Tomatoes Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Movie run time distribution",
        "Relevant data columns": [
            "Running Time"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Running Time']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How production budget changes over release years",
        "Relevant data columns": [
            "Production Budget",
            "Release Year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Release Year', 'Production Budget']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What was the average production budget of movies by year",
        "Relevant data columns": [
            "Production Budget",
            "Release Year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Release Year')['Production Budget'].mean()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What's the average production budget of the different rated movies, separated by creative type",
        "Relevant data columns": [
            "Production Budget",
            "Content Rating",
            "Creative Type"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Content Rating', 'Creative Type'])['Production Budget'].mean()",
        "Data transformation operation": [
            "groupby",
            "average calculation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Which genre movie makes most worldwide gross",
        "Relevant data columns": [
            "Major Genre",
            "Worldwide Gross"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if the query is asking for the highest grossing movie in each genre or the genre which on average has the highest gross.",
        "Ambiguity resolution": "Assume the query is asking for the genre which on average has the highest worldwide gross.",
        "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].mean().idxmax()",
        "Data transformation operation": [
            "groupby",
            "aggregate",
            "find maximum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Are IMDb rating and rotten tomatoes rating related",
        "Relevant data columns": [
            "IMDB Rating",
            "Rotten Tomatoes Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['IMDB Rating', 'Rotten Tomatoes Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the worldwide gross distribution per genre",
        "Relevant data columns": [
            "Worldwide Gross",
            "Major Genre"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].describe()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what's the breakdown of production budget by creative type per content rating",
        "Relevant data columns": [
            "Production Budget",
            "Creative Type",
            "Content Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Creative Type', 'Content Rating'])['Production Budget'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how does Rotten Tomatoes Rating change as IMDB Rating",
        "Relevant data columns": [
            "Rotten Tomatoes Rating",
            "IMDB Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the total worldwide gross earned by each major genre and content rating",
        "Relevant data columns": [
            "Worldwide Gross",
            "Major Genre",
            "Content Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Major Genre', 'Content Rating'])['Worldwide Gross'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "For each genre and rating, what is the total world-wide gross earnings",
        "Relevant data columns": [
            "Major Genre",
            "Content Rating",
            "Worldwide Gross"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Major Genre', 'Content Rating'])['Worldwide Gross'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How much did each type of movie earn across the whole world",
        "Relevant data columns": [
            "Major Genre",
            "Worldwide Gross"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How much money did movies of each genre and rating make",
        "Relevant data columns": [
            "Major Genre",
            "Content Rating",
            "Worldwide Gross"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Major Genre', 'Content Rating'])['Worldwide Gross'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What was the average budget for each content rating and creative type, as multiple column charts",
        "Relevant data columns": [
            "Production Budget",
            "Content Rating",
            "Creative Type"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "cluster"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Content Rating', 'Creative Type'])['Production Budget'].mean()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the average production budget in each year",
        "Relevant data columns": [
            "Production Budget",
            "Release Year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Release Year')['Production Budget'].mean()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Compare imdb rating to rotten tomatoes rating",
        "Relevant data columns": [
            "IMDB Rating",
            "Rotten Tomatoes Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['IMDB Rating', 'Rotten Tomatoes Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Which creative types have the most movies",
        "Relevant data columns": [
            "Creative Type"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Creative Type'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "On average, how much was earned by movies of each genre",
        "Relevant data columns": [
            "Worldwide Gross",
            "Major Genre"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many movies are of each length",
        "Relevant data columns": [
            "Running Time"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Running Time'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Help me see outliers in IMDB and Rotten Tomatoes ratings",
        "Relevant data columns": [
            "IMDB Rating",
            "Rotten Tomatoes Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['IMDB Rating', 'Rotten Tomatoes Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What was the average worldwide gross of movies by genre",
        "Relevant data columns": [
            "Worldwide Gross",
            "Major Genre"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How much did major genres gross in total",
        "Relevant data columns": [
            "Major Genre",
            "Worldwide Gross"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')['Worldwide Gross'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "gross across genres regarding content rating",
        "Relevant data columns": [
            "Worldwide Gross",
            "Major Genre",
            "Content Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if the query is asking for a total, average, or another form of aggregation of gross across genres for each content rating.",
        "Ambiguity resolution": "Assume the query is asking for the total gross for each genre and content rating combination.",
        "Data transformations": "df.groupby(['Major Genre', 'Content Rating'])['Worldwide Gross'].sum().reset_index()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what's the distribution of running times by movie",
        "Relevant data columns": [
            "Running Time",
            "Title"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Title', 'Running Time']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how many movies are there in 20 minute bins of running time",
        "Relevant data columns": [
            "Running Time"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Running Time Bin'] = pd.cut(df['Running Time'], bins=range(0, df['Running Time'].max() + 20, 20), right=False); df.groupby('Running Time Bin').size()",
        "Data transformation operation": [
            "binning",
            "groupby",
            "count"
        ],
        "New Column Name": "Running Time Bin",
        "Derivation Specification": "pd.cut(df['Running Time'], bins=range(0, df['Running Time'].max() + 20, 20), right=False)",
        "Missing Data Column": ""
    },
    {
        "query": "how many movies are there for each creative type",
        "Relevant data columns": [
            "Creative Type"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Creative Type').size()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which creative types had the most movies",
        "Relevant data columns": [
            "Creative Type"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Creative Type'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Show me the variation in the amount ordered by different entities in different orders",
        "Relevant data columns": [],
        "Data column classification": [],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query mentions 'entities' and 'orders' which are not present in the dataset. It is unclear which columns these terms refer to.",
        "Ambiguity resolution": "Clarify with the user which columns correspond to 'entities' and 'orders'. If these terms refer to other aspects such as 'Title' for entities and 'Worldwide Gross' for orders, specify this in the query.",
        "Data transformations": "",
        "Data transformation operation": [],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "entities, orders"
    },
    {
        "query": "relation between rotten tomatoes rating and IMDB rating",
        "Relevant data columns": [
            "Rotten Tomatoes Rating",
            "IMDB Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "relation between rotten tomatoes and IMDB ratings",
        "Relevant data columns": [
            "Rotten Tomatoes Rating",
            "IMDB Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "worldwide gross for each genre for each year 1995 to now",
        "Relevant data columns": [
            "Worldwide Gross",
            "Major Genre",
            "Release Year"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query specifies 'to now' but the dataset may not include data up to the current year.",
        "Ambiguity resolution": "Assume 'to now' refers to the latest year available in the dataset.",
        "Data transformations": "df = df[(df['Release Year'] >= 1995) & (df['Release Year'] <= df['Release Year'].max())]; result = df.groupby(['Release Year', 'Major Genre'])['Worldwide Gross'].sum().reset_index()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how many films of each creative type",
        "Relevant data columns": [
            "Creative Type"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Creative Type').size()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Cumulative gross for each content rating, by major genre",
        "Relevant data columns": [
            "Worldwide Gross",
            "Content Rating",
            "Major Genre"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Content Rating', 'Major Genre'])['Worldwide Gross'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Relation between worldwide gross and production budget for each major genre",
        "Relevant data columns": [
            "Worldwide Gross",
            "Production Budget",
            "Major Genre"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Major Genre')[['Worldwide Gross', 'Production Budget']].mean()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Relationship of Rotten Tomatoes rating to IMDB rating",
        "Relevant data columns": [
            "Rotten Tomatoes Rating",
            "IMDB Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Rotten Tomatoes Rating', 'IMDB Rating']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Is there a correlation between acceleration and horsepower",
        "Relevant data columns": [
            "timeto60",
            "hp"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['timeto60', 'hp']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many heavy cars are in the dataset",
        "Relevant data columns": [
            "weightlbs"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'heavy' is ambiguous as it does not specify a weight threshold.",
        "Ambiguity resolution": "Define a specific weight threshold to classify cars as 'heavy'.",
        "Data transformations": "df[df['weightlbs'] > threshold].count()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Are there any American 5 cylinder cars",
        "Relevant data columns": [
            "cylinders",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[(df['cylinders'] == 5) & (df['country'].str.contains('US'))]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How does displacement relate to fuel economy for cars from Europe v USA",
        "Relevant data columns": [
            "cubicinches",
            "mpg",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "synonym",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate",
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify whether to consider all years or specific years, or how to handle cars from other countries not mentioned.",
        "Ambiguity resolution": "Filter data to include only cars from Europe and USA; consider all years available in the dataset.",
        "Data transformations": "df_filtered = df[df['country'].isin(['Europe.', 'US.'])][['cubicinches', 'mpg', 'country']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Which cylinder cars have the highest fuel economy",
        "Relevant data columns": [
            "cylinders",
            "mpg"
        ],
        "Data column classification": [
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if the highest fuel economy should be determined for each type of cylinder or overall.",
        "Ambiguity resolution": "Assume the query is asking for the highest fuel economy for each cylinder type.",
        "Data transformations": "df.groupby('cylinders')['mpg'].max()",
        "Data transformation operation": [
            "groupby",
            "max"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Which countries have the most cars in this dataset",
        "Relevant data columns": [
            "country"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['country'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Which countries have the highest acceleration for cars of different cylinders",
        "Relevant data columns": [
            "country",
            "timeto60",
            "cylinders"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum",
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear whether 'highest acceleration' refers to the shortest or longest time to 60 mph, as acceleration could be interpreted differently.",
        "Ambiguity resolution": "Assume 'highest acceleration' refers to the shortest time to 60 mph, indicating faster acceleration.",
        "Data transformations": "df.groupby(['cylinders', 'country'])['timeto60'].min().reset_index()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How do the horsepowers of the cars from different regions change with years",
        "Relevant data columns": [
            "hp",
            "year",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "exploratory",
        "Ambiguity in the query": "It is unclear if the query is asking for an average, median, or specific statistical measure of horsepower for each year and region.",
        "Ambiguity resolution": "Calculate average horsepower for each year and region to observe general trends.",
        "Data transformations": "df.groupby(['year', 'country'])['hp'].mean().reset_index()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "The distribution of the number of cylinders of cars based on different origins",
        "Relevant data columns": [
            "cylinders",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('country')['cylinders'].value_counts()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the correlation between displacement and MPG of cars with different origins",
        "Relevant data columns": [
            "cubicinches",
            "mpg",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['cubicinches', 'mpg', 'country']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "count the number of cars based on their origins",
        "Relevant data columns": [
            "country"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('country').size()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the correlation between horsepower and acceleration",
        "Relevant data columns": [
            "hp",
            "timeto60"
        ],
        "Data column classification": [
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "correlation = df[['hp', 'timeto60']].corr()",
        "Data transformation operation": [
            "select",
            "correlation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Is there a correlation between cars' horsepower and acceleration",
        "Relevant data columns": [
            "hp",
            "timeto60"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['hp', 'timeto60']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how does displacement relate to mpg for individual models, partitioned by country",
        "Relevant data columns": [
            "cubicinches",
            "mpg",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'individual models' is ambiguous as the dataset does not explicitly contain a 'model' column.",
        "Ambiguity resolution": "Assume 'individual models' refers to the unique combinations of 'cylinders', 'cubicinches', 'hp', 'weightlbs', 'timeto60', 'year' as a proxy for different car models.",
        "Data transformations": "df.groupby(['country', 'cylinders', 'cubicinches', 'hp', 'weightlbs', 'timeto60', 'year'])['mpg'].mean().reset_index()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how does weight relate to acceleration for car models, small multiples by origin",
        "Relevant data columns": [
            "weightlbs",
            "timeto60",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "synonym",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate",
            "cluster"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['country', 'weightlbs', 'timeto60']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how does horsepower relate to acceleration for individual car models",
        "Relevant data columns": [
            "hp",
            "timeto60"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query mentions 'individual car models' but the dataset does not contain a specific column for car models.",
        "Ambiguity resolution": "Assume the query refers to the dataset as it is, ignoring the specific model details since they are not available.",
        "Data transformations": "df[['hp', 'timeto60']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "car models"
    },
    {
        "query": "Compare the number of models in USA, Japan and Europe",
        "Relevant data columns": [
            "country"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for a comparison over time or just a total count of models from each country.",
        "Ambiguity resolution": "Assume the query is asking for a total count of models from each country without considering the time factor.",
        "Data transformations": "df['country'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Does higher horsepower mean lower acceleration",
        "Relevant data columns": [
            "hp",
            "timeto60"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['hp', 'timeto60']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many cylinders do cars manufactured in different countries have",
        "Relevant data columns": [
            "cylinders",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear whether the query is asking for a list of unique cylinder counts per country or a statistical summary (e.g., average, count) of cylinders per country.",
        "Ambiguity resolution": "Assuming the query asks for a statistical summary of cylinders per country, such as the average number of cylinders or the distribution of cylinder counts per country.",
        "Data transformations": "df.groupby('country')['cylinders'].describe()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Compare car cylinder count against acceleration across countries",
        "Relevant data columns": [
            "cylinders",
            "timeto60",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "synonym",
            "keyword"
        ],
        "Low-level visualization task": [
            "compare",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if the comparison should be aggregated by country or if individual data points should be compared.",
        "Ambiguity resolution": "Aggregate data by country to compare average cylinder count and average acceleration time.",
        "Data transformations": "df.groupby('country').agg({'cylinders': 'mean', 'timeto60': 'mean'})",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many cars do each country manufacture",
        "Relevant data columns": [
            "country"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query assumes the dataset represents manufacturing numbers, which may not be the case as it could simply represent samples of cars from different countries.",
        "Ambiguity resolution": "Clarify that the count of entries per country in the dataset is being used as a proxy for the number of cars manufactured, which may not reflect actual production numbers.",
        "Data transformations": "df.groupby('country').size()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What's the mileage for cars based on the number of cylinders present",
        "Relevant data columns": [
            "mpg",
            "cylinders"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('cylinders')['mpg'].mean()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Does higher cylinder count mean mean lower mileage",
        "Relevant data columns": [
            "cylinders",
            "mpg"
        ],
        "Data column classification": [
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query does not specify if the analysis should be done across all years or within specific years, or if it should consider the impact of other variables like weight or horsepower.",
        "Ambiguity resolution": "Assume the analysis is across all years and does not initially control for other variables. Further analysis could segment data by year or control for other factors if needed.",
        "Data transformations": "correlation_df = df[['cylinders', 'mpg']].corr()",
        "Data transformation operation": [
            "select",
            "correlation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How does mileage relate to cylinder count",
        "Relevant data columns": [
            "mpg",
            "cylinders"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['mpg', 'cylinders']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the average MPG for different cylinders",
        "Relevant data columns": [
            "mpg",
            "cylinders"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('cylinders')['mpg'].mean()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the relation between horsepower and acceleration",
        "Relevant data columns": [
            "hp",
            "timeto60"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['hp', 'timeto60']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how weight varies each year",
        "Relevant data columns": [
            "weightlbs",
            "year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for an average, total, or individual weights per year.",
        "Ambiguity resolution": "Assume the query is asking for average weight per year for simplicity and clarity.",
        "Data transformations": "df.groupby('year')['weightlbs'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how is acceleration related to horsepower",
        "Relevant data columns": [
            "timeto60",
            "hp"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['timeto60', 'hp']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How has horsepower changed over time by country",
        "Relevant data columns": [
            "hp",
            "year",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['country', 'year'])['hp'].mean().reset_index()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Have cars gotten lighter over time",
        "Relevant data columns": [
            "weightlbs",
            "year"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if the query is asking for a general trend or specific statistical measures (e.g., average weight per year).",
        "Ambiguity resolution": "Assume the query is asking for a general trend of average car weight over the years.",
        "Data transformations": "df.groupby('year')['weightlbs'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how many models are proudced by each country",
        "Relevant data columns": [
            "country"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'models' is ambiguous as it is unclear whether it refers to unique models or simply counts of entries per country.",
        "Ambiguity resolution": "Assume 'models' refers to the count of entries (cars) listed per country.",
        "Data transformations": "df.groupby('country').size()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the average weight of cars over time",
        "Relevant data columns": [
            "weightlbs",
            "year"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('year')['weightlbs'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the distribution of weight across all cars",
        "Relevant data columns": [
            "weightlbs"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['weightlbs']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How much do various cars weigh",
        "Relevant data columns": [
            "weightlbs"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify if the weight should be averaged, listed per car, or categorized in any specific way.",
        "Ambiguity resolution": "Assuming the need is to list weights for each car model or make, which is not specified in the dataset. Alternatively, could provide summary statistics (mean, median, etc.) for car weights.",
        "Data transformations": "df[['weightlbs']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the range of weights for all cars",
        "Relevant data columns": [
            "weightlbs"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "determine range"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['weightlbs'].agg(['min', 'max'])",
        "Data transformation operation": [
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "where do the cars originate from",
        "Relevant data columns": [
            "country"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['country']].drop_duplicates()",
        "Data transformation operation": [
            "select",
            "drop duplicates"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How has AVG (Horsepower) evolved over time | Segregate it by the car origin",
        "Relevant data columns": [
            "hp",
            "year",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend",
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['year', 'country'])['hp'].mean().reset_index()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Compare AVG (Acceleration) with Cylinders | Segregate the cylinders by their origin",
        "Relevant data columns": [
            "timeto60",
            "cylinders",
            "country"
        ],
        "Data column classification": [
            "synonym",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compare",
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear whether the comparison should be visualized or summarized in a table, and how the data should be grouped or segmented beyond the origin.",
        "Ambiguity resolution": "Group data by 'cylinders' and 'country', then calculate the average 'timeto60' for each group to facilitate comparison.",
        "Data transformations": "df.groupby(['cylinders', 'country'])['timeto60'].mean().reset_index()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How does AVG (Weight) evolve over the years",
        "Relevant data columns": [
            "weightlbs",
            "year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('year')['weightlbs'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How does the acceleration of cars from different countries vary by the number of cylinders",
        "Relevant data columns": [
            "timeto60",
            "country",
            "cylinders"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify if the comparison should be averaged, summarized by median, or just listed for each car. It also does not specify the method of comparison or visualization.",
        "Ambiguity resolution": "Group data by country and cylinders, then calculate average acceleration (time to 60) for each group to provide a clear comparison.",
        "Data transformations": "df.groupby(['country', 'cylinders'])['timeto60'].mean().reset_index()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How does acceleration vary by weight for cars from different regions",
        "Relevant data columns": [
            "timeto60",
            "weightlbs",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify if the analysis should be aggregated by regions or if it should include individual data points from each region.",
        "Ambiguity resolution": "Assuming the analysis should include individual data points from each region to observe the variance of acceleration with weight across different regions.",
        "Data transformations": "df[['timeto60', 'weightlbs', 'country']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the average MPG for cars with different cylinders",
        "Relevant data columns": [
            "mpg",
            "cylinders"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('cylinders')['mpg'].mean()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How does MPG vary by the number of cylinders in a car",
        "Relevant data columns": [
            "mpg",
            "cylinders"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('cylinders')['mpg'].mean()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How does acceleration change with horsepower",
        "Relevant data columns": [
            "timeto60",
            "hp"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['hp', 'timeto60']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How does acceleration behave compared to horsepower",
        "Relevant data columns": [
            "timeto60",
            "hp"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate",
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify if the relationship should be visualized across different years or countries, or if it should be aggregated.",
        "Ambiguity resolution": "Assume no aggregation by year or country unless specified; analyze the overall relationship between 'timeto60' and 'hp' for the entire dataset.",
        "Data transformations": "df[['hp', 'timeto60']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many cars are from each region",
        "Relevant data columns": [
            "country"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "summarize"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('country').size()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how does MPG compare to displacement, broken out by region",
        "Relevant data columns": [
            "mpg",
            "cubicinches",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "synonym",
            "keyword"
        ],
        "Low-level visualization task": [
            "compare",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'displacement' is used instead of a specific column name, which might cause confusion if not familiar with automotive terminology.",
        "Ambiguity resolution": "Clarify that 'displacement' refers to the 'cubicinches' column in the dataset.",
        "Data transformations": "df[['mpg', 'cubicinches', 'country']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "For each region, how does a car's MPG vary with displacement",
        "Relevant data columns": [
            "mpg",
            "cubicinches",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "synonym",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['country', 'cubicinches', 'mpg']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How has horsepower changed over time in each region",
        "Relevant data columns": [
            "hp",
            "year",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['year', 'country'])['hp'].mean().reset_index()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the breakdown of cars by the number of cylinders in each region",
        "Relevant data columns": [
            "cylinders",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['country', 'cylinders']).size().reset_index(name='count')",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "count",
        "Derivation Specification": "The 'count' column represents the number of cars in each category of 'cylinders' for each 'country'",
        "Missing Data Column": ""
    },
    {
        "query": "How many cars have various numbers of cylinders in each region",
        "Relevant data columns": [
            "cylinders",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['country', 'cylinders']).size().reset_index(name='count')",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "count",
        "Derivation Specification": "size() function used after groupby to count occurrences",
        "Missing Data Column": ""
    },
    {
        "query": "What is the average weight of cars by model year",
        "Relevant data columns": [
            "weightlbs",
            "year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('year')['weightlbs'].mean()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How has the average weight of cars changed over the years",
        "Relevant data columns": [
            "weightlbs",
            "year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend",
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('year')['weightlbs'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How much is the average of profit of each state",
        "Relevant data columns": [
            "Profit",
            "State"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('State')['Profit'].mean()",
        "Data transformation operation": [
            "groupby",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How do the company earn in each state",
        "Relevant data columns": [
            "Profit",
            "State"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('State')['Profit'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What were the total sales for each date in each category",
        "Relevant data columns": [
            "Sales",
            "Order Date",
            "Category"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Order Date', 'Category'])['Sales'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How much was sold each day for each category",
        "Relevant data columns": [
            "Order Date",
            "Category",
            "Sales"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Order Date', 'Category'])['Sales'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the average profit for each state",
        "Relevant data columns": [
            "Profit",
            "State"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('State')['Profit'].mean()",
        "Data transformation operation": [
            "groupby",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the relationship between profit and sales",
        "Relevant data columns": [
            "Profit",
            "Sales"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Profit', 'Sales']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the average profit of each ship mode divided by segment",
        "Relevant data columns": [
            "Profit",
            "Ship Mode",
            "Segment"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Ship Mode', 'Segment'])['Profit'].mean()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the sales forecast for each date",
        "Relevant data columns": [
            "Sales Forecast",
            "Order Date"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Order Date')['Sales Forecast'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many orders were placed for each order quantity",
        "Relevant data columns": [
            "Quantity"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Quantity')['Order ID'].count()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the relationship between sales and profit for each region",
        "Relevant data columns": [
            "Sales",
            "Profit",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Region', 'Sales', 'Profit']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the relationship between sales and profit for each region",
        "Relevant data columns": [
            "Sales",
            "Profit",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Region', 'Sales', 'Profit']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many orders were placed for each sub-category",
        "Relevant data columns": [
            "Sub-Category",
            "Order ID"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Sub-Category')['Order ID'].count()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the total profit for each region, based on ship status",
        "Relevant data columns": [
            "Profit",
            "Region",
            "Ship Status"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Region', 'Ship Status'])['Profit'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the sales trend of the different product categories",
        "Relevant data columns": [
            "Sales",
            "Category",
            "Order Date"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query does not specify the time frame for the sales trend analysis.",
        "Ambiguity resolution": "Assume the analysis is over the available data range unless specified otherwise.",
        "Data transformations": "df.groupby(['Order Date', 'Category'])['Sales'].sum().reset_index()",
        "Data transformation operation": [
            "groupby",
            "sum",
            "reset_index"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many products have 3 or more quantity ordered",
        "Relevant data columns": [
            "Product Name",
            "Quantity"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "summarize"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Quantity'] >= 3]['Product Name'].nunique()",
        "Data transformation operation": [
            "filter",
            "select",
            "count unique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many products are ordered in single quantity",
        "Relevant data columns": [
            "Product Name",
            "Quantity"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Quantity'] == 1]['Product Name'].count()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Density of sales across regions and their profitability",
        "Relevant data columns": [
            "Sales",
            "Profit",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'density' is ambiguous as it could refer to the distribution of sales values, the concentration of sales events, or a statistical density estimation.",
        "Ambiguity resolution": "Assume 'density' refers to the distribution of sales values and their corresponding profitability across different regions.",
        "Data transformations": "df.groupby('Region').agg({'Sales': 'sum', 'Profit': 'sum'})",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What are the profits across different states",
        "Relevant data columns": [
            "Profit",
            "State"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('State')['Profit'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What product category has more orders placed",
        "Relevant data columns": [
            "Category",
            "Quantity"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Category')['Quantity'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "sales forecast between Jan 2016 and July 2017",
        "Relevant data columns": [
            "Sales Forecast",
            "Order Date"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify whether the sales forecast should be aggregated or listed individually for each order, or if any specific grouping (e.g., by month, category) is required.",
        "Ambiguity resolution": "Assuming the need is to aggregate the sales forecast by month for the specified date range.",
        "Data transformations": "df['Order Date'] = pd.to_datetime(df['Order Date']); filtered_df = df[(df['Order Date'] >= '2016-01-01') & (df['Order Date'] <= '2017-07-31')]; result = filtered_df.groupby(filtered_df['Order Date'].dt.to_period('M'))['Sales Forecast'].sum()",
        "Data transformation operation": [
            "convert to datetime",
            "filter",
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "I want to know how many orders there are by the quantity of the order",
        "Relevant data columns": [
            "Order ID",
            "Quantity"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Quantity')['Order ID'].count()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is our profit based on shipping mode by customer segment",
        "Relevant data columns": [
            "Profit",
            "Ship Mode",
            "Segment"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Ship Mode', 'Segment'])['Profit'].sum().reset_index()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the sales vs profit ratio of the four regions",
        "Relevant data columns": [
            "Sales",
            "Profit",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Region').agg({'Sales': 'sum', 'Profit': 'sum'}).assign(Sales_Profit_Ratio=lambda x: x['Profit'] / x['Sales'])",
        "Data transformation operation": [
            "groupby",
            "summarize",
            "calculate new column"
        ],
        "New Column Name": "Sales_Profit_Ratio",
        "Derivation Specification": "Sales_Profit_Ratio = Profit / Sales",
        "Missing Data Column": ""
    },
    {
        "query": "What is the average profit of each state",
        "Relevant data columns": [
            "Profit",
            "State"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('State')['Profit'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the sales vs profit ratio of all the zones",
        "Relevant data columns": [
            "Sales",
            "Profit",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Region').apply(lambda x: x['Profit'].sum() / x['Sales'].sum())",
        "Data transformation operation": [
            "groupby",
            "apply"
        ],
        "New Column Name": "Sales vs Profit Ratio",
        "Derivation Specification": "df['Sales vs Profit Ratio'] = df.groupby('Region').apply(lambda x: x['Profit'].sum() / x['Sales'].sum())",
        "Missing Data Column": ""
    },
    {
        "query": "What is the average profit of different segments on the ship modes of transport",
        "Relevant data columns": [
            "Profit",
            "Segment",
            "Ship Mode"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby(['Segment', 'Ship Mode'])['Profit'].mean()",
        "Data transformation operation": [
            "groupby",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how much is the profit for sales for each",
        "Relevant data columns": [
            "Profit",
            "Sales"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the grouping criteria for calculating profit for sales.",
        "Ambiguity resolution": "Assume the profit needs to be aggregated for each product or category, as these are common business analysis groupings.",
        "Data transformations": "df.groupby('Product Name')[['Sales', 'Profit']].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the correlation between sales and profit by region",
        "Relevant data columns": [
            "Sales",
            "Profit",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Region')[['Sales', 'Profit']].corr().loc[(slice(None), 'Sales'), 'Profit']",
        "Data transformation operation": [
            "groupby",
            "correlation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Can you create a graph showing sales and profit by region",
        "Relevant data columns": [
            "Sales",
            "Profit",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Region')[['Sales', 'Profit']].sum()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What months are hurricanes most common",
        "Relevant data columns": [
            "month",
            "status"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'hurricanes' needs to be clearly defined in terms of the 'status' or 'category' column values.",
        "Ambiguity resolution": "Assume 'hurricanes' refer to entries where 'status' includes 'hurricane' or 'category' is greater than 0.",
        "Data transformations": "df_hurricanes = df[(df['status'].str.contains('hurricane')) | (df['category'] > 0)]; hurricane_months = df_hurricanes['month'].value_counts()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Where are storms most common depending on the time of year",
        "Relevant data columns": [
            "status",
            "month",
            "lat",
            "long"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what defines 'most common'\u2014whether it's the number of storms or the intensity of storms.",
        "Ambiguity resolution": "Assume 'most common' refers to the frequency of storms. Aggregate data by month and count occurrences.",
        "Data transformations": "df[df['status'].str.contains('storm')].groupby(['month', 'lat', 'long']).size().reset_index(name='count')",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count"
        ],
        "New Column Name": "count",
        "Derivation Specification": "size() after groupby to count occurrences",
        "Missing Data Column": ""
    },
    {
        "query": "Are there more storms in recent years",
        "Relevant data columns": [
            "year"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "trend",
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what constitutes 'recent years', nor does it specify the criteria for counting storms (e.g., by name, by any entry).",
        "Ambiguity resolution": "Assume 'recent years' to mean the last decade available in the dataset. Count storms by unique names per year.",
        "Data transformations": "df['recent_years'] = df['year'] >= df['year'].max() - 10; recent_storms = df[df['recent_years']].groupby('year')['name'].nunique()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count"
        ],
        "New Column Name": "recent_years",
        "Derivation Specification": "df['recent_years'] = df['year'] >= df['year'].max() - 10",
        "Missing Data Column": ""
    },
    {
        "query": "What does the distribution of the storms look like",
        "Relevant data columns": [
            "status"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear if the distribution should be visualized over time, by category, or by another variable such as location.",
        "Ambiguity resolution": "Assume distribution by status as it directly relates to the type of storm, which is a common method to analyze storm data.",
        "Data transformations": "df['status'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the most frequent status over the year",
        "Relevant data columns": [
            "status",
            "year"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('status').size().idxmax()",
        "Data transformation operation": [
            "groupby",
            "count",
            "retrieve maximum index"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the main factor depending on different status (wind, time, pressure, or etc)",
        "Relevant data columns": [
            "status",
            "wind",
            "year",
            "month",
            "day",
            "hour",
            "pressure"
        ],
        "Data column classification": [
            "keyword",
            "data value mention",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "data value mention"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query is ambiguous as it does not specify which factors to compare against the status or how to measure 'main factor'.",
        "Ambiguity resolution": "Assume the need to explore correlations between status and other numerical variables like wind and pressure. Time could be combined into a single datetime column for analysis.",
        "Data transformations": "df['datetime'] = pd.to_datetime(df[['year', 'month', 'day', 'hour']]); df[['status', 'wind', 'pressure', 'datetime']]",
        "Data transformation operation": [
            "create new column",
            "select"
        ],
        "New Column Name": "datetime",
        "Derivation Specification": "df['datetime'] = pd.to_datetime(df[['year', 'month', 'day', 'hour']])",
        "Missing Data Column": ""
    },
    {
        "query": "What was the name of the earliest storm",
        "Relevant data columns": [
            "name",
            "year",
            "month",
            "day",
            "hour"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.sort_values(by=['year', 'month', 'day', 'hour']).iloc[0]['name']",
        "Data transformation operation": [
            "sort",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many hurricanes",
        "Relevant data columns": [
            "status"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify the time frame or geographical area for counting hurricanes.",
        "Ambiguity resolution": "Assume the count is for the entire dataset unless specified otherwise.",
        "Data transformations": "df[df['status'].str.contains('hurricane')].shape[0]",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the name of the largest storm",
        "Relevant data columns": [
            "name",
            "ts_diameter",
            "hu_diameter"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear whether 'largest' refers to the tropical storm diameter or hurricane diameter, or if it considers both.",
        "Ambiguity resolution": "Assume 'largest' refers to the maximum value of either tropical storm diameter or hurricane diameter. Calculate the maximum of these columns and determine the corresponding storm name.",
        "Data transformations": "df['max_diameter'] = df[['ts_diameter', 'hu_diameter']].max(axis=1); largest_storm = df.loc[df['max_diameter'].idxmax()]['name']",
        "Data transformation operation": [
            "create new column",
            "calculate maximum",
            "filter"
        ],
        "New Column Name": "max_diameter",
        "Derivation Specification": "df['max_diameter'] = df[['ts_diameter', 'hu_diameter']].max(axis=1)",
        "Missing Data Column": ""
    },
    {
        "query": "What storm produced the greatest air pressure",
        "Relevant data columns": [
            "name",
            "pressure"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear whether the query is asking for the highest or lowest air pressure value, as 'greatest' could imply either maximum or minimum.",
        "Ambiguity resolution": "Assume 'greatest' refers to the highest air pressure value.",
        "Data transformations": "df.loc[df['pressure'].idxmax(), ['name', 'pressure']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many storms are named Caroline",
        "Relevant data columns": [
            "name"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['name'] == 'Caroline'].shape[0]",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What storm produced the least air pressure",
        "Relevant data columns": [
            "name",
            "pressure"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "result = df.loc[df['pressure'].idxmin(), ['name', 'pressure']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What storm had the greatest diameter of tropical storm strength winds",
        "Relevant data columns": [
            "name",
            "ts_diameter",
            "status"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query does not specify if it refers to the maximum diameter recorded for a single instance or the maximum average diameter across all instances of tropical storms for each storm.",
        "Ambiguity resolution": "Assume the query is asking for the maximum diameter recorded for a single instance of tropical storm strength for simplicity.",
        "Data transformations": "df[df['status'].str.contains('tropical storm')].nlargest(1, 'ts_diameter')[['name', 'ts_diameter']]",
        "Data transformation operation": [
            "filter",
            "select",
            "find maximum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What storm had the greatest diameter of hurricane strength winds",
        "Relevant data columns": [
            "name",
            "hu_diameter"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if the query is asking for the maximum diameter recorded for a single storm or the maximum diameter across all storms.",
        "Ambiguity resolution": "Assume the query is asking for the maximum diameter recorded for each storm and then identify which storm had the overall maximum.",
        "Data transformations": "df.groupby('name')['hu_diameter'].max().idxmax()",
        "Data transformation operation": [
            "groupby",
            "max",
            "idxmax"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many storms occur per year, on average",
        "Relevant data columns": [
            "year",
            "status"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if 'storms' refers to all statuses considered as storms or only specific statuses like 'tropical storm'.",
        "Ambiguity resolution": "Assume 'storms' refers to statuses that include the word 'storm'.",
        "Data transformations": "df[df['status'].str.contains('storm')].groupby('year').size().mean()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "On average, what is the first date that a tropical cyclone (tropical depression, tropical storm, or hurricane) forms on every year",
        "Relevant data columns": [
            "year",
            "month",
            "day",
            "status"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify whether to consider all statuses equally or prioritize them based on severity.",
        "Ambiguity resolution": "Assume all statuses mentioned are equally important for determining the first date of formation.",
        "Data transformations": "df_filtered = df[df['status'].isin(['tropical depression', 'tropical storm', 'hurricane'])]; df_grouped = df_filtered.groupby('year').agg({'month': 'min', 'day': 'min'}); df_grouped['date'] = pd.to_datetime(df_grouped[['year', 'month', 'day']]); df_result = df_grouped.groupby('year')['date'].min()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "aggregate",
            "datetime conversion"
        ],
        "New Column Name": "date",
        "Derivation Specification": "df_grouped['date'] = pd.to_datetime(df_grouped[['year', 'month', 'day']])",
        "Missing Data Column": ""
    },
    {
        "query": "Is there a correlation between wind speed and air pressure",
        "Relevant data columns": [
            "wind",
            "pressure"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['wind', 'pressure']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Is there a correlation between the duration of the storm and wind speed",
        "Relevant data columns": [
            "wind",
            "year",
            "month",
            "day",
            "hour"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify how to calculate the duration of the storm, which is necessary to determine the correlation with wind speed.",
        "Ambiguity resolution": "Assume duration is calculated from the difference between the start and end times of the storm's data entries.",
        "Data transformations": "df['datetime'] = pd.to_datetime(df[['year', 'month', 'day', 'hour']]); df['duration'] = df.groupby('name')['datetime'].transform(lambda x: x.max() - x.min()); df[['duration', 'wind']]",
        "Data transformation operation": [
            "create datetime",
            "calculate duration",
            "select"
        ],
        "New Column Name": "duration",
        "Derivation Specification": "df['datetime'] = pd.to_datetime(df[['year', 'month', 'day', 'hour']]); df['duration'] = df.groupby('name')['datetime'].transform(lambda x: x.max() - x.min())",
        "Missing Data Column": ""
    },
    {
        "query": "Where have all hurricanes been recorded on the globe Where are they more common",
        "Relevant data columns": [
            "lat",
            "long",
            "status"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the time frame or the intensity of hurricanes to be considered.",
        "Ambiguity resolution": "Assume all data points with 'hurricane' status across all years are considered. Further, analyze the commonality based on the density of occurrences in different geographic locations.",
        "Data transformations": "hurricane_df = df[df['status'].str.contains('hurricane')]; common_areas = hurricane_df.groupby(['lat', 'long']).size().reset_index(name='counts')",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count"
        ],
        "New Column Name": "counts",
        "Derivation Specification": "hurricane_df.groupby(['lat', 'long']).size().reset_index(name='counts')",
        "Missing Data Column": ""
    },
    {
        "query": "What lat/long locations are most likely to experience hurricanes",
        "Relevant data columns": [
            "lat",
            "long",
            "status"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the criteria for 'most likely' or a specific time frame or category of hurricanes.",
        "Ambiguity resolution": "Assume 'most likely' refers to the highest frequency of hurricane status entries. Filter data for hurricane status and then aggregate by latitude and longitude.",
        "Data transformations": "hurricane_data = df[df['status'].str.contains('hurricane')]; location_counts = hurricane_data.groupby(['lat', 'long']).size().reset_index(name='count').sort_values(by='count', ascending=False)",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What are lengths/timings of hurricane seasons in different regions of the world",
        "Relevant data columns": [
            "month",
            "lat",
            "long"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what constitutes the start and end of a hurricane season, nor does it define 'regions of the world' specifically.",
        "Ambiguity resolution": "Assume hurricane season starts with the first recorded storm in a region and ends with the last. Define regions based on latitude and longitude ranges or predefined areas.",
        "Data transformations": "df['region'] = pd.cut(df['lat'], bins=[-90, -60, -30, 0, 30, 60, 90], labels=['Far South', 'South', 'Tropical South', 'Tropical North', 'North', 'Far North']); season_start = df.groupby('region')['month'].min(); season_end = df.groupby('region')['month'].max(); season_length = season_end - season_start",
        "Data transformation operation": [
            "groupby",
            "min",
            "max",
            "arithmetic operation"
        ],
        "New Column Name": "region",
        "Derivation Specification": "df['region'] = pd.cut(df['lat'], bins=[-90, -60, -30, 0, 30, 60, 90], labels=['Far South', 'South', 'Tropical South', 'Tropical North', 'North', 'Far North'])",
        "Missing Data Column": ""
    },
    {
        "query": "What is the average storm length",
        "Relevant data columns": [
            "name",
            "year",
            "month",
            "day",
            "hour"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear how 'storm length' is defined. Does it refer to the duration in hours, the number of entries, or the spatial distance covered?",
        "Ambiguity resolution": "Assume 'storm length' refers to the duration in hours from the first to the last record of each storm.",
        "Data transformations": "df.groupby(['name', 'year']).apply(lambda x: (x['day'].max() - x['day'].min()) * 24 + (x['hour'].max() - x['hour'].min())).mean()",
        "Data transformation operation": [
            "groupby",
            "apply",
            "max",
            "min",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the average time that it takes to go from depression to storm",
        "Relevant data columns": [
            "status",
            "hour"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the time should be calculated for each individual storm or averaged across multiple storms, and how to handle cases where a storm does not progress from depression to storm within the dataset.",
        "Ambiguity resolution": "Assume the calculation is for each storm individually where applicable, and average those durations. Exclude cases where a storm does not progress within the available data.",
        "Data transformations": "df['time'] = df.groupby('name').apply(lambda x: x[x['status']=='tropical storm']['hour'].min() - x[x['status']=='tropical depression']['hour'].min()); avg_time = df.dropna(subset=['time'])['time'].mean()",
        "Data transformation operation": [
            "groupby",
            "apply",
            "min",
            "mean"
        ],
        "New Column Name": "time",
        "Derivation Specification": "df['time'] = df.groupby('name').apply(lambda x: x[x['status']=='tropical storm']['hour'].min() - x[x['status']=='tropical depression']['hour'].min())",
        "Missing Data Column": ""
    },
    {
        "query": "What is the relationship, if any, between wind and pressure",
        "Relevant data columns": [
            "wind",
            "pressure"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['wind', 'pressure']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How does wind change over the course of each hurricane",
        "Relevant data columns": [
            "wind",
            "name",
            "year",
            "month",
            "day",
            "hour"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify if the wind change should be visualized for each hurricane separately or all hurricanes together, nor does it specify the time granularity (e.g., hourly, daily).",
        "Ambiguity resolution": "Assume the wind change should be visualized for each hurricane separately on a daily basis, aggregating hourly data.",
        "Data transformations": "df['date'] = pd.to_datetime(df[['year', 'month', 'day']]); df_grouped = df.groupby(['name', 'date'])['wind'].mean().reset_index()",
        "Data transformation operation": [
            "create new column",
            "groupby",
            "aggregate"
        ],
        "New Column Name": "date",
        "Derivation Specification": "df['date'] = pd.to_datetime(df[['year', 'month', 'day']])",
        "Missing Data Column": ""
    },
    {
        "query": "Average tropical storm diameter",
        "Relevant data columns": [
            "status",
            "ts_diameter"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The dataset contains NaN values for 'ts_diameter', which needs handling before computing the average.",
        "Ambiguity resolution": "Exclude NaN values from the 'ts_diameter' column before computing the average.",
        "Data transformations": "df[df['status'] == 'tropical storm']['ts_diameter'].dropna().mean()",
        "Data transformation operation": [
            "filter",
            "select",
            "drop NaN",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the relationship between storm day and hu_diameter",
        "Relevant data columns": [
            "day",
            "hu_diameter"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify if the relationship should be analyzed for a specific storm or across all storms, nor does it address handling of missing data in 'hu_diameter'.",
        "Ambiguity resolution": "Assume the analysis is for all available data, and handle missing values by excluding them from the analysis.",
        "Data transformations": "df.dropna(subset=['hu_diameter'])[['day', 'hu_diameter']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Are there any repeat names of storms",
        "Relevant data columns": [
            "name"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify over what time range or geographical area the duplicates should be identified.",
        "Ambiguity resolution": "Assume duplicates are to be identified across the entire dataset provided.",
        "Data transformations": "df[df.duplicated(subset=['name'], keep=False)][['name']]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What month has the strongest hurricanes",
        "Relevant data columns": [
            "month",
            "wind",
            "status"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query does not specify what defines a 'strongest hurricane', whether it's based on wind speed alone or includes other factors like pressure.",
        "Ambiguity resolution": "Assume 'strongest' refers to the highest wind speeds recorded for hurricanes.",
        "Data transformations": "df[df['status'].str.contains('hurricane')].groupby('month')['wind'].max()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "max"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How has wind speed changed over time",
        "Relevant data columns": [
            "wind",
            "year",
            "month",
            "day",
            "hour"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query does not specify over what time scale or for which storm the wind speed change should be analyzed.",
        "Ambiguity resolution": "Assume the query refers to the wind speed changes over the entire dataset for the storm named 'Amy'.",
        "Data transformations": "df['datetime'] = pd.to_datetime(df[['year', 'month', 'day', 'hour']]); df_sorted = df.sort_values(by='datetime'); df_sorted[['datetime', 'wind']]",
        "Data transformation operation": [
            "create datetime",
            "sort",
            "select"
        ],
        "New Column Name": "datetime",
        "Derivation Specification": "df['datetime'] = pd.to_datetime(df[['year', 'month', 'day', 'hour']])",
        "Missing Data Column": ""
    },
    {
        "query": "What is the maximum pressure of a certain hurricane",
        "Relevant data columns": [
            "pressure",
            "name"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query does not specify which hurricane's maximum pressure is needed.",
        "Ambiguity resolution": "Assume a specific hurricane or provide a method to select a hurricane.",
        "Data transformations": "df[df['name'] == 'HurricaneName']['pressure'].max()",
        "Data transformation operation": [
            "filter",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "HurricaneName"
    },
    {
        "query": "Relationship between position and the strength of the hurricane",
        "Relevant data columns": [
            "lat",
            "long",
            "wind"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear if the relationship should be visualized or quantified, and whether it should consider other factors like time or just spatial coordinates and wind strength.",
        "Ambiguity resolution": "Assume a basic correlation analysis between latitude, longitude, and wind strength. Additional analysis could consider time as a factor if needed.",
        "Data transformations": "df[['lat', 'long', 'wind']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Average time for each hurricane status",
        "Relevant data columns": [
            "status",
            "hour"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear whether 'average time' refers to the average of the 'hour' field or the duration each status typically lasts.",
        "Ambiguity resolution": "Assume 'average time' refers to the average of the 'hour' field for each status. If duration is needed, further clarification from the user would be required.",
        "Data transformations": "df.groupby('status')['hour'].mean()",
        "Data transformation operation": [
            "groupby",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Which hurricane lasted the longest",
        "Relevant data columns": [
            "name",
            "year",
            "month",
            "day",
            "hour"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the duration should be calculated within a single year or across multiple years if the hurricane spans more than one year.",
        "Ambiguity resolution": "Assume the duration is calculated within a single year as hurricanes typically do not span multiple years.",
        "Data transformations": "df['datetime'] = pd.to_datetime(df[['year', 'month', 'day', 'hour']]); hurricane_duration = df.groupby('name')['datetime'].agg([min, max]); hurricane_duration['duration'] = hurricane_duration['max'] - hurricane_duration['min']; longest_hurricane = hurricane_duration['duration'].idxmax()",
        "Data transformation operation": [
            "datetime conversion",
            "groupby",
            "min/max calculation",
            "duration calculation",
            "find maximum"
        ],
        "New Column Name": "duration",
        "Derivation Specification": "hurricane_duration['duration'] = hurricane_duration['max'] - hurricane_duration['min']",
        "Missing Data Column": ""
    },
    {
        "query": "show me a list of neighborhoods with the number of male births from least to most",
        "Relevant data columns": [
            "Neighborhood Name",
            "Number",
            "Gender"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Gender'] == 'Boys'][['Neighborhood Name', 'Number']].sort_values(by='Number')",
        "Data transformation operation": [
            "filter",
            "select",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me the distribution of births across all districts in 2017",
        "Relevant data columns": [
            "Year",
            "District Name",
            "Number"
        ],
        "Data column classification": [
            "data value",
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df = df[df['Year'] == 2017].groupby('District Name')['Number'].sum().reset_index()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "let me know if there are groups of neighborhoods with similar birth gender ratios",
        "Relevant data columns": [
            "Neighborhood Name",
            "Gender",
            "Number"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "cluster",
            "similarity"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the method for determining similarity in birth gender ratios or how to group neighborhoods.",
        "Ambiguity resolution": "Calculate the ratio of births by gender for each neighborhood and use clustering techniques to group neighborhoods with similar ratios.",
        "Data transformations": "df['Gender Ratio'] = df.groupby(['Neighborhood Name', 'Gender'])['Number'].transform('sum') / df.groupby('Neighborhood Name')['Number'].transform('sum'); df = df.drop_duplicates(subset=['Neighborhood Name']);",
        "Data transformation operation": [
            "groupby",
            "sum",
            "division",
            "drop duplicates"
        ],
        "New Column Name": "Gender Ratio",
        "Derivation Specification": "df['Gender Ratio'] = df.groupby(['Neighborhood Name', 'Gender'])['Number'].transform('sum') / df.groupby('Neighborhood Name')['Number'].transform('sum')",
        "Missing Data Column": ""
    },
    {
        "query": "retrieve the neighborhood with more than 100 female births in ciutat vella in 2013",
        "Relevant data columns": [
            "Neighborhood Name",
            "Number",
            "District Name",
            "Year",
            "Gender"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "data value mention",
            "data value mention",
            "data value mention"
        ],
        "Low-level visualization task": [
            "filter",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The dataset provided does not contain data for the year 2013, only for 2017.",
        "Ambiguity resolution": "Assuming the dataset contains data for 2013, proceed with the specified filters. If not, inform the user about the data availability.",
        "Data transformations": "df[(df['District Name'] == 'Ciutat Vella') & (df['Year'] == 2013) & (df['Gender'] == 'Female') & (df['Number'] > 100)][['Neighborhood Name', 'Number']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which neighborhood in ciutat vella has more than 100 females born in the year 2013",
        "Relevant data columns": [
            "Neighborhood Name",
            "District Name",
            "Gender",
            "Number",
            "Year"
        ],
        "Data column classification": [
            "inferred",
            "data value mention",
            "keyword",
            "inferred",
            "data value"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset provided does not contain data for the year 2013, only for 2017.",
        "Ambiguity resolution": "Assuming the dataset contains data for 2013, apply the necessary filters. If not, the query cannot be resolved with the current dataset.",
        "Data transformations": "df[(df['District Name'] == 'Ciutat Vella') & (df['Gender'] == 'Females') & (df['Year'] == 2013) & (df['Number'] > 100)][['Neighborhood Name']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Barcelona's districts, please list each",
        "Relevant data columns": [
            "District Name"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['District Name'].unique()",
        "Data transformation operation": [
            "select",
            "unique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the distribution of all births in all districts between 2013 and 2017",
        "Relevant data columns": [
            "Year",
            "District Name",
            "Number"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "synonym"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset only contains data for the year 2017, but the query asks for data from 2013 to 2017.",
        "Ambiguity resolution": "Clarify that only data for 2017 is available and adjust the query accordingly or obtain data for the missing years.",
        "Data transformations": "df = df[df['Year'] == 2017].groupby('District Name')['Number'].sum().reset_index()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what neighborhood had 56 boys born in 2017",
        "Relevant data columns": [
            "Neighborhood Name",
            "Number",
            "Gender",
            "Year"
        ],
        "Data column classification": [
            "inferred",
            "data value",
            "keyword",
            "data value"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[(df['Number'] == 56) & (df['Gender'] == 'Boys') & (df['Year'] == 2017)][['Neighborhood Name']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the total number of categories",
        "Relevant data columns": [
            "Category"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Category'].nunique()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me the total number of categories",
        "Relevant data columns": [
            "Category"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Category'].nunique()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what 's the size of \" kids paint free - drawing fun \"",
        "Relevant data columns": [
            "App",
            "Size"
        ],
        "Data column classification": [
            "data value mention",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The app 'kids paint free - drawing fun' is not listed in the provided dataset sample.",
        "Ambiguity resolution": "Check the complete dataset for the presence of the app 'kids paint free - drawing fun' or suggest similar apps if the exact match is not found.",
        "Data transformations": "df[df['App'].str.contains('kids paint free - drawing fun', case=False, na=False)][['App', 'Size']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "App"
    },
    {
        "query": "does an app exist that is much different than the others",
        "Relevant data columns": [
            "App",
            "Category",
            "Rating",
            "Reviews",
            "Size",
            "Installs",
            "Type",
            "Price",
            "Content Rating",
            "Genres",
            "Last Updated",
            "Current Ver",
            "Android Ver"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query is ambiguous as it does not specify the criteria for 'much different'. It could refer to any attribute such as category, rating, size, installs, type, price, content rating, genres, last updated, current version, or Android version.",
        "Ambiguity resolution": "Define specific criteria or metrics to measure 'difference' such as statistical outliers in numerical data (e.g., Rating, Reviews) or unique entries in categorical data (e.g., Category, Type).",
        "Data transformations": "df.describe(include='all'); df.nunique(); df[df['Rating'] == df['Rating'].max()]; df[df['Reviews'] == df['Reviews'].max()]; df[df['Installs'] == df['Installs'].max()]; df[df['Price'] == df['Price'].max()]",
        "Data transformation operation": [
            "summary statistics",
            "unique count",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the total amount of genres",
        "Relevant data columns": [
            "Genres"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear whether the query is asking for the total number of unique genres or the total number of genre entries including duplicates.",
        "Ambiguity resolution": "Assuming the query is asking for the total number of unique genres.",
        "Data transformations": "df['Genres'].nunique()",
        "Data transformation operation": [
            "nunique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the title of the biggest app",
        "Relevant data columns": [
            "App",
            "Size"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'biggest' could refer to the file size of the app or the number of installs. Additionally, the 'Size' column contains values with different units (M for megabytes, k for kilobytes), which need to be standardized for comparison.",
        "Ambiguity resolution": "Assume 'biggest' refers to file size. Convert all sizes to a uniform unit (megabytes) for comparison.",
        "Data transformations": "df['Size'] = df['Size'].replace('M', '', regex=True).replace('k', '', regex=True).astype(float); df['Size'] = df['Size'].apply(lambda x: x if x > 1 else x/1000); df.loc[df['Size'].idxmax(), 'App']",
        "Data transformation operation": [
            "replace",
            "astype",
            "apply",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what apps have a perfect rating and a lot of reviews",
        "Relevant data columns": [
            "Rating",
            "Reviews"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'a lot of reviews' is ambiguous as it does not specify a numeric threshold for what constitutes 'a lot'.",
        "Ambiguity resolution": "Define a specific threshold for 'a lot of reviews', such as reviews greater than a certain percentile or a specific number.",
        "Data transformations": "df[df['Rating'] == 5.0].sort_values(by='Reviews', ascending=False)",
        "Data transformation operation": [
            "filter",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "see if you can locate the most recent gaming app",
        "Relevant data columns": [
            "Last Updated",
            "Category"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify the criteria for 'most recent'\u2014whether it refers to the date of the last update or the release version.",
        "Ambiguity resolution": "Assume 'most recent' refers to the latest date in the 'Last Updated' column for apps in the 'GAME' category.",
        "Data transformations": "df[df['Category'] == 'GAME'].sort_values(by='Last Updated', ascending=False).head(1)",
        "Data transformation operation": [
            "filter",
            "sort",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me free or paid apps have a higher mean rating",
        "Relevant data columns": [
            "Type",
            "Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compare",
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Type')['Rating'].mean()",
        "Data transformation operation": [
            "groupby",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which genres are included in the dataset",
        "Relevant data columns": [
            "Genres"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Genres'].unique()",
        "Data transformation operation": [
            "select",
            "unique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which apps have support for versions of android lower than 40",
        "Relevant data columns": [
            "App",
            "Android Ver"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Android Ver'].apply(lambda x: x.split(' ')[0] if isinstance(x, str) else '999') < '4.0'][['App', 'Android Ver']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "describe shape of the distribution for the number of installations",
        "Relevant data columns": [
            "Installs"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The 'Installs' column contains values with '+' and commas, which need to be cleaned for proper numerical analysis.",
        "Ambiguity resolution": "Remove '+' and commas from the 'Installs' column and convert it to numeric for analysis.",
        "Data transformations": "df['Installs'] = df['Installs'].str.replace('+', '').str.replace(',', '').astype(int)",
        "Data transformation operation": [
            "replace",
            "type conversion"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me the app that costs the most",
        "Relevant data columns": [
            "App",
            "Price"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify if it refers to the absolute highest price or relative to its category.",
        "Ambiguity resolution": "Assume the query refers to the absolute highest price across all categories.",
        "Data transformations": "df['Price'] = df['Price'].replace('[\textbackslash\textdollar]', '', regex=True).astype(float); max_price_app = df[df['Price'] == df['Price'].max()][['App', 'Price']]",
        "Data transformation operation": [
            "replace",
            "astype",
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is there a relationship between the android version of an app and its installations",
        "Relevant data columns": [
            "Android Ver",
            "Installs"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify how to handle apps with 'Varies with device' as their Android version.",
        "Ambiguity resolution": "Exclude apps with 'Varies with device' from the analysis or treat them as a separate category.",
        "Data transformations": "df = df[df['Android Ver'] != 'Varies with device'][['Android Ver', 'Installs']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me the most recent version of androids 'discover color'",
        "Relevant data columns": [
            "App",
            "Android Ver"
        ],
        "Data column classification": [
            "data value mention",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The app name 'discover color' does not appear in the dataset, and it is unclear if it is a typo or a different name is used in the dataset.",
        "Ambiguity resolution": "Check for similar app names or typos in the dataset that could match 'discover color'.",
        "Data transformations": "df[df['App'].str.contains('discover color', case=False, na=False)][['App', 'Android Ver']].sort_values(by='Last Updated', ascending=False).head(1)",
        "Data transformation operation": [
            "filter",
            "select",
            "sort",
            "retrieve top record"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "discover color"
    },
    {
        "query": "when taking different android versions into account, does that have any impact on installation",
        "Relevant data columns": [
            "Android Ver",
            "Installs"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify how to measure the impact on installations, whether it's by the number of installs, growth rate, or another metric.",
        "Ambiguity resolution": "Assume the impact is to be measured by the total number of installations per Android version.",
        "Data transformations": "df.groupby('Android Ver')['Installs'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "give me a list of all the free business apps that have received rating that were higher than a 45",
        "Relevant data columns": [
            "App",
            "Category",
            "Rating",
            "Type"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[(df['Category'] == 'BUSINESS') & (df['Type'] == 'Free') & (df['Rating'] > 4.5)][['App', 'Category', 'Rating', 'Type']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me the attribute 'rating' be affected 'installation'",
        "Relevant data columns": [
            "Rating",
            "Installs"
        ],
        "Data column classification": [
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query is ambiguous as it does not specify how 'rating' is affected by 'installation' - positively, negatively, or if there is any correlation at all.",
        "Ambiguity resolution": "Assume the user is interested in finding if there is any correlation between 'Rating' and 'Installs'.",
        "Data transformations": "df['Installs'] = df['Installs'].str.replace('+','').str.replace(',','').astype(int); df[['Rating', 'Installs']]",
        "Data transformation operation": [
            "transform",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what's the price distribution in beauty apps",
        "Relevant data columns": [
            "Price",
            "Category"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Category'] == 'BEAUTY']['Price']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which app has a rating that doesn't follow a trend between installations, rating and number of reviews",
        "Relevant data columns": [
            "App",
            "Rating",
            "Installs",
            "Reviews"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query is ambiguous because it does not specify what constitutes a 'trend' or how to measure deviation from this trend.",
        "Ambiguity resolution": "Assume a linear relationship between installations, rating, and number of reviews. Calculate residuals from a linear regression model to identify outliers.",
        "Data transformations": "df['Installs'] = df['Installs'].str.replace('+','').str.replace(',','').astype(int); df['Reviews'] = df['Reviews'].astype(int); import statsmodels.api as sm; X = df[['Installs', 'Reviews']]; X = sm.add_constant(X); model = sm.OLS(df['Rating'], X, missing='drop').fit(); df['Residuals'] = model.resid; outlier_apps = df[df['Residuals'].abs() > 2]['App']",
        "Data transformation operation": [
            "cleaning",
            "regression",
            "outlier detection"
        ],
        "New Column Name": "Residuals",
        "Derivation Specification": "Residuals from linear regression of Rating on Installs and Reviews",
        "Missing Data Column": ""
    },
    {
        "query": "what is the app with the most abnormal pattern",
        "Relevant data columns": [
            "App",
            "Rating",
            "Reviews",
            "Installs",
            "Price"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'abnormal pattern' is vague without specifying which feature(s) to consider for determining abnormality.",
        "Ambiguity resolution": "Assume abnormality could be in terms of Rating, Reviews, Installs, or Price. Calculate z-scores for these columns to identify outliers.",
        "Data transformations": "df['Z_Rating'] = (df['Rating'] - df['Rating'].mean()) / df['Rating'].std(); df['Z_Reviews'] = (df['Reviews'].astype(int) - df['Reviews'].astype(int).mean()) / df['Reviews'].astype(int).std(); df['Z_Installs'] = (df['Installs'].str.replace('+', '').str.replace(',', '').astype(int) - df['Installs'].str.replace('+', '').str.replace(',', '').astype(int).mean()) / df['Installs'].str.replace('+', '').str.replace(',', '').astype(int).std(); df['Z_Price'] = (df['Price'].str.replace('$', '').astype(float) - df['Price'].str.replace('$', '').astype(float).mean()) / df['Price'].str.replace('$', '').astype(float).std(); df['Abnormality_Score'] = df[['Z_Rating', 'Z_Reviews', 'Z_Installs', 'Z_Price']].abs().sum(axis=1); df.loc[df['Abnormality_Score'].idxmax(), 'App']",
        "Data transformation operation": [
            "standardization",
            "calculation",
            "aggregation"
        ],
        "New Column Name": "Abnormality_Score",
        "Derivation Specification": "df['Abnormality_Score'] = df[['Z_Rating', 'Z_Reviews', 'Z_Installs', 'Z_Price']].abs().sum(axis=1)",
        "Missing Data Column": ""
    },
    {
        "query": "are there an unusually high number of reviews for any of the apps",
        "Relevant data columns": [
            "Reviews",
            "App"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what constitutes an 'unusually high' number of reviews, nor does it specify if this should be considered within the context of categories or overall.",
        "Ambiguity resolution": "Assume 'unusually high' to mean significantly higher than the average number of reviews. This can be determined by calculating the mean and standard deviation of reviews and identifying apps with reviews greater than mean + 2*standard deviation.",
        "Data transformations": "df['Reviews'] = df['Reviews'].astype(int); mean_reviews = df['Reviews'].mean(); std_reviews = df['Reviews'].std(); df[df['Reviews'] > mean_reviews + 2 * std_reviews][['App', 'Reviews']]",
        "Data transformation operation": [
            "convert type",
            "calculate mean",
            "calculate standard deviation",
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the distribution of the number based on shape of installations",
        "Relevant data columns": [
            "Installs"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'shape' is ambiguous as it is unclear whether it refers to the format of the data, the categorization of installation sizes, or a graphical representation.",
        "Ambiguity resolution": "Assume 'shape' refers to categorizing installation sizes into groups for distribution analysis.",
        "Data transformations": "df['Installs'] = df['Installs'].str.replace('+', '').str.replace(',', '').astype(int); df['Installs'].value_counts()",
        "Data transformation operation": [
            "cleaning",
            "conversion",
            "aggregation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is there an effect on price caused by the app 's genre",
        "Relevant data columns": [
            "Price",
            "Genres"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify whether to consider free apps in the analysis or how to handle apps with varying prices.",
        "Ambiguity resolution": "Exclude free apps from the analysis to focus on paid apps. Convert price from string to numeric for analysis.",
        "Data transformations": "df = df[df['Type'] == 'Paid']; df['Price'] = df['Price'].str.replace('$', '').astype(float); df[['Genres', 'Price']]",
        "Data transformation operation": [
            "filter",
            "convert",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is there a correlation between apps with more installations and higher ratings",
        "Relevant data columns": [
            "Installs",
            "Rating"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The 'Installs' column contains non-numeric values with symbols and suffixes that need to be converted to numeric format for correlation analysis.",
        "Ambiguity resolution": "Convert the 'Installs' column to a numeric format by removing non-numeric characters and converting the result to integers.",
        "Data transformations": "df['Installs_numeric'] = df['Installs'].str.replace(r'[^\\d]', '', regex=True).astype(int); df[['Installs_numeric', 'Rating']].dropna()",
        "Data transformation operation": [
            "convert",
            "select",
            "dropna"
        ],
        "New Column Name": "Installs_numeric",
        "Derivation Specification": "df['Installs_numeric'] = df['Installs'].str.replace(r'[^\\d]', '', regex=True).astype(int)",
        "Missing Data Column": ""
    },
    {
        "query": "tell me the most pricey apps by release date, recent to oldest",
        "Relevant data columns": [
            "Price",
            "Last Updated",
            "App"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum",
            "sort"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query does not specify if free apps should be included or excluded in the list of pricey apps.",
        "Ambiguity resolution": "Assume that only paid apps are considered when identifying the most pricey apps.",
        "Data transformations": "df['Price'] = df['Price'].replace('[\textbackslash\textdollar,]', '', regex=True).astype(float); paid_apps = df[df['Price'] > 0]; sorted_apps = paid_apps.sort_values(by=['Last Updated', 'Price'], ascending=[False, False])",
        "Data transformation operation": [
            "replace",
            "filter",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "find out any app that is distinctive from the rest",
        "Relevant data columns": [
            "App",
            "Category",
            "Rating",
            "Reviews",
            "Size",
            "Installs",
            "Type",
            "Price",
            "Content Rating",
            "Genres",
            "Last Updated",
            "Current Ver",
            "Android Ver"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what makes an app 'distinctive'. It could be based on any of the available metrics or features such as Rating, Reviews, Installs, Price, etc.",
        "Ambiguity resolution": "Assume 'distinctive' refers to apps with extreme values in numeric columns such as Rating, Reviews, and Price. Analyze these columns to find outliers.",
        "Data transformations": "df['Rating'] = pd.to_numeric(df['Rating'], errors='coerce'); df['Reviews'] = pd.to_numeric(df['Reviews'].str.replace(',', ''), errors='coerce'); df['Price'] = df['Price'].str.replace('$', '').astype(float); outliers = df[(np.abs(stats.zscore(df[['Rating', 'Reviews', 'Price']].dropna())) > 3).any(axis=1)]",
        "Data transformation operation": [
            "convert to numeric",
            "replace",
            "calculate z-score",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "list the top 10 gaming apps sorted from highest to lowest installations",
        "Relevant data columns": [
            "App",
            "Category",
            "Installs"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "sort",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The format of the 'Installs' column may need transformation to enable sorting as it includes commas and a plus sign.",
        "Ambiguity resolution": "Remove commas and plus signs from the 'Installs' column to convert it to an integer format for sorting.",
        "Data transformations": "df['Installs'] = df['Installs'].str.replace(',', '').str.replace('+', '').astype(int); df[df['Category'] == 'GAME'].nlargest(10, 'Installs')",
        "Data transformation operation": [
            "transform",
            "filter",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me the price distribution of all the beauty apps",
        "Relevant data columns": [
            "Price",
            "Category"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify whether free apps should be included in the price distribution or if it should focus only on paid apps.",
        "Ambiguity resolution": "Assume the distribution includes both free and paid apps unless specified otherwise.",
        "Data transformations": "beauty_apps = df[df['Category'] == 'BEAUTY']; beauty_apps[['Price']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "name any apps that can support any version of android lower than 40",
        "Relevant data columns": [
            "App",
            "Android Ver"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Android Ver'].str.contains('1.|2.|3.', na=False)][['App', 'Android Ver']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "according to population, what is the rank of each region",
        "Relevant data columns": [
            "Population",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Region', 'Population']].sort_values(by='Population', ascending=False)",
        "Data transformation operation": [
            "select",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the number of hospitals located in manyara",
        "Relevant data columns": [
            "Hospital",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The region 'Manyara' is not listed in the provided dataset sample.",
        "Ambiguity resolution": "Check the complete dataset for the presence of 'Manyara' or consider the possibility of a data entry error or missing data.",
        "Data transformations": "df[df['Region'] == 'Manyara']['Hospital']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Manyara"
    },
    {
        "query": "which 10 regions have the most health centers",
        "Relevant data columns": [
            "Region",
            "Health Centre"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "sort"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Region', 'Health Centre']].sort_values(by='Health Centre', ascending=False).head(10)",
        "Data transformation operation": [
            "select",
            "sort",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "look up regions that names start with the letter a",
        "Relevant data columns": [
            "Region"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Region'].str.startswith('A')]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "make a list of the number of total hfs in descending order",
        "Relevant data columns": [
            "Total HFs"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Region', 'Total HFs']].sort_values(by='Total HFs', ascending=False)",
        "Data transformation operation": [
            "select",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the average count of hospitals",
        "Relevant data columns": [
            "Hospital"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Hospital'].mean()",
        "Data transformation operation": [
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the number of clinics that are in mara",
        "Relevant data columns": [
            "Clinic",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The region 'Mara' is not listed in the provided dataset, which may lead to confusion or incorrect results.",
        "Ambiguity resolution": "Check for alternative names or misspellings of 'Mara' in the dataset, or confirm the region list to ensure 'Mara' should be included.",
        "Data transformations": "df[df['Region'] == 'Mara']['Clinic']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Mara"
    },
    {
        "query": "what's the distribution of the entire hfs",
        "Relevant data columns": [
            "Total HFs"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Total HFs']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which region has the lowest population ratio of hf",
        "Relevant data columns": [
            "Region",
            "ration of population over HF"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['ration of population over HF'].idxmin(), ['Region', 'ration of population over HF']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "enter the regions from this table",
        "Relevant data columns": [
            "Region"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Region']",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "look for the region that has the most people living in it",
        "Relevant data columns": [
            "Region",
            "Population"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Population'].idxmax(), ['Region', 'Population']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "remove any regions with a population ratio of hf lower than 15",
        "Relevant data columns": [
            "ration of population over HF",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df = df[df['ration of population over HF'] >= 1.5]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "the population range needs to be discovered",
        "Relevant data columns": [
            "Population"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "determine range"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Population'].agg(['min', 'max'])",
        "Data transformation operation": [
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "do any regions have their population ratio over 20 hf",
        "Relevant data columns": [
            "Region",
            "ration of population over HF"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['ration of population over HF'] > 2.0][['Region', 'ration of population over HF']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "give me the movie that received the most nominations",
        "Relevant data columns": [
            "nominee"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if the query is asking for the most nominations in a single year or across all years.",
        "Ambiguity resolution": "Assume the query is asking for the most nominations across all years unless specified otherwise.",
        "Data transformations": "df['nominee'].value_counts().idxmax()",
        "Data transformation operation": [
            "count",
            "find maximum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "out of the winners for best performance by an actor in a motion picture - musical or comedy from 2003 to 2020, the most abnormal age belongs to which actor",
        "Relevant data columns": [
            "year_award",
            "category",
            "nominee",
            "win"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The dataset does not contain age information for the actors, and the category specified does not exactly match the categories in the dataset.",
        "Ambiguity resolution": "Assuming additional data linking nominees to their ages is available, join this data. Adjust the category to match dataset categories if necessary.",
        "Data transformations": "additional_data = pd.merge(df, actors_ages, on='nominee'); filtered_data = additional_data[(additional_data['year_award'] >= 2003) & (additional_data['year_award'] <= 2020) & (additional_data['category'].str.contains('Best Performance by an Actor in a Motion Picture - Musical or Comedy')) & (additional_data['win'] == True)]; result = filtered_data.loc[filtered_data['age'].idxmax()]",
        "Data transformation operation": [
            "merge",
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "age"
    },
    {
        "query": "can you organize the results of the table by sorting the list according to the age of the stars",
        "Relevant data columns": [
            "nominee"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain information about the age of the stars, which is necessary to perform the sorting as requested.",
        "Ambiguity resolution": "Obtain or merge additional data that includes the age of the stars for each nominee.",
        "Data transformations": "df = df.merge(stars_age_df, on='nominee'); df.sort_values(by='Star Age')",
        "Data transformation operation": [
            "merge",
            "sort"
        ],
        "New Column Name": "Star Age",
        "Derivation Specification": "",
        "Missing Data Column": "Star Age"
    },
    {
        "query": "can you list all the results in the table about the movie 'About Schmidt'",
        "Relevant data columns": [
            "nominee",
            "year_film",
            "year_award",
            "ceremony",
            "category",
            "win"
        ],
        "Data column classification": [
            "data value mention",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['nominee'] == 'About Schmidt'][['nominee', 'year_film', 'year_award', 'ceremony', 'category', 'win']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what was the gender of all actors among all the final winners in the 60th ceremony",
        "Relevant data columns": [
            "ceremony",
            "win",
            "nominee"
        ],
        "Data column classification": [
            "data value mention",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain gender information for the nominees, and it is unclear if the query is asking for actors specifically or all winners.",
        "Ambiguity resolution": "Assume the query is asking for all winners. To resolve the gender ambiguity, external data linking nominees to their gender is required.",
        "Data transformations": "winners_df = df[(df['ceremony'] == 60) & (df['win'] == True)][['nominee']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "gender"
    },
    {
        "query": "tell me who won the best performance by an actor in a motion picture - drama award at the 60th ceremony",
        "Relevant data columns": [
            "ceremony",
            "category",
            "nominee",
            "win"
        ],
        "Data column classification": [
            "data value mention",
            "keyword",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The category 'best performance by an actor in a motion picture - drama' is not explicitly listed in the provided data sample.",
        "Ambiguity resolution": "Assume the category exists in the full dataset or check for similar categories.",
        "Data transformations": "df[(df['ceremony'] == 60) & (df['category'].str.contains('Best Performance by an Actor in a Motion Picture - Drama')) & (df['win'] == True)]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Best Performance by an Actor in a Motion Picture - Drama"
    },
    {
        "query": "I would like to review the dispersement of the amount of nominations",
        "Relevant data columns": [
            "category",
            "nominee"
        ],
        "Data column classification": [
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for the distribution of nominations across categories, years, or nominees.",
        "Ambiguity resolution": "Assume the query is asking for the distribution of nominations across different categories and years.",
        "Data transformations": "df.groupby(['category', 'year_award']).size().reset_index(name='Number of Nominations')",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "Number of Nominations",
        "Derivation Specification": "df.groupby(['category', 'year_award']).size()",
        "Missing Data Column": ""
    },
    {
        "query": "In the 60th ceremony, the award for best performance by an actor in a motion picture was won by whom",
        "Relevant data columns": [
            "ceremony",
            "category",
            "nominee",
            "win"
        ],
        "Data column classification": [
            "data value mention",
            "inferred",
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The category 'best performance by an actor in a motion picture' is not explicitly listed in the provided data sample.",
        "Ambiguity resolution": "Assume the category includes any category with 'actor' and 'motion picture' in its description.",
        "Data transformations": "df[(df['ceremony'] == 60) & (df['category'].str.contains('actor', case=False, na=False) & df['category'].str.contains('motion picture', case=False, na=False)) & (df['win'] == True)][['nominee']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "category for 'best performance by an actor in a motion picture'"
    },
    {
        "query": "which actor was nominated for the most awards",
        "Relevant data columns": [
            "nominee"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain an 'actor' column, only 'nominee' which includes films, not individual actors.",
        "Ambiguity resolution": "Assuming 'nominee' refers to actors, though it actually refers to films in the provided dataset.",
        "Data transformations": "df['nominee'].value_counts().idxmax()",
        "Data transformation operation": [
            "count",
            "find maximum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "actor"
    },
    {
        "query": "can the actors nationality impact the outcome",
        "Relevant data columns": [
            "nominee",
            "win"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The dataset does not contain information about the actors' nationalities.",
        "Ambiguity resolution": "Join this dataset with another dataset that includes actors' nationalities.",
        "Data transformations": "merged_df = df.merge(actors_df, on='nominee')",
        "Data transformation operation": [
            "join"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "actors nationality"
    },
    {
        "query": "what was the number of candidates that were nominated for best performance by an actor in a motion picture -drama at the 60th ceremony",
        "Relevant data columns": [
            "category",
            "ceremony"
        ],
        "Data column classification": [
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The category specified in the query does not exactly match any category in the dataset, and it is unclear if the dataset includes actor-specific categories.",
        "Ambiguity resolution": "Assuming the category 'Best Motion Picture - Drama' includes actor nominations, or check dataset for correct category names.",
        "Data transformations": "df[(df['ceremony'] == 60) & (df['category'].str.contains('Best Performance by an Actor in a Motion Picture - Drama'))].count()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Best Performance by an Actor in a Motion Picture - Drama"
    },
    {
        "query": "what is the total number of movies released in the year 1998",
        "Relevant data columns": [
            "year_film"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query asks for movies released in 1998, but the dataset only contains information about movies nominated for awards, not all movies released.",
        "Ambiguity resolution": "Assuming the query refers to the number of movies nominated in 1998, not all movies released.",
        "Data transformations": "df[df['year_film'] == 1998]['nominee film'].count()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me what movie won best original score in a motion picture in 1997",
        "Relevant data columns": [
            "category",
            "year_film",
            "win",
            "nominee"
        ],
        "Data column classification": [
            "keyword",
            "data value",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain a specific category for 'Best Original Score'.",
        "Ambiguity resolution": "Assuming 'Best Motion Picture - Drama' or 'Best Motion Picture - Musical or Comedy' categories might include 'Best Original Score' or checking other similar categories if available.",
        "Data transformations": "df[(df['year_film'] == 1997) & (df['category'].str.contains('Best Original Score')) & (df['win'] == True)]['nominee']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Best Original Score"
    },
    {
        "query": "what is the correlation between the nomination and the age of a star",
        "Relevant data columns": [
            "nominee"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain information about the age of a star, nor does it link directly to any external dataset that provides such information.",
        "Ambiguity resolution": "To resolve this, additional data linking nominees to their birthdates or ages at the time of the nomination would be required. This could involve merging this dataset with another dataset containing the birthdates of the nominees.",
        "Data transformations": "df = df.merge(star_ages, on='nominee')",
        "Data transformation operation": [
            "merge"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "star age"
    },
    {
        "query": "is there an outlier within the value distribution of albinism that causes the result to be skewed",
        "Relevant data columns": [
            "ALBINO"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear what method or threshold should be used to define an outlier.",
        "Ambiguity resolution": "Use statistical methods such as IQR or Z-score to define and identify outliers.",
        "Data transformations": "Q1 = df['ALBINO'].quantile(0.25); Q3 = df['ALBINO'].quantile(0.75); IQR = Q3 - Q1; outlier_condition = (df['ALBINO'] < (Q1 - 1.5 * IQR)) | (df['ALBINO'] > (Q3 + 1.5 * IQR)); outliers = df[outlier_condition]",
        "Data transformation operation": [
            "quantile calculation",
            "outlier detection"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "find all the types of genetic diseases with greater than 1,000 patients",
        "Relevant data columns": [
            "ALBINO",
            "AUTISM",
            "DEAF-MUTE",
            "DEAF-BLIND",
            "MENTALLY IMPAIRED",
            "PHYSICAL IMPAIRED",
            "VISUALLY IMPAIRED"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[:, ['ALBINO', 'AUTISM', 'DEAF-MUTE', 'DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']].sum().loc[lambda x: x > 1000]",
        "Data transformation operation": [
            "select",
            "sum",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me the maximum and minimum number of patients with autism across all regions",
        "Relevant data columns": [
            "AUTISM",
            "REGION"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['REGION', 'AUTISM']].agg(['min', 'max'])",
        "Data transformation operation": [
            "select",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the spatial and temporal correlation of albinism",
        "Relevant data columns": [
            "REGION",
            "ALBINO"
        ],
        "Data column classification": [
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The dataset does not contain temporal data, only spatial data is available.",
        "Ambiguity resolution": "Clarify that only spatial analysis can be performed due to the absence of temporal data.",
        "Data transformations": "df[['REGION', 'ALBINO']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Temporal data"
    },
    {
        "query": "does this data represent outliers in the number of patients",
        "Relevant data columns": [
            "ALBINO",
            "AUTISM",
            "DEAF-MUTE",
            "DEAF-BLIND",
            "MENTALLY IMPAIRED",
            "PHYSICAL IMPAIRED",
            "VISUALLY IMPAIRED"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear if outliers should be identified for each disability category separately or across all categories combined.",
        "Ambiguity resolution": "Identify outliers separately for each disability category to maintain clarity and specificity.",
        "Data transformations": "outliers = df.apply(lambda x: x[(x - x.mean()) > 3 * x.std()], axis=0)",
        "Data transformation operation": [
            "apply",
            "lambda",
            "mean",
            "std",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "take out the regions with a number of patients larger than 500",
        "Relevant data columns": [
            "REGION",
            "ALBINO",
            "AUTISM",
            "DEAF-MUTE",
            "DEAF-BLIND",
            "MENTALLY IMPAIRED",
            "PHYSICAL IMPAIRED",
            "VISUALLY IMPAIRED"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query refers to the total number of patients across all disabilities per region or if it refers to each disability separately.",
        "Ambiguity resolution": "Assuming the query refers to the total number of patients across all disabilities per region.",
        "Data transformations": "df['Total Patients'] = df[['ALBINO', 'AUTISM', 'DEAF-MUTE', 'DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']].sum(axis=1); df[df['Total Patients'] > 500][['REGION', 'Total Patients']]",
        "Data transformation operation": [
            "sum",
            "filter",
            "select"
        ],
        "New Column Name": "Total Patients",
        "Derivation Specification": "df['Total Patients'] = df[['ALBINO', 'AUTISM', 'DEAF-MUTE', 'DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']].sum(axis=1)",
        "Missing Data Column": ""
    },
    {
        "query": "looking at the number of people in all regions with a visual impairment, what is the median",
        "Relevant data columns": [
            "VISUALLY IMPAIRED"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['VISUALLY IMPAIRED'].median()",
        "Data transformation operation": [
            "calculate median"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "does the value distribution of albinism look skewed",
        "Relevant data columns": [
            "ALBINO"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution",
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the type of skewness (positive or negative) or any specific statistical measure to quantify skewness.",
        "Ambiguity resolution": "Calculate skewness of the 'ALBINO' column to determine the type and extent of skewness.",
        "Data transformations": "df['ALBINO'].skew()",
        "Data transformation operation": [
            "skewness calculation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is there an obvious clustering",
        "Relevant data columns": [
            "REGION",
            "ALBINO",
            "AUTISM",
            "DEAF-MUTE",
            "DEAF-BLIND",
            "MENTALLY IMPAIRED",
            "PHYSICAL IMPAIRED",
            "VISUALLY IMPAIRED"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "cluster"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the type of clustering (e.g., hierarchical, k-means) or the features (columns) to be used for clustering.",
        "Ambiguity resolution": "Assume a general clustering method like k-means and use all numerical columns for clustering.",
        "Data transformations": "df.fillna(0).drop(columns=['REGION'])",
        "Data transformation operation": [
            "fillna",
            "drop"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "kindly rate the regions on the basis of the number of patients",
        "Relevant data columns": [
            "REGION",
            "ALBINO",
            "AUTISM",
            "DEAF-MUTE",
            "DEAF-BLIND",
            "MENTALLY IMPAIRED",
            "PHYSICAL IMPAIRED",
            "VISUALLY IMPAIRED"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify if the rating should be based on the total number of patients across all disabilities or if it should be based on specific types of disabilities.",
        "Ambiguity resolution": "Assume the rating is based on the total number of patients across all disabilities.",
        "Data transformations": "df['Total Patients'] = df[['ALBINO', 'AUTISM', 'DEAF-MUTE', 'DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']].sum(axis=1); df_sorted = df[['REGION', 'Total Patients']].sort_values(by='Total Patients', ascending=False)",
        "Data transformation operation": [
            "sum",
            "select",
            "sort"
        ],
        "New Column Name": "Total Patients",
        "Derivation Specification": "df['Total Patients'] = df[['ALBINO', 'AUTISM', 'DEAF-MUTE', 'DEAF-BLIND', 'MENTALLY IMPAIRED', 'PHYSICAL IMPAIRED', 'VISUALLY IMPAIRED']].sum(axis=1)",
        "Missing Data Column": ""
    },
    {
        "query": "they want to know what tactic is most effective during football",
        "Relevant data columns": [
            "tactic",
            "goals"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear how 'effectiveness' is measured. Does it relate to the number of goals, shooting attempts, or a combination of both?",
        "Ambiguity resolution": "Assume effectiveness is measured by the number of goals scored per shooting attempt.",
        "Data transformations": "df['effectiveness'] = df['goals'] / df['shooting attempts']; df.groupby('tactic')['effectiveness'].mean()",
        "Data transformation operation": [
            "calculate new column",
            "groupby",
            "average"
        ],
        "New Column Name": "effectiveness",
        "Derivation Specification": "df['effectiveness'] = df['goals'] / df['shooting attempts']",
        "Missing Data Column": ""
    },
    {
        "query": "were you aware of the most recent news",
        "Relevant data columns": [
            "date"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what 'news' refers to, nor does it clearly relate to the dataset. It is ambiguous whether 'news' refers to a specific event or data point within the dataset.",
        "Ambiguity resolution": "Assuming 'news' refers to the most recent data entries, sort the dataset by date and retrieve the latest entries.",
        "Data transformations": "df.sort_values(by='date', ascending=False).head()",
        "Data transformation operation": [
            "sort",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "the clubs should be arranged by their shooting attempts",
        "Relevant data columns": [
            "shooting attempts"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'clubs' is used, but the dataset contains player names and not club names. It is unclear if 'clubs' refers to a missing column or a misunderstanding of the dataset.",
        "Ambiguity resolution": "Assuming 'clubs' refers to the players' teams, which is not present in the dataset. If 'clubs' is intended to mean 'players', then sort by 'shooting attempts'.",
        "Data transformations": "df.sort_values(by='shooting attempts', ascending=False)",
        "Data transformation operation": [
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "club"
    },
    {
        "query": "what was the total amount of goals scored in the game that Liverpool played in",
        "Relevant data columns": [
            "goals",
            "game"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain a direct reference to 'Liverpool' or any identifiable team codes that match common knowledge of Liverpool's abbreviations or nicknames.",
        "Ambiguity resolution": "Assuming 'LO' represents Liverpool based on the context, although this needs confirmation.",
        "Data transformations": "df[df['game'] == 'LO']['goals'].sum()",
        "Data transformation operation": [
            "filter",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "game"
    },
    {
        "query": "the games are sorted by experts by their date",
        "Relevant data columns": [
            "date",
            "game"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear whether the sorting should be ascending or descending and if the sorting is based solely on the date or if it involves other attributes as well.",
        "Ambiguity resolution": "Assume sorting by date in ascending order unless specified otherwise.",
        "Data transformations": "df.sort_values(by='date')",
        "Data transformation operation": [
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "rank these clubs by their shooting attempts",
        "Relevant data columns": [
            "shooting attempts",
            "date game"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The term 'clubs' is used, but the dataset contains 'date game' which might imply specific matches rather than clubs.",
        "Ambiguity resolution": "Assume 'date game' represents different clubs or matches and proceed with ranking based on 'shooting attempts'.",
        "Data transformations": "df.groupby('date game')['shooting attempts'].sum().sort_values(ascending=False)",
        "Data transformation operation": [
            "groupby",
            "sum",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can lower study times among students cause greater failure rates in class",
        "Relevant data columns": [
            "studytime",
            "failures"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify the threshold for what constitutes 'lower' study times, nor does it clarify if the failure rate should be calculated or if raw failure counts are sufficient.",
        "Ambiguity resolution": "Assume 'lower' study times to be below the median study time of the dataset. Calculate failure rates as the proportion of students with non-zero failures in these groups.",
        "Data transformations": "df['lower_study_time'] = df['studytime'] < df['studytime'].median(); df.groupby('lower_study_time')['failures'].mean()",
        "Data transformation operation": [
            "new column creation",
            "groupby",
            "mean calculation"
        ],
        "New Column Name": "lower_study_time",
        "Derivation Specification": "df['lower_study_time'] = df['studytime'] < df['studytime'].median()",
        "Missing Data Column": ""
    },
    {
        "query": "can you name an unusual reason for choosing this school",
        "Relevant data columns": [
            "reason"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'unusual' is subjective and not clearly defined in the context of the dataset.",
        "Ambiguity resolution": "Identify the least frequent reasons listed for choosing the school as 'unusual'.",
        "Data transformations": "df['reason'].value_counts().nsmallest(1)",
        "Data transformation operation": [
            "count",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "could you show me the list sorted by study time (longest to shortest)",
        "Relevant data columns": [
            "studytime"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.sort_values(by='studytime', ascending=False)",
        "Data transformation operation": [
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "find the distribution by age",
        "Relevant data columns": [
            "age"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "exploratory",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['age'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me which students have fathers that are teachers",
        "Relevant data columns": [
            "Fjob"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Fjob'] == 'teacher']",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "retrieve the students with fathers who work as teachers",
        "Relevant data columns": [
            "Fjob"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Fjob'] == 'teacher']",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me the youngest students in the dataset",
        "Relevant data columns": [
            "age"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['age'] == df['age'].min()]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me the types of jobs the student's mothers have",
        "Relevant data columns": [
            "Mjob"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Mjob'].unique()",
        "Data transformation operation": [
            "select",
            "unique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "I'm wondering would the travel time decrease for students if they spent more time studying",
        "Relevant data columns": [
            "traveltime",
            "studytime"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query assumes a causal relationship between study time and travel time without specifying the nature of this relationship or considering other influencing factors.",
        "Ambiguity resolution": "To resolve this, one could analyze the correlation between study time and travel time while considering other variables that might affect both, such as 'address' (urban or rural) which could influence travel times.",
        "Data transformations": "df[['studytime', 'traveltime']].corr()",
        "Data transformation operation": [
            "correlation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "would more time spent on studying reduce travel time for students",
        "Relevant data columns": [
            "studytime",
            "traveltime"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query implies a causal relationship between study time and travel time, which may not be directly inferable from the data.",
        "Ambiguity resolution": "Clarify that the analysis can only show correlation, not causation. Suggest analyzing the correlation between study time and travel time.",
        "Data transformations": "correlation_df = df[['studytime', 'traveltime']].corr()",
        "Data transformation operation": [
            "select",
            "correlation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "please help me identify the least common age",
        "Relevant data columns": [
            "age"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['age'].value_counts().idxmin()",
        "Data transformation operation": [
            "count",
            "find minimum index"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "name me a country that 's happiness score does not coincide with the region it belongs to",
        "Relevant data columns": [
            "Country",
            "Region",
            "Happiness Score"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query is ambiguous because it does not specify what it means for a happiness score to 'not coincide' with the region it belongs to. Does it refer to statistical outliers within each region, or does it imply a comparison against a global or regional average?",
        "Ambiguity resolution": "Assume the query is asking for countries whose happiness scores are outliers within their respective regions. This can be determined by comparing each country's happiness score to the average and standard deviation of scores within its region.",
        "Data transformations": "df['Mean Happiness Score by Region'] = df.groupby('Region')['Happiness Score'].transform('mean'); df['Std Dev Happiness Score by Region'] = df.groupby('Region')['Happiness Score'].transform('std'); df['Outlier'] = (df['Happiness Score'] < (df['Mean Happiness Score by Region'] - 2 * df['Std Dev Happiness Score by Region'])) | (df['Happiness Score'] > (df['Mean Happiness Score by Region'] + 2 * df['Std Dev Happiness Score by Region'])); outlier_countries = df[df['Outlier']][['Country', 'Region', 'Happiness Score']]",
        "Data transformation operation": [
            "groupby",
            "transform",
            "filter"
        ],
        "New Column Name": "Outlier",
        "Derivation Specification": "Outlier = (Happiness Score < (Mean Happiness Score by Region - 2 * Std Dev Happiness Score by Region)) | (Happiness Score > (Mean Happiness Score by Region + 2 * Std Dev Happiness Score by Region))",
        "Missing Data Column": ""
    },
    {
        "query": "tell me the country with the lowest trust score",
        "Relevant data columns": [
            "Country",
            "Trust (Government Corruption)"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Trust (Government Corruption)'].idxmin(), ['Country', 'Trust (Government Corruption)']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is there a correlation between happiness scores and other attributes",
        "Relevant data columns": [
            "Happiness Score",
            "Standard Error",
            "Economy (GDP per Capita)",
            "Family",
            "Health (Life Expectancy)",
            "Freedom",
            "Trust (Government Corruption)",
            "Generosity",
            "Dystopia Residual"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Happiness Score', 'Standard Error', 'Economy (GDP per Capita)', 'Family', 'Health (Life Expectancy)', 'Freedom', 'Trust (Government Corruption)', 'Generosity', 'Dystopia Residual']].corr()",
        "Data transformation operation": [
            "correlation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me, in terms of economy, what is the range across all countries",
        "Relevant data columns": [
            "Economy (GDP per Capita)"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "determine range"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Economy (GDP per Capita)'].agg(['min', 'max'])",
        "Data transformation operation": [
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what countries, other than Finland, have higher happiness scores and lower GDP",
        "Relevant data columns": [
            "Country",
            "Happiness Score",
            "Economy (GDP per Capita)"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear what specific GDP value or Happiness Score threshold should be used for comparison.",
        "Ambiguity resolution": "Use Finland's GDP and Happiness Score as the reference values for comparison.",
        "Data transformations": "finland_gdp = df[df['Country'] == 'Finland']['Economy (GDP per Capita)'].iloc[0]; finland_happiness = df[df['Country'] == 'Finland']['Happiness Score'].iloc[0]; result_df = df[(df['Happiness Score'] > finland_happiness) & (df['Economy (GDP per Capita)'] < finland_gdp) & (df['Country'] != 'Finland')]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me the area in the previous decade that increased rapidly in the happiness score",
        "Relevant data columns": [
            "Region",
            "Happiness Score"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies",
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The dataset does not contain data spanning multiple decades, and the term 'previous decade' is ambiguous without a clear reference to specific years.",
        "Ambiguity resolution": "Assuming the dataset represents the most recent data, infer trends within the available data or request additional data spanning multiple decades.",
        "Data transformations": "df.groupby('Region')['Happiness Score'].mean().reset_index()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me any clustering there may be in the gdp that has a happiness score of larger than 5",
        "Relevant data columns": [
            "Economy (GDP per Capita)",
            "Happiness Score"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "cluster"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the method or parameters for clustering, such as the number of clusters or the specific clustering algorithm to use.",
        "Ambiguity resolution": "Assume a default clustering method such as K-means and determine an appropriate number of clusters based on the data distribution or use a standard method like the elbow method to decide.",
        "Data transformations": "filtered_df = df[df['Happiness Score'] > 5][['Economy (GDP per Capita)', 'Happiness Score']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "within the last year have any countries experienced a sudden decrease in happiness score",
        "Relevant data columns": [
            "Country",
            "Happiness Score",
            "Happiness Rank"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset provided does not include multiple years of data to analyze trends or changes over time.",
        "Ambiguity resolution": "Assuming additional data is available for multiple years, calculate the difference in happiness scores between the last two years for each country.",
        "Data transformations": "Assuming df_years represents a dataset with multiple years: df_years['Happiness Score Change'] = df_years.groupby('Country')['Happiness Score'].diff(); df_years[df_years['Happiness Score Change'] < 0]",
        "Data transformation operation": [
            "groupby",
            "difference calculation",
            "filter"
        ],
        "New Column Name": "Happiness Score Change",
        "Derivation Specification": "df_years['Happiness Score Change'] = df_years.groupby('Country')['Happiness Score'].diff()",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me the range of happiness score in western europe",
        "Relevant data columns": [
            "Happiness Score",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "determine range"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Region'] == 'Western Europe']['Happiness Score'].agg(['min', 'max'])",
        "Data transformation operation": [
            "filter",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "out of all the countries, which ones have a happiness score higher than Finland",
        "Relevant data columns": [
            "Country",
            "Happiness Score"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Happiness Score'] > df[df['Country'] == 'Finland']['Happiness Score'].values[0]][['Country', 'Happiness Score']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me in what range will the number of countries in each region fall",
        "Relevant data columns": [
            "Country",
            "Region"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "determine range"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the exact nature of 'range'\u2014whether it refers to the minimum and maximum number of countries per region or a statistical range such as quartiles.",
        "Ambiguity resolution": "Assume the query is asking for the minimum and maximum number of countries per region.",
        "Data transformations": "df.groupby('Region')['Country'].count().agg(['min', 'max'])",
        "Data transformation operation": [
            "groupby",
            "count",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "please identify the parameters of the happiness score in western Europe",
        "Relevant data columns": [
            "Happiness Score",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Region'] == 'Western Europe'][['Happiness Score', 'Region']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show all the countries with happiness scores higher than 5",
        "Relevant data columns": [
            "Country",
            "Happiness Score"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Happiness Score'] > 5][['Country', 'Happiness Score']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "name the continent that contains the greatest number of countries that are top 10 on the happiness index",
        "Relevant data columns": [
            "Region",
            "Happiness Rank"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum",
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Happiness Rank'] <= 10].groupby('Region').size().idxmax()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count",
            "retrieve maximum index"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "do any countries have happiness scores that don't match with their gdp",
        "Relevant data columns": [
            "Happiness Score",
            "Economy (GDP per Capita)",
            "Country"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies",
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what constitutes a 'match' between happiness scores and GDP.",
        "Ambiguity resolution": "Assume a correlation analysis to determine if there are outliers or anomalies where happiness scores significantly deviate from what would be expected based on GDP.",
        "Data transformations": "df['GDP_Happiness_Difference'] = df['Happiness Score'] - df['Economy (GDP per Capita)'].rank(pct=True) * df['Happiness Score'].max(); df[df['GDP_Happiness_Difference'].abs() > df['GDP_Happiness_Difference'].std() * 2]",
        "Data transformation operation": [
            "new column calculation",
            "filter"
        ],
        "New Column Name": "GDP_Happiness_Difference",
        "Derivation Specification": "df['GDP_Happiness_Difference'] = df['Happiness Score'] - df['Economy (GDP per Capita)'].rank(pct=True) * df['Happiness Score'].max()",
        "Missing Data Column": ""
    },
    {
        "query": "of all the countries trust score, which country has the lowest",
        "Relevant data columns": [
            "Country",
            "Trust (Government Corruption)"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Trust (Government Corruption)'].idxmin(), ['Country', 'Trust (Government Corruption)']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "name the country that scores the least on trust",
        "Relevant data columns": [
            "Country",
            "Trust (Government Corruption)"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Trust (Government Corruption)'].idxmin(), ['Country', 'Trust (Government Corruption)']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the range across all the countries in terms of economy",
        "Relevant data columns": [
            "Economy (GDP per Capita)",
            "Country"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "determine range"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Country', 'Economy (GDP per Capita)']].agg(['min', 'max'])",
        "Data transformation operation": [
            "select",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "organize the countries based on happiness score, with the score limit on each group being 10",
        "Relevant data columns": [
            "Country",
            "Happiness Score"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "sort",
            "cluster"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'score limit on each group being 10' is ambiguous as it is unclear how to apply a limit of 10 to happiness scores that are already below 10.",
        "Ambiguity resolution": "Assuming the intent is to categorize countries into groups based on ranges of happiness scores, each range having a width of 10, which is not applicable here as all scores are below 10. Instead, categorize by existing score ranges.",
        "Data transformations": "df['Score Group'] = pd.cut(df['Happiness Score'], bins=[0, 10], labels=['0-10']); df_sorted = df.sort_values(by='Happiness Score', ascending=False)[['Country', 'Happiness Score', 'Score Group']]",
        "Data transformation operation": [
            "categorize",
            "sort",
            "select"
        ],
        "New Column Name": "Score Group",
        "Derivation Specification": "df['Score Group'] = pd.cut(df['Happiness Score'], bins=[0, 10], labels=['0-10'])",
        "Missing Data Column": ""
    },
    {
        "query": "show me the distribution of the health score as it is presented in different regions",
        "Relevant data columns": [
            "Health (Life Expectancy)",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "exploratory",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Region', 'Health (Life Expectancy)']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me the average gdp of countries in western europe",
        "Relevant data columns": [
            "Economy (GDP per Capita)",
            "Region"
        ],
        "Data column classification": [
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Region'] == 'Western Europe']['Economy (GDP per Capita)'].mean()",
        "Data transformation operation": [
            "filter",
            "select",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "organize the countries by their region",
        "Relevant data columns": [
            "Country",
            "Region"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Region')['Country'].apply(list)",
        "Data transformation operation": [
            "groupby",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "for all the regions, can you show me the pattern of the happiness score",
        "Relevant data columns": [
            "Region",
            "Happiness Score"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Region', 'Happiness Score']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what are all the countries that have a happiness score similar to Finland 5 is an acceptable error score",
        "Relevant data columns": [
            "Country",
            "Happiness Score"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "similarity",
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The term 'Fineland' seems to be a typo or incorrect reference, likely meant to be 'Finland'.",
        "Ambiguity resolution": "Assuming 'Fineland' refers to 'Finland' for the query processing.",
        "Data transformations": "finland_score = df[df['Country'] == 'Finland']['Happiness Score'].iloc[0]; df[df['Happiness Score'].between(finland_score - 5, finland_score + 5)][['Country', 'Happiness Score']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the range of economy across all the countries",
        "Relevant data columns": [
            "Economy (GDP per Capita)"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "determine range"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Economy (GDP per Capita)'].agg(['min', 'max'])",
        "Data transformation operation": [
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "rank countries high to low by their family score",
        "Relevant data columns": [
            "Country",
            "Family"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.sort_values(by='Family', ascending=False)[['Country', 'Family']]",
        "Data transformation operation": [
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can we conclude that higher happiness comes from higher freedom",
        "Relevant data columns": [
            "Happiness Score",
            "Freedom"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify if the analysis should consider other factors that might influence happiness, or if it should be isolated to just happiness and freedom.",
        "Ambiguity resolution": "Perform a correlation analysis between happiness and freedom, possibly controlling for other variables to isolate the effect of freedom on happiness.",
        "Data transformations": "correlation = df[['Happiness Score', 'Freedom']].corr()",
        "Data transformation operation": [
            "correlation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what dimension of the happiness index has the maximum fluctuation",
        "Relevant data columns": [
            "Happiness Rank",
            "Happiness Score",
            "Standard Error",
            "Economy (GDP per Capita)",
            "Family",
            "Health (Life Expectancy)",
            "Freedom",
            "Trust (Government Corruption)",
            "Generosity",
            "Dystopia Residual"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear whether fluctuation refers to the range, standard deviation, or another measure of variability.",
        "Ambiguity resolution": "Assume fluctuation refers to the standard deviation as a common measure of dispersion.",
        "Data transformations": "df.std()",
        "Data transformation operation": [
            "standard deviation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "retrieve the country that has had a sudden decrease in happiness score within a year",
        "Relevant data columns": [
            "Country",
            "Happiness Score",
            "Happiness Rank"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset provided does not include multiple years of data for each country to detect changes in happiness score over time.",
        "Ambiguity resolution": "Request additional data that includes happiness scores for multiple years or clarify that the analysis is not possible with the current dataset.",
        "Data transformations": "",
        "Data transformation operation": [],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Year"
    },
    {
        "query": "across all regions, what is the happiness score pattern",
        "Relevant data columns": [
            "Region",
            "Happiness Score"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'pattern' is vague and could refer to trends, distributions, or comparisons across regions.",
        "Ambiguity resolution": "Assume 'pattern' refers to understanding the distribution and central tendencies of Happiness Scores across different regions.",
        "Data transformations": "df.groupby('Region')['Happiness Score'].describe()",
        "Data transformation operation": [
            "groupby",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "the health score is highest in which country",
        "Relevant data columns": [
            "Health (Life Expectancy)",
            "Country"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Health (Life Expectancy)'].idxmax(), ['Country', 'Health (Life Expectancy)']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "the highest health score is held by which country",
        "Relevant data columns": [
            "Health (Life Expectancy)",
            "Country"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Health (Life Expectancy)'].idxmax(), ['Country', 'Health (Life Expectancy)']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me the distribution for the book ratings",
        "Relevant data columns": [
            "averageRating"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['averageRating'].dropna()",
        "Data transformation operation": [
            "select",
            "drop missing values"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you rearrange the table by book rating in descending order",
        "Relevant data columns": [
            "averageRating"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.sort_values(by='averageRating', ascending=False)",
        "Data transformation operation": [
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what books have low ratings that seem suspect",
        "Relevant data columns": [
            "title",
            "averageRating"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'low ratings' is ambiguous as it does not specify a numeric threshold. Additionally, 'suspect' is subjective and needs clarification on what criteria define a rating as suspect.",
        "Ambiguity resolution": "Define a numeric threshold for 'low ratings' such as ratings below 3.0. Define 'suspect' ratings as those that are outliers or significantly lower than the average rating for similar books.",
        "Data transformations": "df[df['averageRating'] < 3.0]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me the book ratings distribution",
        "Relevant data columns": [
            "averageRating"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['averageRating'].dropna()",
        "Data transformation operation": [
            "select",
            "drop missing values"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which author has worked with dark horse comics most frequently",
        "Relevant data columns": [
            "authors",
            "publisher"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain explicit information about collaborations with 'Dark Horse Comics' or any specific counts of publications per author with them.",
        "Ambiguity resolution": "Assuming 'Dark Horse Comics' should be present in the 'publisher' column, filter data for this publisher and count publications per author.",
        "Data transformations": "df[df['publisher'] == 'Dark Horse Comics'].groupby('authors').size().idxmax()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count",
            "find maximum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "publisher"
    },
    {
        "query": "please go and get all of the books written in english",
        "Relevant data columns": [
            "language"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df = df[df['language'] == 'en']",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "are there outliers in the book ratings",
        "Relevant data columns": [
            "averageRating"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify the method or threshold for identifying outliers.",
        "Ambiguity resolution": "Assume a common statistical method such as IQR or Z-score to identify outliers.",
        "Data transformations": "q1 = df['averageRating'].quantile(0.25); q3 = df['averageRating'].quantile(0.75); iqr = q3 - q1; lower_bound = q1 - 1.5 * iqr; upper_bound = q3 + 1.5 * iqr; outliers = df[(df['averageRating'] < lower_bound) | (df['averageRating'] > upper_bound)]",
        "Data transformation operation": [
            "quantile calculation",
            "IQR calculation",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "of fiction books, which are written in English",
        "Relevant data columns": [
            "categories",
            "language"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df = df[(df['categories'].str.contains('Fiction')) & (df['language'] == 'en')]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    null,
    {
        "query": "how many books have been released by dark horse comics",
        "Relevant data columns": [
            "publisher"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The publisher 'Dark Horse Comics' is not explicitly mentioned in the dataset provided.",
        "Ambiguity resolution": "Assuming 'Dark Horse Comics' is a publisher, filter the dataset for this publisher and count the entries.",
        "Data transformations": "df[df['publisher'] == 'Dark Horse Comics'].shape[0]",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "publisher"
    },
    {
        "query": "what is the most expensive book and who published it",
        "Relevant data columns": [
            "title",
            "publisher"
        ],
        "Data column classification": [
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The dataset does not contain price information for the books.",
        "Ambiguity resolution": "Assuming price information is available, proceed with finding the maximum price. If not, the query cannot be resolved with the current dataset.",
        "Data transformations": "Assuming a 'price' column exists, df.loc[df['price'].idxmax(), ['title', 'publisher']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "price"
    },
    {
        "query": "show a list of similarly rated books",
        "Relevant data columns": [
            "title",
            "averageRating"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "similarity"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what 'similarly rated' means in terms of rating range or specific rating value.",
        "Ambiguity resolution": "Assume a default range for similarity, such as +/- 0.5 from a given book's rating.",
        "Data transformations": "rating_reference = 4.0; df_similar_rated = df[(df['averageRating'] >= rating_reference - 0.5) & (df['averageRating'] <= rating_reference + 0.5)][['title', 'averageRating']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "produce a list of book titles published during the current year",
        "Relevant data columns": [
            "title",
            "publishedDate"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The current year is not specified in the query, and it's unclear if the dataset contains books from the current year.",
        "Ambiguity resolution": "Assume the current year is 2023 and filter the dataset accordingly.",
        "Data transformations": "df['publishedDate'] = pd.to_datetime(df['publishedDate'], errors='coerce'); current_year_books = df[df['publishedDate'].dt.year == 2023]['title']",
        "Data transformation operation": [
            "convert to datetime",
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "dark horse comic has how many books",
        "Relevant data columns": [
            "title",
            "categories"
        ],
        "Data column classification": [
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if 'dark horse comic' refers to a specific category, title, or publisher, and whether it should include books from all categories or only specific ones.",
        "Ambiguity resolution": "Assume 'dark horse comic' refers to a category and count books in that category. If not found, check if it appears in titles or as a publisher.",
        "Data transformations": "df[df['categories'].str.contains('dark horse comic', na=False, case=False)].shape[0]",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "in terms of the readings, group the similar timestamps for the Sants",
        "Relevant data columns": [
            "Generated",
            "Station"
        ],
        "Data column classification": [
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "cluster"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear which specific readings or attributes should be included in the grouping or if any specific aggregation or transformation is needed for the readings.",
        "Ambiguity resolution": "Assume all available readings (O3 Value, NO2 Value, PM10 Value) should be included in the grouping. Aggregate these readings by mean or sum if multiple entries exist for the same timestamp.",
        "Data transformations": "df[df['Station'] == 'Barcelona - Sants'].groupby('Generated').agg({'O3 Value': 'mean', 'NO2 Value': 'mean', 'PM10 Value': 'mean'})",
        "Data transformation operation": [
            "filter",
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "for o3, what is the distribution value",
        "Relevant data columns": [
            "O3 Value"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the time frame or specific conditions (like location or air quality status) under which the distribution should be considered.",
        "Ambiguity resolution": "Assume distribution over all available data unless specified otherwise.",
        "Data transformations": "df[['O3 Value']].dropna()",
        "Data transformation operation": [
            "select",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "in the whole table, show me the best record of pm10",
        "Relevant data columns": [
            "PM10 Value",
            "Station"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear whether 'best' refers to the highest or lowest value of PM10.",
        "Ambiguity resolution": "Assume 'best' refers to the lowest PM10 value as it typically indicates better air quality.",
        "Data transformations": "df.loc[df['PM10 Value'].idxmin(), ['Station', 'PM10 Value']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "based on their pollution, group the locations together that are similar",
        "Relevant data columns": [
            "Station",
            "Air Quality",
            "O3 Quality",
            "NO2 Quality",
            "PM10 Quality"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "cluster",
            "similarity"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify which pollutants or combination of pollutants should be used to determine similarity, nor does it specify the method for grouping (e.g., clustering, threshold-based).",
        "Ambiguity resolution": "Assume similarity is based on the qualitative assessment of air quality for each pollutant (O3, NO2, PM10) and use a clustering algorithm to group stations with similar pollution profiles.",
        "Data transformations": "df['Pollution Profile'] = df[['O3 Quality', 'NO2 Quality', 'PM10 Quality']].astype(str).agg('-'.join, axis=1); grouped_locations = df.groupby('Pollution Profile')['Station'].apply(list)",
        "Data transformation operation": [
            "aggregate",
            "groupby"
        ],
        "New Column Name": "Pollution Profile",
        "Derivation Specification": "df['Pollution Profile'] = df[['O3 Quality', 'NO2 Quality', 'PM10 Quality']].astype(str).agg('-'.join, axis=1)",
        "Missing Data Column": ""
    },
    {
        "query": "please look at the o3 data and find the minimum number",
        "Relevant data columns": [
            "O3 Value"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the minimum should be found across all stations or for each station individually.",
        "Ambiguity resolution": "Assuming the minimum should be found across all stations.",
        "Data transformations": "df['O3 Value'].min()",
        "Data transformation operation": [
            "min"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "in what manner are good air quality records dispersed throughout the monitored region",
        "Relevant data columns": [
            "Station",
            "Air Quality",
            "Longitude",
            "Latitude"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the type of dispersion or distribution method to be used, nor does it clarify if 'good' refers to all pollutants or specific ones.",
        "Ambiguity resolution": "Assume 'good' refers to the general 'Air Quality' column. Filter records where 'Air Quality' is 'Good' and visualize the distribution of these records based on geographical coordinates.",
        "Data transformations": "df_good = df[df['Air Quality'] == 'Good'][['Station', 'Longitude', 'Latitude']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "are there any outliers in pm10 readings from a temporal perspective",
        "Relevant data columns": [
            "PM10 Value",
            "Generated"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear what constitutes an outlier in the context of PM10 readings. Specific criteria or thresholds for outliers are not provided.",
        "Ambiguity resolution": "Assume outliers are values that are significantly higher or lower than the mean. Use statistical methods like Z-score or IQR to identify these.",
        "Data transformations": "df['Generated'] = pd.to_datetime(df['Generated']); df.set_index('Generated', inplace=True); df['PM10 Value'].dropna().describe(percentiles=[0.25, 0.75])",
        "Data transformation operation": [
            "convert to datetime",
            "set index",
            "drop NA",
            "calculate statistics"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "work out the quality of o3",
        "Relevant data columns": [
            "O3 Quality"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query requires a specific time or station, or if it pertains to all available data.",
        "Ambiguity resolution": "Assume the query pertains to all available data unless a specific time or station is mentioned.",
        "Data transformations": "df[['Station', 'O3 Quality']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "put the readings in order according to their pm 10 values",
        "Relevant data columns": [
            "PM10 Value"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify if the sorting should be in ascending or descending order.",
        "Ambiguity resolution": "Assume sorting in ascending order unless specified otherwise.",
        "Data transformations": "df.sort_values(by='PM10 Value', ascending=True)",
        "Data transformation operation": [
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is distribution for pm10 value anything other than normal",
        "Relevant data columns": [
            "PM10 Value"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution",
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the method to determine if the distribution is normal or not.",
        "Ambiguity resolution": "Use statistical tests such as Shapiro-Wilk test to determine if the distribution is normal.",
        "Data transformations": "df.dropna(subset=['PM10 Value'])",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me a day with extremely bad air quality",
        "Relevant data columns": [
            "Station Air Quality",
            "Generated"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The dataset does not contain a specific measure or threshold for 'extremely bad' air quality, nor does it specify if all stations must report bad quality on the same day or if it is sufficient for any station to report such a condition.",
        "Ambiguity resolution": "Assume 'extremely bad' air quality corresponds to the worst category available in the 'Station Air Quality' data. Filter data to days where any station reports this category.",
        "Data transformations": "df[df['Station Air Quality'] == 'Poor']['Generated'].drop_duplicates()",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what days had really bad air quality",
        "Relevant data columns": [
            "Station Air Quality",
            "Generated"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "filter",
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'really bad' is subjective and not clearly defined in terms of air quality ratings.",
        "Ambiguity resolution": "Assume 'really bad' refers to the worst categories available in the 'Station Air Quality' data, typically 'Poor' or 'Very Poor', if these categories exist.",
        "Data transformations": "df[df['Station Air Quality'].isin(['Poor', 'Very Poor'])][['Generated', 'Station Air Quality']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "give me the count of missing readings in this table",
        "Relevant data columns": [
            "O3 Hour",
            "O3 Quality",
            "O3 Value",
            "NO2 Hour",
            "NO2 Quality",
            "NO2 Value",
            "PM10 Hour",
            "PM10 Quality",
            "PM10 Value"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.isnull().sum()",
        "Data transformation operation": [
            "count missing values"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me the data attribute that has the most na values, for example the hardest data points to collect",
        "Relevant data columns": [
            "O3 Hour",
            "O3 Quality",
            "O3 Value",
            "NO2 Hour",
            "NO2 Quality",
            "NO2 Value",
            "PM10 Hour",
            "PM10 Quality",
            "PM10 Value"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.isna().sum().idxmax()",
        "Data transformation operation": [
            "count missing values",
            "identify maximum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "describe the change in air quality over one day describe the change in each air pollutant",
        "Relevant data columns": [
            "Generated",
            "Air Quality",
            "O3 Value",
            "NO2 Value",
            "PM10 Value"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "trend",
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query does not specify which stations or if all stations should be included in the analysis, nor does it specify the exact time range for 'one day'.",
        "Ambiguity resolution": "Assume the analysis is for all stations and for the entire range of times provided in the dataset for a single day.",
        "Data transformations": "df['Generated'] = pd.to_datetime(df['Generated']); df = df.set_index('Generated').groupby('Station').resample('D').agg({'O3 Value': 'mean', 'NO2 Value': 'mean', 'PM10 Value': 'mean', 'Air Quality': lambda x: x.value_counts().idxmax()})",
        "Data transformation operation": [
            "convert to datetime",
            "set index",
            "groupby",
            "resample",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "could you search all available values for pm10 quality",
        "Relevant data columns": [
            "PM10 Quality"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['PM10 Quality'].dropna().unique()",
        "Data transformation operation": [
            "select",
            "filter",
            "unique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "are the o3 value and the pm10 value dependent on each other",
        "Relevant data columns": [
            "O3 Value",
            "PM10 Value"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "dependency"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify if the dependency should be checked across all data or within specific conditions such as time or location.",
        "Ambiguity resolution": "Assume the dependency check is across all available data without filtering for specific conditions unless specified.",
        "Data transformations": "df[['O3 Value', 'PM10 Value']].dropna()",
        "Data transformation operation": [
            "select",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "across the monitored region, what is the distribution of records for good air quality",
        "Relevant data columns": [
            "Station",
            "Air Quality"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for a spatial distribution across the region or simply a count of records classified as 'Good' for each station.",
        "Ambiguity resolution": "Assume the query is asking for a count of records classified as 'Good' for each station, as no specific spatial data analysis tools or methods are mentioned.",
        "Data transformations": "df[df['Air Quality'] == 'Good'].groupby('Station').size()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "in the premier league how are the transferred players ages distributed",
        "Relevant data columns": [
            "Age",
            "League_to"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df = df[df['League_to'] == 'Premier League'][['Age']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me a reason why top backcourt players have a higher market value than the top frontcourt player",
        "Relevant data columns": [
            "Position",
            "Market_value"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The terms 'backcourt' and 'frontcourt' are not standard football terminology and are not explicitly defined in the dataset. It is unclear which positions are considered backcourt or frontcourt.",
        "Ambiguity resolution": "Assume 'backcourt' refers to defensive positions (e.g., Centre-Back) and 'frontcourt' to offensive positions (e.g., Centre-Forward). Group by these assumed categories to compare market values.",
        "Data transformations": "df['Position_Category'] = df['Position'].apply(lambda x: 'Backcourt' if 'Back' in x else 'Frontcourt'); grouped_df = df.groupby('Position_Category')['Market_value'].mean()",
        "Data transformation operation": [
            "map",
            "groupby",
            "aggregate"
        ],
        "New Column Name": "Position_Category",
        "Derivation Specification": "df['Position_Category'] = df['Position'].apply(lambda x: 'Backcourt' if 'Back' in x else 'Frontcourt')",
        "Missing Data Column": ""
    },
    {
        "query": "which player had an abnormal transfer_fee",
        "Relevant data columns": [
            "Name",
            "Transfer_fee"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'abnormal' is vague and does not specify what constitutes an abnormality in the context of transfer fees.",
        "Ambiguity resolution": "Assume abnormality in transfer fees to mean statistical outliers. Use a method like IQR or Z-score to identify outliers in the 'Transfer_fee' data.",
        "Data transformations": "Q1 = df['Transfer_fee'].quantile(0.25); Q3 = df['Transfer_fee'].quantile(0.75); IQR = Q3 - Q1; filter = (df['Transfer_fee'] < (Q1 - 1.5 * IQR)) | (df['Transfer_fee'] > (Q3 + 1.5 * IQR)); df[filter]",
        "Data transformation operation": [
            "quantile calculation",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how old was david when he was transferred in 2010",
        "Relevant data columns": [
            "Name",
            "Age",
            "Season"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "Multiple players named David were transferred in 2010, it is unclear which David is being referred to.",
        "Ambiguity resolution": "Specify which David is being referred to, or provide the age of all Davids transferred in 2010.",
        "Data transformations": "df[(df['Name'].str.contains('David')) & (df['Season']=='2010-2011')][['Name', 'Age']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what player had a market value of 50,000,000 and was transferred for 58,500,000 in the 2010-2011",
        "Relevant data columns": [
            "Name",
            "Market_value",
            "Transfer_fee",
            "Season"
        ],
        "Data column classification": [
            "inferred",
            "data value",
            "data value",
            "data value mention"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[(df['Market_value'] == 50000000) & (df['Transfer_fee'] == 58500000) & (df['Season'] == '2010-2011')][['Name']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "for the center forward position, what was the highest market value for the 2011-2012 season",
        "Relevant data columns": [
            "Position",
            "Market_value",
            "Season"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The dataset provided does not contain data for the 2011-2012 season.",
        "Ambiguity resolution": "Clarify with the user if they meant to ask for another season or if additional data for the 2011-2012 season is required.",
        "Data transformations": "df[df['Position'] == 'Centre-Forward'][['Position', 'Market_value', 'Season']].sort_values(by='Market_value', ascending=False).head(1)",
        "Data transformation operation": [
            "filter",
            "select",
            "sort",
            "retrieve top"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "2011-2012 season data"
    },
    {
        "query": "tell me the numbers of the transferred players in different leagues in the 2010 -2011 season",
        "Relevant data columns": [
            "League_to",
            "Season"
        ],
        "Data column classification": [
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Season']=='2010-2011'].groupby('League_to').size()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "could you buy a player with his market value higher than a transfer fee",
        "Relevant data columns": [
            "Market_value",
            "Transfer_fee"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Market_value'] > df['Transfer_fee']]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the average transfer_fee for players who transferred to the Premier League",
        "Relevant data columns": [
            "Transfer_fee",
            "League_to"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['League_to'] == 'Premier League']['Transfer_fee'].mean()",
        "Data transformation operation": [
            "filter",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "list center-backs by what their transfer_fee was",
        "Relevant data columns": [
            "Position",
            "Transfer_fee"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "sort"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Position'] == 'Centre-Back'].sort_values(by='Transfer_fee', ascending=False)",
        "Data transformation operation": [
            "filter",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which player was the oldest that was transferred",
        "Relevant data columns": [
            "Name",
            "Age"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Age'].idxmax(), ['Name', 'Age']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the distribution of the leagues who paid for transferred players in 2010",
        "Relevant data columns": [
            "League_to",
            "Season"
        ],
        "Data column classification": [
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for a count of transfers per league or the sum of transfer fees per league.",
        "Ambiguity resolution": "Assume the query is asking for the count of transfers per league.",
        "Data transformations": "df[df['Season'].str.contains('2010')]['League_to'].value_counts()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "are you aware of any clustering of the seasons in which players were transferred to the premier league",
        "Relevant data columns": [
            "Season",
            "League_to"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "cluster"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear what type of clustering is being asked for - temporal clustering by years, clustering by frequency of transfers, or clustering based on other attributes of the transfer such as transfer fee or market value.",
        "Ambiguity resolution": "Assume temporal clustering by seasons to identify any patterns or trends in the transfer data specifically to the Premier League.",
        "Data transformations": "premier_league_transfers = df[df['League_to'] == 'Premier League']; season_counts = premier_league_transfers['Season'].value_counts()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "do you feel that midfield players have a lower market value than front court players",
        "Relevant data columns": [
            "Position",
            "Market_value"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'front court players' is ambiguous as it is not a standard term in football. It is unclear if it refers to forwards or includes other positions like wingers.",
        "Ambiguity resolution": "Assume 'front court players' refers to forwards and possibly wingers. Compare market values of midfield players to these positions.",
        "Data transformations": "df['Position_Group'] = df['Position'].apply(lambda x: 'Midfield' if 'Midfield' in x else ('Forward' if 'Forward' in x or 'Winger' in x else 'Other')); midfield_value = df[df['Position_Group'] == 'Midfield']['Market_value'].mean(); forward_value = df[df['Position_Group'] == 'Forward']['Market_value'].mean()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "mean"
        ],
        "New Column Name": "Position_Group",
        "Derivation Specification": "df['Position_Group'] = df['Position'].apply(lambda x: 'Midfield' if 'Midfield' in x else ('Forward' if 'Forward' in x or 'Winger' in x else 'Other'))",
        "Missing Data Column": ""
    },
    {
        "query": "name movies released in 2017",
        "Relevant data columns": [
            "title",
            "release_year"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['release_year'] == 2017]['title']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is the normal distribution satisfied by the length of the movies",
        "Relevant data columns": [
            "duration"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify whether to consider all movies or a subset, and the format of the duration needs to be converted to a numerical value for analysis.",
        "Ambiguity resolution": "Assume analysis is for all movies. Convert duration from a string format to numerical minutes.",
        "Data transformations": "df['duration_numeric'] = df['duration'].str.extract('(\\d+)').astype(int)",
        "Data transformation operation": [
            "extract",
            "convert"
        ],
        "New Column Name": "duration_numeric",
        "Derivation Specification": "Extract numerical part from the 'duration' column and convert to integer",
        "Missing Data Column": ""
    },
    {
        "query": "sort the movies by length",
        "Relevant data columns": [
            "duration",
            "type"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The duration format includes units (min, Season), which complicates direct numerical sorting.",
        "Ambiguity resolution": "Convert duration to a uniform numeric format for sorting.",
        "Data transformations": "df['duration_numeric'] = df['duration'].apply(lambda x: int(x.split(' ')[0]) if 'min' in x else 0); df[df['type']=='Movie'].sort_values(by='duration_numeric', ascending=True)",
        "Data transformation operation": [
            "create new column",
            "filter",
            "sort"
        ],
        "New Column Name": "duration_numeric",
        "Derivation Specification": "df['duration_numeric'] = df['duration'].apply(lambda x: int(x.split(' ')[0]) if 'min' in x else 0)",
        "Missing Data Column": ""
    },
    {
        "query": "how long is the run time of average r-rated movies",
        "Relevant data columns": [
            "rating",
            "duration"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['rating'] == 'R']['duration'].mean()",
        "Data transformation operation": [
            "filter",
            "select",
            "average calculation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "give me the numbers of movies that were released in 2017",
        "Relevant data columns": [
            "type",
            "release_year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[(df['type'] == 'Movie') & (df['release_year'] == 2017)].shape[0]",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is there an average run time for movies",
        "Relevant data columns": [
            "duration",
            "type"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify if the average should be calculated for all movies or segmented by any other variable such as release year or genre.",
        "Ambiguity resolution": "Assume the average is to be calculated for all movies without segmentation.",
        "Data transformations": "df[df['type'] == 'Movie']['duration'].str.extract('(\\\\d+)').astype(int).mean()",
        "Data transformation operation": [
            "filter",
            "select",
            "extract",
            "convert",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is the running time of movies recently longer than it used to be",
        "Relevant data columns": [
            "duration",
            "release_year",
            "type"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "trend",
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify what 'recently' means in terms of years or the exact time frame to compare against.",
        "Ambiguity resolution": "Assume 'recently' to mean the last 5 years and compare it with the previous periods.",
        "Data transformations": "df['duration_min'] = df['duration'].str.extract('(\\\\d+)').astype(int); recent_df = df[(df['type'] == 'Movie') & (df['release_year'] >= df['release_year'].max() - 5)]; past_df = df[(df['type'] == 'Movie') & (df['release_year'] < df['release_year'].max() - 5)]; recent_avg_duration = recent_df['duration_min'].mean(); past_avg_duration = past_df['duration_min'].mean()",
        "Data transformation operation": [
            "filter",
            "select",
            "extract",
            "convert",
            "aggregate"
        ],
        "New Column Name": "duration_min",
        "Derivation Specification": "Extract numeric part from 'duration' column and convert to integer",
        "Missing Data Column": ""
    },
    {
        "query": "do movie tags and duration have a connection",
        "Relevant data columns": [
            "listed_in",
            "duration"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear how 'connection' is defined between movie tags and duration, whether it refers to statistical correlation, trends, or categorical associations.",
        "Ambiguity resolution": "Assume the query is asking for a statistical correlation between the number of tags (categories in 'listed_in') and the numerical value of duration.",
        "Data transformations": "df['num_tags'] = df['listed_in'].str.split(',').apply(len); df['duration_min'] = df['duration'].str.extract('(\\d+)').astype(int); correlation_result = df[['num_tags', 'duration_min']].corr()",
        "Data transformation operation": [
            "split",
            "count",
            "extract",
            "convert",
            "correlation"
        ],
        "New Column Name": "num_tags, duration_min",
        "Derivation Specification": "df['num_tags'] = df['listed_in'].str.split(',').apply(len); df['duration_min'] = df['duration'].str.extract('(\\d+)').astype(int)",
        "Missing Data Column": ""
    },
    {
        "query": "determine if the running time of movies has increased in recent years",
        "Relevant data columns": [
            "duration",
            "release_year",
            "type"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'recent years' is ambiguous as it does not specify the exact time range.",
        "Ambiguity resolution": "Assume a specific time range or use the last 10 years as a definition for 'recent years'.",
        "Data transformations": "df = df[df['type'] == 'Movie']; df['duration'] = df['duration'].str.extract('(\\\\d+)').astype(int); recent_df = df[df['release_year'] >= df['release_year'].max() - 10]",
        "Data transformation operation": [
            "filter",
            "extract",
            "convert",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me the dates that netflix released movies",
        "Relevant data columns": [
            "date_added",
            "type"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['type'] == 'Movie']['date_added'].dropna()",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "does any movies not have a description",
        "Relevant data columns": [
            "description"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['description'].isnull()]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "At what point was data added to the table for Netflix",
        "Relevant data columns": [
            "date_added"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for the specific date when data was first added, the range of dates, or the frequency of data addition.",
        "Ambiguity resolution": "Assuming the query asks for the first and last date data was added to the table, and possibly the frequency of updates.",
        "Data transformations": "df['date_added'].agg(['min', 'max']).append(df['date_added'].value_counts())",
        "Data transformation operation": [
            "aggregate",
            "value counts"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the percentage of the white population in blount county, alabama",
        "Relevant data columns": [
            "White",
            "County",
            "State"
        ],
        "Data column classification": [
            "keyword",
            "data value mention",
            "data value mention"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[(df['County']=='Blount County') & (df['State']=='Alabama')]['White']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what percentage of the Blount County, Alabama population is white",
        "Relevant data columns": [
            "County",
            "State",
            "White"
        ],
        "Data column classification": [
            "data value mention",
            "data value mention",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[(df['County']=='Blount County') & (df['State']=='Alabama')]['White']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "sort all the counties in connecticut by the percentages of the hispanic population",
        "Relevant data columns": [
            "County",
            "Hispanic",
            "State"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['State'] == 'Connecticut'][['County', 'Hispanic']].sort_values(by='Hispanic')",
        "Data transformation operation": [
            "filter",
            "select",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me which county has the greatest number of female residents",
        "Relevant data columns": [
            "County",
            "Women"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Women'].idxmax(), ['County', 'Women']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "calculate the average black population for each state",
        "Relevant data columns": [
            "State",
            "Black"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('State')['Black'].mean()",
        "Data transformation operation": [
            "groupby",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me the sales distribution of type 4046 in 2015",
        "Relevant data columns": [
            "4046",
            "year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df_2015_4046 = df[df['year'] == 2015]['4046']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what are the groups of regions according to three types of avocados sales ratio",
        "Relevant data columns": [
            "4046",
            "4225",
            "4770",
            "region"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "cluster"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear how the sales ratio is defined and how the groups should be formed based on these ratios.",
        "Ambiguity resolution": "Assume sales ratio as the proportion of each type's sales to the total sales per region. Group regions based on similar sales ratio distributions.",
        "Data transformations": "df['Total Sales'] = df['4046'] + df['4225'] + df['4770']; df['Ratio 4046'] = df['4046'] / df['Total Sales']; df['Ratio 4225'] = df['4225'] / df['Total Sales']; df['Ratio 4770'] = df['4770'] / df['Total Sales']; grouped_df = df.groupby('region')[['Ratio 4046', 'Ratio 4225', 'Ratio 4770']].mean()",
        "Data transformation operation": [
            "sum",
            "division",
            "groupby",
            "mean"
        ],
        "New Column Name": "Total Sales, Ratio 4046, Ratio 4225, Ratio 4770",
        "Derivation Specification": "Total Sales = 4046 + 4225 + 4770; Ratio 4046 = 4046 / Total Sales; Ratio 4225 = 4225 / Total Sales; Ratio 4770 = 4770 / Total Sales",
        "Missing Data Column": ""
    },
    {
        "query": "Using the three types of avocado's sales ratio, provide the groups of regions",
        "Relevant data columns": [
            "4046",
            "4225",
            "4770",
            "Total Volume",
            "region"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "cluster"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear how to group the regions based on the sales ratio of the three types of avocados.",
        "Ambiguity resolution": "Calculate the sales ratio for each type of avocado per region and then cluster regions based on these ratios.",
        "Data transformations": "df['Ratio_4046'] = df['4046'] / df['Total Volume']; df['Ratio_4225'] = df['4225'] / df['Total Volume']; df['Ratio_4770'] = df['4770'] / df['Total Volume']; grouped_df = df.groupby('region')[['Ratio_4046', 'Ratio_4225', 'Ratio_4770']].mean()",
        "Data transformation operation": [
            "calculation",
            "groupby",
            "mean"
        ],
        "New Column Name": "Ratio_4046, Ratio_4225, Ratio_4770",
        "Derivation Specification": "df['Ratio_4046'] = df['4046'] / df['Total Volume']; df['Ratio_4225'] = df['4225'] / df['Total Volume']; df['Ratio_4770'] = df['4770'] / df['Total Volume']",
        "Missing Data Column": ""
    },
    {
        "query": "provide the distribution of the sales in 2015 of type 4046",
        "Relevant data columns": [
            "4046",
            "year",
            "type"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df = df[(df['year'] == 2015) & (df['type'] == '4046')]; df[['4046']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "determine in what year the income of undergraduate students was higher",
        "Relevant data columns": [
            "Year",
            "Undergraduate Income"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain actual values for 'Undergraduate Income', all entries are NaN.",
        "Ambiguity resolution": "Assuming the dataset is updated with non-null values for 'Undergraduate Income', proceed with finding the year with the highest income.",
        "Data transformations": "df.dropna(subset=['Undergraduate Income']).loc[df['Undergraduate Income'].idxmax(), 'Year']",
        "Data transformation operation": [
            "dropna",
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how are postgraduate student numbers distributed every year",
        "Relevant data columns": [
            "Postgraduate",
            "Year"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The format of the 'Year' column is unclear and may need transformation to a standard date format for accurate yearly distribution analysis.",
        "Ambiguity resolution": "Convert the 'Year' column to a standard date format to ensure accurate distribution analysis.",
        "Data transformations": "df['Year'] = pd.to_datetime(df['Year'], format='%y-%b'); df[['Year', 'Postgraduate']]",
        "Data transformation operation": [
            "convert",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "could you tell me if there is any correlation between the number of undergraduate and postgraduate students",
        "Relevant data columns": [
            "Undergraduate",
            "Postgraduate"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Undergraduate', 'Postgraduate']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "state the average income of postgraduate students in each country",
        "Relevant data columns": [
            "Postgraduate Income",
            "Country"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The dataset contains NaN values for Postgraduate Income which may affect the calculation of the average income.",
        "Ambiguity resolution": "Handle NaN values appropriately, possibly by ignoring them or imputing them before calculating the average.",
        "Data transformations": "df.groupby('Country')['Postgraduate Income'].mean()",
        "Data transformation operation": [
            "groupby",
            "average calculation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the number of postgraduate students for each year",
        "Relevant data columns": [
            "Postgraduate",
            "Year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Year', 'Postgraduate']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "in each year, what is the distribution of the number of postgraduates",
        "Relevant data columns": [
            "Year",
            "Postgraduate"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Year', 'Postgraduate']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "do you know which videos have more than 100 tags",
        "Relevant data columns": [
            "tags"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear how tags are separated or counted in the dataset, which affects how to determine if there are more than 100 tags.",
        "Ambiguity resolution": "Assume tags are separated by '|' and count the number of separators to determine the number of tags.",
        "Data transformations": "df['tag_count'] = df['tags'].str.count('\\|') + 1; df[df['tag_count'] > 100]",
        "Data transformation operation": [
            "count",
            "filter"
        ],
        "New Column Name": "tag_count",
        "Derivation Specification": "df['tag_count'] = df['tags'].str.count('\\|') + 1",
        "Missing Data Column": ""
    },
    {
        "query": "in the videos by \"eminemvevo\", what are the average number of comments made",
        "Relevant data columns": [
            "channel_title",
            "comment_count"
        ],
        "Data column classification": [
            "data value mention",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['channel_title'] == 'eminemvevo']['comment_count'].mean()",
        "Data transformation operation": [
            "filter",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    null,
    {
        "query": "which videos are missing thumbnail links",
        "Relevant data columns": [
            "thumbnail_link"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['thumbnail_link'].isna()]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    null,
    null,
    null,
    {
        "query": "show me the video with the highest number of tags",
        "Relevant data columns": [
            "tags",
            "title"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear whether the count of unique tags or the total number of tag occurrences is required.",
        "Ambiguity resolution": "Assume the count of unique tags is required.",
        "Data transformations": "df['tag_count'] = df['tags'].apply(lambda x: len(x.split('|'))); df.loc[df['tag_count'].idxmax(), ['title', 'tags']]",
        "Data transformation operation": [
            "transform",
            "filter",
            "select"
        ],
        "New Column Name": "tag_count",
        "New Column Derivation": "df['tag_count'] = df['tags'].apply(lambda x: len(x.split('|')))",
        "Missing Data Column": ""
    },
    {
        "query": "indicate the number of likes that \"plush - bad unboxing fan mail\" receives",
        "Relevant data columns": [
            "title",
            "likes"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The exact title match for 'plush - bad unboxing fan mail' needs to be confirmed as it may not be exact or may vary slightly.",
        "Ambiguity resolution": "Use string matching techniques to find the closest match to the title in the dataset.",
        "Data transformations": "df[df['title'].str.contains('plush - bad unboxing fan mail', case=False, na=False)]['likes']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the number if likes from the \" plush - bad unboxing fan mail \" video",
        "Relevant data columns": [
            "title",
            "likes"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The title mentioned does not exactly match any video titles in the dataset, which may lead to confusion about which video's likes are being queried.",
        "Ambiguity resolution": "Use a string matching or search technique to find the closest match to the title in the dataset.",
        "Data transformations": "df[df['title'].str.contains('plush - bad unboxing fan mail', case=False, na=False)]['likes']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "discover the most liked removed video",
        "Relevant data columns": [
            "likes",
            "video_error_or_removed"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['video_error_or_removed'] == True][['title', 'likes']].sort_values(by='likes', ascending=False).head(1)",
        "Data transformation operation": [
            "filter",
            "select",
            "sort",
            "retrieve top"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "are there are special characters included in the title",
        "Relevant data columns": [
            "title"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear what is considered a 'special character' in the context of the dataset.",
        "Ambiguity resolution": "Define 'special characters' as any non-alphanumeric character excluding spaces.",
        "Data transformations": "df['Special Characters'] = df['title'].apply(lambda x: any(not c.isalnum() and not c.isspace() for c in x))",
        "Data transformation operation": [
            "apply"
        ],
        "New Column Name": "Special Characters",
        "Derivation Specification": "df['Special Characters'] = df['title'].apply(lambda x: any(not c.isalnum() and not c.isspace() for c in x))",
        "Missing Data Column": ""
    },
    {
        "query": "do videos with longer titles get more attention",
        "Relevant data columns": [
            "title",
            "views",
            "likes",
            "dislikes",
            "comment_count"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear what 'more attention' specifically refers to - views, likes, dislikes, comments, or a combination of these.",
        "Ambiguity resolution": "Assume 'more attention' refers to a combination of views, likes, dislikes, and comments. Calculate a new metric 'total engagement' as the sum of these factors.",
        "Data transformations": "df['title_length'] = df['title'].apply(len); df['total_engagement'] = df['views'] + df['likes'] + df['dislikes'] + df['comment_count']; df[['title_length', 'total_engagement']]",
        "Data transformation operation": [
            "new column creation",
            "sum"
        ],
        "New Column Name": "total_engagement",
        "Derivation Specification": "df['total_engagement'] = df['views'] + df['likes'] + df['dislikes'] + df['comment_count']",
        "Missing Data Column": ""
    },
    {
        "query": "tell me about the 'plush - bad unboxing fan mail' video",
        "Relevant data columns": [
            "title"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify which attributes of the video are of interest, such as views, likes, dislikes, etc.",
        "Ambiguity resolution": "Assume all relevant video attributes are required.",
        "Data transformations": "df[df['title'].str.contains('plush - bad unboxing fan mail', case=False, na=False)]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you show me how the likes are distributed",
        "Relevant data columns": [
            "likes"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['likes']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what differences are there among the students who acquired more than 270 points between 2010 -2019",
        "Relevant data columns": [
            "Total Points",
            "First Name",
            "Last Name"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "filter",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The dataset does not contain a column for the year, making it impossible to filter data between 2010 - 2019.",
        "Ambiguity resolution": "Assume all data is relevant for the period 2010-2019 or request clarification on the dataset's timeframe.",
        "Data transformations": "df[df['Total Points'] > 270][['First Name', 'Last Name', 'Total Points']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Year"
    },
    {
        "query": "tell me all of the categories of grade types",
        "Relevant data columns": [
            "Grade"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Grade'].unique()",
        "Data transformation operation": [
            "select",
            "unique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "use the midterm exam and final exam as the 2nd and 1st keywords respectively in order to assign a rank to every one of the students",
        "Relevant data columns": [
            "Mid-term exams",
            "Final exam"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the ranking should be based on the numeric value of the scores or the percentage as a string needs conversion.",
        "Ambiguity resolution": "Convert percentage strings to numeric values before ranking.",
        "Data transformations": "df['Mid-term exams'] = df['Mid-term exams'].str.rstrip('%').astype(int); df['Final exam'] = df['Final exam'].str.rstrip('%').astype(int); df['Rank'] = df[['Final exam', 'Mid-term exams']].apply(tuple, axis=1).rank(method='dense', ascending=False)",
        "Data transformation operation": [
            "convert",
            "rank"
        ],
        "New Column Name": "Rank",
        "Derivation Specification": "df['Rank'] = df[['Final exam', 'Mid-term exams']].apply(tuple, axis=1).rank(method='dense', ascending=False)",
        "Missing Data Column": ""
    },
    {
        "query": "what did the majority of students receive as a grade",
        "Relevant data columns": [
            "Grade"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if 'majority' refers to a simple majority (more than 50%) or just the most common grade.",
        "Ambiguity resolution": "Assume 'majority' refers to the mode, or most frequently occurring grade.",
        "Data transformations": "df['Grade'].mode()",
        "Data transformation operation": [
            "mode"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "use the final exam as the first keyword and midterm exam as the second keyword to rank all the students",
        "Relevant data columns": [
            "Final exam",
            "Mid-term exams"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the ranking should be done in ascending or descending order, and how to handle percentage values for ranking.",
        "Ambiguity resolution": "Assume descending order for ranking as higher exam scores typically indicate better performance. Convert percentage strings to numerical values for accurate ranking.",
        "Data transformations": "df['Final exam'] = df['Final exam'].str.rstrip('%').astype(float); df['Mid-term exams'] = df['Mid-term exams'].str.rstrip('%').astype(float); df.sort_values(by=['Final exam', 'Mid-term exams'], ascending=[False, False])",
        "Data transformation operation": [
            "convert",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me the scope, among all the students, of the cw2 score",
        "Relevant data columns": [
            "CW 2"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'scope' is ambiguous and could refer to the range, distribution, or general statistics of CW 2 scores.",
        "Ambiguity resolution": "Assume 'scope' refers to the distribution of scores, including range and basic statistics.",
        "Data transformations": "df['CW 2'] = df['CW 2'].str.rstrip('%').astype(int); df['CW 2'].describe()",
        "Data transformation operation": [
            "convert",
            "summarize"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "in cw1, how many students achieved the feat of 100%, or full marks",
        "Relevant data columns": [
            "CW 1"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['CW 1'] == '100%'].count()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "rank the grades from highest to lowest according to the average score",
        "Relevant data columns": [
            "Grade",
            "Student\nAverage"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.sort_values(by='Student\\nAverage', ascending=False)[['Grade', 'Student\\nAverage']]",
        "Data transformation operation": [
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me the median score of the cw1 class",
        "Relevant data columns": [
            "CW 1"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['CW 1'] = df['CW 1'].str.rstrip('%').astype(int); median_cw1 = df['CW 1'].median()",
        "Data transformation operation": [
            "convert",
            "calculate median"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "do you know the median score of all students in cw1",
        "Relevant data columns": [
            "CW 1"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['CW 1'] = df['CW 1'].str.rstrip('%').astype(int); median_cw1 = df['CW 1'].median()",
        "Data transformation operation": [
            "convert",
            "calculate median"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how many students received an a",
        "Relevant data columns": [
            "Grade"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Grade'].str.upper().str.strip() == 'A'].count()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "select all cw1 scores not less than 80%",
        "Relevant data columns": [
            "CW 1"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['CW 1'].str.rstrip('%').astype(int) >= 80]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "arrange the students by grade and furnish me with a list",
        "Relevant data columns": [
            "Grade"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "sort",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "sorted_df = df.sort_values(by='Grade')",
        "Data transformation operation": [
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the distribution of the total points of the students",
        "Relevant data columns": [
            "Total Points"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Total Points']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "was the same midterm exam given to velma paul and glynis caine",
        "Relevant data columns": [
            "First Name",
            "Last Name",
            "Mid-term exams"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "Glynis Caine is not listed in the provided dataset, making it unclear how to compare with Velma Paul.",
        "Ambiguity resolution": "Check for the presence of Glynis Caine in the dataset and compare only if present.",
        "Data transformations": "df[df['First Name'].isin(['Velma', 'Glynis']) & df['Last Name'].isin(['Paul', 'Caine'])][['First Name', 'Last Name', 'Mid-term exams']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Glynis Caine"
    },
    {
        "query": "provide the total sum of all the separated, divorced, and widowed people in Lindi",
        "Relevant data columns": [
            "Separated",
            "Divorced",
            "Widowed",
            "Regions"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset provided does not include a row for 'Lindi', which is mentioned in the query.",
        "Ambiguity resolution": "Check for alternative spellings or related regions in the dataset that might correspond to 'Lindi'. If none, the query cannot be resolved with the current dataset.",
        "Data transformations": "df[df['Regions'] == 'Lindi'][['Separated', 'Divorced', 'Widowed']].sum(axis=1)",
        "Data transformation operation": [
            "filter",
            "select",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Lindi"
    },
    {
        "query": "does simiyu have a similar structure of people as that of katavi",
        "Relevant data columns": [
            "Regions",
            "Never Married",
            "Married",
            "Living Together",
            "Separated",
            "Divorced",
            "Widowed"
        ],
        "Data column classification": [
            "data value mention",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "similarity"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "Simiyu and Katavi are not listed in the provided dataset, making it unclear how to perform the comparison.",
        "Ambiguity resolution": "Verify the presence of Simiyu and Katavi in the dataset or obtain additional data including these regions.",
        "Data transformations": "df[df['Regions'].isin(['Simiyu', 'Katavi'])]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Simiyu, Katavi"
    },
    {
        "query": "can you tell me how mara attributes are distributed",
        "Relevant data columns": [
            "Regions"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query mentions 'mara attributes' which is unclear. It is ambiguous whether 'mara' refers to a specific region or a type of attribute within the dataset.",
        "Ambiguity resolution": "Assume 'mara' refers to a region and check if it exists in the dataset. If not, clarify with the user or provide distributions for all regions.",
        "Data transformations": "df[df['Regions'].str.contains('Mara', na=False)]",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Mara"
    },
    {
        "query": "is the total attribute of one area equal to the sum of the other attributes in any area",
        "Relevant data columns": [
            "Total",
            "Never Married",
            "Married",
            "Living Together",
            "Separated",
            "Divorced",
            "Widowed"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking to check this condition for all areas or just any one specific area.",
        "Ambiguity resolution": "Assume the query asks to check for all areas and verify if the 'Total' column equals the sum of all other marital status columns for each area.",
        "Data transformations": "df['Calculated Total'] = df['Never Married'] + df['Married'] + df['Living Together'] + df['Separated'] + df['Divorced'] + df['Widowed']; df['Total Match'] = df['Total'] == df['Calculated Total']",
        "Data transformation operation": [
            "sum",
            "comparison"
        ],
        "New Column Name": "Calculated Total, Total Match",
        "Derivation Specification": "df['Calculated Total'] = df['Never Married'] + df['Married'] + df['Living Together'] + df['Separated'] + df['Divorced'] + df['Widowed']; df['Total Match'] = df['Total'] == df['Calculated Total']",
        "Missing Data Column": ""
    },
    {
        "query": "can you see any abnormalities in the suicide rates",
        "Relevant data columns": [
            "suicides_no",
            "population",
            "suicides/100k pop"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'abnormalities' is vague and could refer to statistical outliers, trends, or unexpected values in the data.",
        "Ambiguity resolution": "Assume 'abnormalities' refers to statistical outliers in the suicide rates per 100k population. Calculate the interquartile range and identify values outside this range.",
        "Data transformations": "q1 = df['suicides/100k pop'].quantile(0.25); q3 = df['suicides/100k pop'].quantile(0.75); iqr = q3 - q1; lower_bound = q1 - 1.5 * iqr; upper_bound = q3 + 1.5 * iqr; outliers_df = df[(df['suicides/100k pop'] < lower_bound) | (df['suicides/100k pop'] > upper_bound)][['country', 'year', 'sex', 'age', 'suicides/100k pop']]",
        "Data transformation operation": [
            "quantile calculation",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "name the country with the lowest suicide rate",
        "Relevant data columns": [
            "country",
            "suicides/100k pop"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the lowest suicide rate should be calculated for a specific year, age group, or sex, or if it should be averaged across all available data.",
        "Ambiguity resolution": "Calculate the average suicide rate across all years, age groups, and sexes for each country to determine the country with the overall lowest rate.",
        "Data transformations": "df.groupby('country')['suicides/100k pop'].mean().idxmin()",
        "Data transformation operation": [
            "groupby",
            "aggregate",
            "index minimum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "do you know the average number of suicides in europe",
        "Relevant data columns": [
            "suicides_no",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not specify which countries are in Europe, requiring additional data to classify countries by continent.",
        "Ambiguity resolution": "Merge dataset with a list of European countries to filter the data before calculating the average.",
        "Data transformations": "european_countries = ['list', 'of', 'European', 'countries']; df_europe = df[df['country'].isin(european_countries)]; avg_suicides = df_europe['suicides_no'].mean()",
        "Data transformation operation": [
            "filter",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "are there any countries with anomalously low suicides rates",
        "Relevant data columns": [
            "country",
            "suicides/100k pop"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'anomalously low' is not quantitatively defined, making it unclear what threshold should be used to determine low suicide rates.",
        "Ambiguity resolution": "Define a specific threshold for 'anomalously low' suicide rates or calculate statistical metrics such as mean and standard deviation to identify outliers.",
        "Data transformations": "threshold = df['suicides/100k pop'].mean() - (2 * df['suicides/100k pop'].std()); low_suicide_rates = df[df['suicides/100k pop'] < threshold]",
        "Data transformation operation": [
            "calculate mean",
            "calculate standard deviation",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Is there similarities between gdp per capita and suicide rates",
        "Relevant data columns": [
            "gdp_per_capita ($)",
            "suicides/100k pop"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate",
            "similarity"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify if the correlation should be analyzed over time, by country, or across different age or sex groups.",
        "Ambiguity resolution": "Assume the correlation is to be analyzed across the entire dataset without grouping by time, country, age, or sex unless specified.",
        "Data transformations": "df[['gdp_per_capita ($)', 'suicides/100k pop']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "were there any countries with abnormally low suicide rates",
        "Relevant data columns": [
            "country",
            "suicides/100k pop"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'abnormally low' is subjective and not quantitatively defined.",
        "Ambiguity resolution": "Define a threshold for 'abnormally low' suicide rates, such as rates below the 10th percentile.",
        "Data transformations": "threshold = df['suicides/100k pop'].quantile(0.1); low_suicide_rates = df[df['suicides/100k pop'] <= threshold]",
        "Data transformation operation": [
            "quantile",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "with the suicide larger than 100, determine the ages in Albania",
        "Relevant data columns": [
            "suicides_no",
            "age",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "data value mention"
        ],
        "Low-level visualization task": [
            "filter",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if the query is asking for specific years or all years combined when considering suicides larger than 100.",
        "Ambiguity resolution": "Assume the query is asking for any year where suicides are greater than 100 in Albania, without aggregating data across years.",
        "Data transformations": "df = df[(df['country'] == 'Albania') & (df['suicides_no'] > 100)][['age', 'year', 'suicides_no']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "the country with the lowest suicide rate is",
        "Relevant data columns": [
            "country",
            "suicides/100k pop"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for the lowest suicide rate for a specific year or the lowest average suicide rate across all years.",
        "Ambiguity resolution": "Calculate the average suicide rate across all years for each country and then find the country with the lowest average rate.",
        "Data transformations": "df.groupby('country')['suicides/100k pop'].mean().idxmin()",
        "Data transformation operation": [
            "groupby",
            "mean",
            "index of minimum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the distribution rate of suicide",
        "Relevant data columns": [
            "suicides/100k pop"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear if the distribution should be analyzed over different years, countries, or demographic groups such as age or sex.",
        "Ambiguity resolution": "Assume a general distribution analysis across the entire dataset without breaking down by other factors unless specified.",
        "Data transformations": "df[['suicides/100k pop']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the total number of all suicides in 1999",
        "Relevant data columns": [
            "suicides_no",
            "year"
        ],
        "Data column classification": [
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['year'] == 1999]['suicides_no'].sum()",
        "Data transformation operation": [
            "filter",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Would there be any clustering of countries in terms of suicide rates",
        "Relevant data columns": [
            "country",
            "suicides/100k pop"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "cluster"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify the criteria or features to be used for clustering, such as whether to use raw suicide rates, normalized rates, or additional socioeconomic factors like GDP.",
        "Ambiguity resolution": "Assume clustering based on average suicide rates per 100k population across all available years for simplicity unless further specified.",
        "Data transformations": "df.groupby('country')['suicides/100k pop'].mean().reset_index()",
        "Data transformation operation": [
            "groupby",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "create a list showing the ages of people who committed suicide in Albania",
        "Relevant data columns": [
            "age",
            "country",
            "suicides_no"
        ],
        "Data column classification": [
            "keyword",
            "data value mention",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for a list of unique age groups or all instances including duplicates where suicides occurred.",
        "Ambiguity resolution": "Assuming the query asks for unique age groups where suicides have been recorded.",
        "Data transformations": "df = df[(df['country'] == 'Albania') & (df['suicides_no'] > 0)]; unique_ages = df['age'].unique()",
        "Data transformation operation": [
            "filter",
            "select",
            "unique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "for the gdp of china, has it gone up or down over the last decade",
        "Relevant data columns": [
            "gdp_for_year ($)",
            "year",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset provided does not contain data for China, only for Albania as shown in the example entries.",
        "Ambiguity resolution": "Check if the dataset contains data for China or use an alternative dataset that includes GDP data for China.",
        "Data transformations": "df[df['country'] == 'China'][['year', 'gdp_for_year ($)']].sort_values('year')",
        "Data transformation operation": [
            "filter",
            "select",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "China data"
    },
    {
        "query": "Of all countries, how is the GDP distribution",
        "Relevant data columns": [
            "gdp_per_capita ($)"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear if the distribution should be considered for each year or aggregated across all years.",
        "Ambiguity resolution": "Assume an aggregation across all years to find overall GDP distribution unless specified otherwise.",
        "Data transformations": "df.groupby('country')['gdp_per_capita ($)'].mean()",
        "Data transformation operation": [
            "groupby",
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "has there been an increase or decrease in the gdp of china over the last 10 years",
        "Relevant data columns": [
            "gdp_for_year ($)",
            "year",
            "country"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "data value mention"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The dataset provided does not contain data for China, only for Albania as shown in the example entries.",
        "Ambiguity resolution": "Check if the dataset contains data for China before proceeding. If not, the query cannot be resolved with the current dataset.",
        "Data transformations": "df[df['country'] == 'China'][['year', 'gdp_for_year ($)']].sort_values('year').tail(10)",
        "Data transformation operation": [
            "filter",
            "select",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "China data"
    },
    {
        "query": "I want to see the distribution of the school rankings in Geita in 2006",
        "Relevant data columns": [
            "RANK",
            "REGION",
            "YEAR_OF_RESULT"
        ],
        "Data column classification": [
            "keyword",
            "data value mention",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The year mentioned in the query (2006) does not match the year available in the dataset (2016).",
        "Ambiguity resolution": "Assuming the year 2016 as the correct year for analysis since it is the only year present in the dataset.",
        "Data transformations": "df = df[(df['REGION'] == 'GEITA') & (df['YEAR_OF_RESULT'] == 2016)][['RANK']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "do the pass rate and the ownership of schools have any correlation",
        "Relevant data columns": [
            "PASS_RATE",
            "OWNERSHIP"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['PASS_RATE', 'OWNERSHIP']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "create a list of schools showing the descending order by change_p",
        "Relevant data columns": [
            "NAME",
            "CHANGE_PREVIOUS_YEAR"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The column 'change_p' is not explicitly mentioned in the dataset. It is likely referring to 'CHANGE_PREVIOUS_YEAR'.",
        "Ambiguity resolution": "Assume 'change_p' refers to 'CHANGE_PREVIOUS_YEAR' for sorting.",
        "Data transformations": "df[['NAME', 'CHANGE_PREVIOUS_YEAR']].sort_values(by='CHANGE_PREVIOUS_YEAR', ascending=False)",
        "Data transformation operation": [
            "select",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you provide a list of school names in geita",
        "Relevant data columns": [
            "NAME",
            "REGION"
        ],
        "Data column classification": [
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['REGION'] == 'GEITA']['NAME']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "determine if there are any schools in neighboring regions that have similar avg_m",
        "Relevant data columns": [
            "NAME",
            "REGION",
            "AVG_MARK"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "synonym"
        ],
        "Low-level visualization task": [
            "similarity",
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what constitutes 'similar' average marks or how close regions need to be to be considered 'neighboring'.",
        "Ambiguity resolution": "Define a threshold for similarity in average marks and specify criteria for neighboring regions.",
        "Data transformations": "df['Similar AVG_MARK'] = df.groupby('REGION')['AVG_MARK'].transform(lambda x: abs(x - x.mean()) < x.std())",
        "Data transformation operation": [
            "groupby",
            "transform"
        ],
        "New Column Name": "Similar AVG_MARK",
        "Derivation Specification": "df['Similar AVG_MARK'] = df.groupby('REGION')['AVG_MARK'].transform(lambda x: abs(x - x.mean()) < x.std())",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me what peacland english medium school 's change pre is in 2016",
        "Relevant data columns": [
            "NAME",
            "CHANGE_PREVIOUS_YEAR",
            "YEAR_OF_RESULT"
        ],
        "Data column classification": [
            "data value mention",
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[(df['NAME'] == 'PEACLAND ENGLISH MEDIUM SCHOOL') & (df['YEAR_OF_RESULT'] == 2016)]['CHANGE_PREVIOUS_YEAR']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "list the values of kwema modern pr  school 's change_p in all the years",
        "Relevant data columns": [
            "CHANGE_PREVIOUS_YEAR",
            "NAME",
            "YEAR_OF_RESULT"
        ],
        "Data column classification": [
            "synonym",
            "data value mention",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query mentions 'change_p' which seems to be a shorthand or typo for 'CHANGE_PREVIOUS_YEAR'. It is also unclear if data for multiple years is available for 'KWEMA MODERN PR. SCHOOL' as the dataset only shows the year 2016.",
        "Ambiguity resolution": "Assuming 'change_p' refers to 'CHANGE_PREVIOUS_YEAR'. Need to check if there are multiple entries for 'KWEMA MODERN PR. SCHOOL' across different years or if the dataset is limited to 2016.",
        "Data transformations": "df[df['NAME'] == 'KWEMA MODERN PR. SCHOOL'][['NAME', 'YEAR_OF_RESULT', 'CHANGE_PREVIOUS_YEAR']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what schools have similar avg_m in the neighboring region",
        "Relevant data columns": [
            "AVG_MARK",
            "REGION"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "similarity",
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'similar' is vague without a specific range or criteria for similarity. Additionally, 'neighboring region' is ambiguous without a clear definition of which regions are considered neighbors.",
        "Ambiguity resolution": "Define a specific range for similarity, e.g., within 5 marks. Define neighboring regions based on geographical proximity or administrative boundaries.",
        "Data transformations": "df['Neighboring Regions'] = df.apply(lambda x: neighboring_regions_function(x['REGION']), axis=1); similar_schools = df[df.apply(lambda x: any(df[(df['REGION'].isin(x['Neighboring Regions'])) & (abs(df['AVG_MARK'] - x['AVG_MARK']) <= 5)].index), axis=1)]",
        "Data transformation operation": [
            "apply",
            "filter",
            "comparison"
        ],
        "New Column Name": "Neighboring Regions",
        "Derivation Specification": "df['Neighboring Regions'] = df.apply(lambda x: neighboring_regions_function(x['REGION']), axis=1)",
        "Missing Data Column": ""
    },
    {
        "query": "which of these school have a pass rate of over 90",
        "Relevant data columns": [
            "NAME",
            "PASS_RATE"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['PASS_RATE'] > 90][['NAME', 'PASS_RATE']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the average height of the floors of these buildings",
        "Relevant data columns": [
            "Meters",
            "Stories"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Average Floor Height'] = df['Meters'] / df['Stories']",
        "Data transformation operation": [
            "division"
        ],
        "New Column Name": "Average Floor Height",
        "Derivation Specification": "df['Average Floor Height'] = df['Meters'] / df['Stories']",
        "Missing Data Column": ""
    },
    {
        "query": "compare the number of tall buildings in hong kong with taiwan",
        "Relevant data columns": [
            "Country/Region",
            "name"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "hk_buildings = df[df['Country/Region'].str.contains('Hong Kong')].shape[0]; tw_buildings = df[df['Country/Region'].str.contains('Taiwan')].shape[0]",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what location has the highest number of tall buildings",
        "Relevant data columns": [
            "Building/City"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if 'location' refers to 'Building/City' or 'Country/Region'.",
        "Ambiguity resolution": "Assume 'location' refers to 'Building/City' as it is the more specific geographic identifier.",
        "Data transformations": "df['Building/City'].value_counts().idxmax()",
        "Data transformation operation": [
            "count",
            "find maximum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "the oldest user was born in what year",
        "Relevant data columns": [
            "birthyear"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['birthyear'].min()",
        "Data transformation operation": [
            "min"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "indicate all the travels taking more than 1000 minutes",
        "Relevant data columns": [
            "tripduration"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The tripduration data appears to be in inconsistent formats, some entries are in a comma-separated format which might be interpreted incorrectly.",
        "Ambiguity resolution": "Convert all tripduration entries to a consistent numeric format before filtering.",
        "Data transformations": "df['tripduration'] = df['tripduration'].replace(',', '', regex=True).astype(float); filtered_df = df[df['tripduration'] > 1000]",
        "Data transformation operation": [
            "convert",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me a list of the trips that take longer than 1,000 minutes",
        "Relevant data columns": [
            "tripduration"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The tripduration data contains commas and periods which might be interpreted differently depending on the locale or format settings.",
        "Ambiguity resolution": "Standardize the tripduration format to a consistent numeric format without commas, ensuring all values are interpreted as minutes.",
        "Data transformations": "df['tripduration'] = df['tripduration'].replace({',': ''}, regex=True).astype(float); filtered_df = df[df['tripduration'] > 1000]",
        "Data transformation operation": [
            "replace",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me the distribution of travel times between wells st & elm st and lake shore dr & ohio st",
        "Relevant data columns": [
            "tripduration",
            "from_station_name",
            "to_station_name"
        ],
        "Data column classification": [
            "inferred",
            "data value mention",
            "data value mention"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The format of tripduration needs clarification whether it's in seconds or minutes, and whether it includes outliers or extreme values.",
        "Ambiguity resolution": "Assume tripduration is in seconds and filter out any extreme durations or incorrect formats for a more accurate distribution.",
        "Data transformations": "df_filtered = df[(df['from_station_name'] == 'Wells St & Elm St') & (df['to_station_name'] == 'Lake Shore Dr & Ohio St') | (df['from_station_name'] == 'Lake Shore Dr & Ohio St') & (df['to_station_name'] == 'Wells St & Elm St')]; df_filtered['tripduration'] = df_filtered['tripduration'].replace(',', '', regex=True).astype(float); df_filtered = df_filtered[df_filtered['tripduration'] < df_filtered['tripduration'].quantile(0.95)]",
        "Data transformation operation": [
            "filter",
            "replace",
            "type conversion",
            "quantile filtering"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "show me the relationship between age and travel time",
        "Relevant data columns": [
            "birthyear",
            "tripduration"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The 'tripduration' column contains values with commas and may not be in a consistent numeric format. Additionally, 'birthyear' needs to be converted to age.",
        "Ambiguity resolution": "Convert 'tripduration' to a consistent numeric format and calculate age from 'birthyear'.",
        "Data transformations": "df['tripduration'] = df['tripduration'].replace(',', '', regex=True).astype(float); df['Age'] = 2023 - df['birthyear'].dropna().astype(int); df[['Age', 'tripduration']]",
        "Data transformation operation": [
            "replace",
            "type conversion",
            "calculate new column",
            "select"
        ],
        "New Column Name": "Age",
        "Derivation Specification": "2023 - df['birthyear']",
        "Missing Data Column": ""
    },
    {
        "query": "do you know of any trip that would take longer than 1000 minutes",
        "Relevant data columns": [
            "tripduration"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The tripduration data contains commas and may be in different units (seconds or minutes).",
        "Ambiguity resolution": "Assume tripduration is in seconds, convert to minutes for comparison.",
        "Data transformations": "df['tripduration'] = df['tripduration'].str.replace(',', '').astype(float); df[df['tripduration'] > 1000 * 60]",
        "Data transformation operation": [
            "convert",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which position has the highest average of playing time",
        "Relevant data columns": [
            "Pos",
            "MPG"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum",
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('Pos')['MPG'].mean().idxmax()",
        "Data transformation operation": [
            "groupby",
            "mean",
            "index of max"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "if you were to average it out, how upbeat would you say the songs are",
        "Relevant data columns": [
            "Beats.Per.Minute",
            "Valence."
        ],
        "Data column classification": [
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'upbeat' is ambiguous as it could refer to either the tempo (Beats.Per.Minute) or the mood (Valence.) of the songs, or both.",
        "Ambiguity resolution": "Calculate the average of both 'Beats.Per.Minute' and 'Valence.' to cover both interpretations of 'upbeat'.",
        "Data transformations": "df[['Beats.Per.Minute', 'Valence.']].mean()",
        "Data transformation operation": [
            "select",
            "average"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "describe the popularity of the loudest song",
        "Relevant data columns": [
            "Popularity",
            "Loudness..dB.."
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Loudness..dB..'].idxmax(), ['Loudness..dB..', 'Popularity']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you help me find some popular songs",
        "Relevant data columns": [
            "Popularity",
            "Track.Name"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify what threshold defines 'popular'.",
        "Ambiguity resolution": "Assume a popularity threshold or use a statistical measure like mean or median to define 'popular'.",
        "Data transformations": "popular_songs = df[df['Popularity'] >= df['Popularity'].mean()][['Track.Name', 'Popularity']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "in terms of length, how long is 'Beautiful People'",
        "Relevant data columns": [
            "Track.Name",
            "Length."
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Track.Name'] == 'Beautiful People (feat. Khalid)']['Length.']",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me which genres were mentioned",
        "Relevant data columns": [
            "Genre"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['Genre'].unique()",
        "Data transformation operation": [
            "select",
            "unique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what songs of the pop genre has Sam Smith released",
        "Relevant data columns": [
            "Track.Name",
            "Artist.Name",
            "Genre"
        ],
        "Data column classification": [
            "inferred",
            "data value mention",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['Artist.Name'] == 'Sam Smith'][df['Genre'] == 'pop'][['Track.Name', 'Artist.Name', 'Genre']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "are there singers who span multiple genres",
        "Relevant data columns": [
            "Artist.Name",
            "Genre"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "cluster"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify if it is looking for artists who span multiple genres within this dataset or across their entire career, which might not be fully represented in this dataset.",
        "Ambiguity resolution": "Assume the query is asking about the diversity of genres for each artist within the provided dataset.",
        "Data transformations": "df.groupby('Artist.Name')['Genre'].nunique().reset_index()",
        "Data transformation operation": [
            "groupby",
            "nunique"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "When the score difference is more than 5, please list the extreme matches to this",
        "Relevant data columns": [
            "home_score",
            "away_score",
            "home_team",
            "away_team",
            "date"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "filter",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The term 'extreme matches' is ambiguous. It is unclear whether it refers to matches with the highest score differences or just any match where the score difference exceeds 5.",
        "Ambiguity resolution": "Assume 'extreme matches' refers to any match where the score difference is more than 5.",
        "Data transformations": "df['score_difference'] = (df['home_score'] - df['away_score']).abs(); extreme_matches_df = df[df['score_difference'] > 5][['date', 'home_team', 'away_team', 'home_score', 'away_score']]",
        "Data transformation operation": [
            "new column creation",
            "filter",
            "select"
        ],
        "New Column Name": "score_difference",
        "Derivation Specification": "df['score_difference'] = (df['home_score'] - df['away_score']).abs()",
        "Missing Data Column": ""
    },
    {
        "query": "please indicate the friendly tournament matches in which the home team beat the away team",
        "Relevant data columns": [
            "tournament",
            "home_team",
            "away_team",
            "home_score",
            "away_score"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter",
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[(df['tournament'] == 'Friendly') & (df['home_score'] > df['away_score'])][['date', 'home_team', 'away_team', 'home_score', 'away_score', 'city', 'country']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "tell me all the tournament matches that the home team won against the away team",
        "Relevant data columns": [
            "home_team",
            "away_team",
            "home_score",
            "away_score",
            "tournament"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[df['home_score'] > df['away_score']][['tournament', 'home_team', 'away_team', 'home_score', 'away_score']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "which group of nations won the most games",
        "Relevant data columns": [
            "home_team",
            "away_team",
            "home_score",
            "away_score"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear what constitutes a 'group of nations'. Does it refer to geographical regions, alliances, or simply individual countries grouped together?",
        "Ambiguity resolution": "Assume 'group of nations' refers to individual countries and calculate wins for each country.",
        "Data transformations": "df['winner'] = df.apply(lambda row: row['home_team'] if row['home_score'] > row['away_score'] else (row['away_team'] if row['home_score'] < row['away_score'] else 'Draw'), axis=1); win_counts = df[df['winner'] != 'Draw']['winner'].value_counts()",
        "Data transformation operation": [
            "apply",
            "conditional assignment",
            "filter",
            "value counts"
        ],
        "New Column Name": "winner",
        "Derivation Specification": "df['winner'] = df.apply(lambda row: row['home_team'] if row['home_score'] > row['away_score'] else (row['away_team'] if row['home_score'] < row['away_score'] else 'Draw'), axis=1)",
        "Missing Data Column": ""
    },
    {
        "query": "based on the number of matches, can you tell me what the distribution of cities is",
        "Relevant data columns": [
            "city"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df['city'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what group of nations have the most games",
        "Relevant data columns": [
            "home_team",
            "away_team"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear whether 'group of nations' refers to a specific group like a continent or a tournament, or simply all nations grouped together.",
        "Ambiguity resolution": "Assume 'group of nations' refers to aggregating all nations together to count games played by each.",
        "Data transformations": "df['home_team'].append(df['away_team']).value_counts()",
        "Data transformation operation": [
            "append",
            "value_counts"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what countries have won a similar number of games",
        "Relevant data columns": [
            "home_team",
            "away_team",
            "home_score",
            "away_score"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "similarity"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear what constitutes a 'similar number' of wins. Does it mean exactly the same number, within a certain range, or another criterion?",
        "Ambiguity resolution": "Assume 'similar number' means exactly the same number of wins.",
        "Data transformations": "df['winner'] = df.apply(lambda row: row['home_team'] if row['home_score'] > row['away_score'] else (row['away_team'] if row['away_score'] > row['home_score'] else 'Draw'), axis=1); win_counts = df[df['winner'] != 'Draw']['winner'].value_counts(); similar_wins = win_counts[win_counts.duplicated(keep=False)]",
        "Data transformation operation": [
            "apply",
            "value_counts",
            "filter"
        ],
        "New Column Name": "winner",
        "Derivation Specification": "df['winner'] = df.apply(lambda row: row['home_team'] if row['home_score'] > row['away_score'] else (row['away_team'] if row['away_score'] > row['home_score'] else 'Draw'), axis=1)",
        "Missing Data Column": ""
    },
    {
        "query": "how can the population of ashley be illustrated to show distribution across five years",
        "Relevant data columns": [
            "County",
            "July 1, 2002 Population",
            "July 1, 2001 Population",
            "July 1, 2000 Population",
            "April 1, 2000 Population",
            "Census 2000 Population"
        ],
        "Data column classification": [
            "data value mention",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df = df[df['County']=='Ashley'][['County', 'July 1, 2002 Population', 'July 1, 2001 Population', 'July 1, 2000 Population', 'April 1, 2000 Population', 'Census 2000 Population']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how likely is it that, if I was born in 2000, I was born in a county with no less than 20,000 people",
        "Relevant data columns": [
            "July 1, 2000\nPopulation",
            "County"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "filter",
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify whether to consider only the population of counties explicitly listed or to include counties with NaN values.",
        "Ambiguity resolution": "Assume that NaN values in the 'County' column represent aggregated state data or invalid entries and should be excluded from the analysis.",
        "Data transformations": "df = df.dropna(subset=['County']); df['July 1, 2000 Population'] = df['July 1, 2000 Population'].str.replace(',', '').astype(int); total_counties = len(df); counties_above_20000 = len(df[df['July 1, 2000 Population'] >= 20000]); probability = counties_above_20000 / total_counties",
        "Data transformation operation": [
            "filter",
            "convert",
            "calculate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "give me the average population rating for ashley in the year 2000",
        "Relevant data columns": [
            "July 1, 2000\nPopulation",
            "April 1, 2000\nPopulation\nEstimates\nBase",
            "County"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "data value mention"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear whether 'average population rating' refers to an average of multiple population data points within the year 2000 or a specific type of 'rating' not present in the dataset.",
        "Ambiguity resolution": "Assume 'average population rating' refers to the mean of the available population data points for the year 2000.",
        "Data transformations": "df[df['County'] == 'Ashley'][['July 1, 2000\\nPopulation', 'April 1, 2000\\nPopulation\\nEstimates\\nBase']].mean(axis=1)",
        "Data transformation operation": [
            "filter",
            "select",
            "mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "identify the county that has the least population each year",
        "Relevant data columns": [
            "County",
            "July 1, 2002\nPopulation",
            "July 1, 2001\nPopulation",
            "July 1, 2000\nPopulation",
            "April 1, 2000\nPopulation\nEstimates\nBase",
            "Census 2000\nPopulation"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query does not specify if the least population should be identified within each individual year or across all years.",
        "Ambiguity resolution": "Assume the query asks for the county with the least population for each individual year.",
        "Data transformations": "df[['County', 'July 1, 2002\\nPopulation']].nsmallest(1, 'July 1, 2002\\nPopulation'); df[['County', 'July 1, 2001\\nPopulation']].nsmallest(1, 'July 1, 2001\\nPopulation'); df[['County', 'July 1, 2000\\nPopulation']].nsmallest(1, 'July 1, 2000\\nPopulation'); df[['County', 'April 1, 2000\\nPopulation\\nEstimates\\nBase']].nsmallest(1, 'April 1, 2000\\nPopulation\\nEstimates\\nBase'); df[['County', 'Census 2000\\nPopulation']].nsmallest(1, 'Census 2000\\nPopulation')",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the average population in 2000",
        "Relevant data columns": [
            "July 1, 2000\nPopulation",
            "Census 2000\nPopulation"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear which 2000 population data to use for the average calculation, as there are multiple columns referring to the year 2000.",
        "Ambiguity resolution": "Calculate the average for both 'July 1, 2000 Population' and 'Census 2000 Population' to provide a comprehensive answer.",
        "Data transformations": "df[['July 1, 2000\\nPopulation', 'Census 2000\\nPopulation']].replace(',', '', regex=True).astype(float).mean()",
        "Data transformation operation": [
            "select",
            "replace",
            "convert to float",
            "calculate mean"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "from all of the universities in London, list the one who has the most faculties",
        "Relevant data columns": [
            "Location",
            "Num"
        ],
        "Data column classification": [
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain any universities located in London.",
        "Ambiguity resolution": "Inform the user about the absence of London-based universities in the dataset.",
        "Data transformations": "df[df['Location'].str.contains('London')].nlargest(1, 'Num')",
        "Data transformation operation": [
            "filter",
            "find maximum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Location data for London"
    },
    {
        "query": "show me a university that has more than 30 faculties and more than 50 teachers",
        "Relevant data columns": [
            "Name",
            "Num"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "filter"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The query mentions 'more than 50 teachers' but the dataset does not have a column explicitly for teachers. It is unclear if 'Num' refers to the number of faculties or includes teachers.",
        "Ambiguity resolution": "Assuming 'Num' refers to the number of faculties and includes teachers, filter universities with 'Num' greater than 50.",
        "Data transformations": "df[df['Num'] > 50][['Name', 'Num']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Teachers (if 'Num' does not include teachers)"
    },
    {
        "query": "universities with similar number of teachers",
        "Relevant data columns": [
            "Num"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "similarity"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify how close the number of teachers should be to consider them similar.",
        "Ambiguity resolution": "Define a range or threshold for similarity, e.g., universities with a number of teachers within a range of \u00b15 of each other.",
        "Data transformations": "df['Similar_Num_Group'] = pd.cut(df['Num'], bins=pd.interval_range(start=df['Num'].min(), end=df['Num'].max(), freq=5)); grouped_df = df.groupby('Similar_Num_Group')['Name'].apply(list)",
        "Data transformation operation": [
            "binning",
            "groupby"
        ],
        "New Column Name": "Similar_Num_Group",
        "Derivation Specification": "df['Similar_Num_Group'] = pd.cut(df['Num'], bins=pd.interval_range(start=df['Num'].min(), end=df['Num'].max(), freq=5))",
        "Missing Data Column": ""
    },
    {
        "query": "the universities cover which locations",
        "Relevant data columns": [
            "Location"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Location']].drop_duplicates()",
        "Data transformation operation": [
            "select",
            "drop duplicates"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the teacher distribution of new york universities",
        "Relevant data columns": [
            "Location",
            "Num"
        ],
        "Data column classification": [
            "keyword",
            "synonym"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if 'teacher distribution' refers to the number of teachers or a different metric related to teachers, as 'Num' typically represents a count of something but is not explicitly defined as 'number of teachers'.",
        "Ambiguity resolution": "Assuming 'Num' refers to the number of teachers or a similar metric, filter data for New York universities and analyze the distribution of this number.",
        "Data transformations": "df[df['Location'].str.contains('New York')][['Location', 'Num']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Would teachers in Harvard be considered outliers if the university was in New York",
        "Relevant data columns": [
            "Name",
            "Location",
            "Num"
        ],
        "Data column classification": [
            "data value mention",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear what specific metric (e.g., 'Num' or 'Tuition') is being used to determine if teachers are outliers.",
        "Ambiguity resolution": "Assume 'Num' (number of teachers) is the metric for determining outliers since it directly relates to teachers.",
        "Data transformations": "df['Location'] = df['Location'].replace({'Cambridge': 'New York'}) if df['Name'] == 'Harvard University'; outlier_df = df[df['Location'] == 'New York']",
        "Data transformation operation": [
            "replace",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the number of divisions in harvard university",
        "Relevant data columns": [
            "Name",
            "Num"
        ],
        "Data column classification": [
            "data value mention",
            "synonym"
        ],
        "Low-level visualization task": [
            "retrieve value"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'divisions' is ambiguous as it could refer to academic divisions or administrative divisions, and it's unclear if 'Num' directly corresponds to 'divisions'.",
        "Ambiguity resolution": "Assuming 'Num' refers to the number of divisions, directly retrieve the value from the dataset.",
        "Data transformations": "df[df['Name'] == 'Harvard University'][['Name', 'Num']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Is there a regional concentration trend in GDP development",
        "Relevant data columns": [
            "GDP",
            "Country"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what constitutes a 'region' or how 'concentration' should be measured or compared.",
        "Ambiguity resolution": "Assume 'region' refers to the list of countries provided and 'concentration' refers to the distribution and central tendency of GDP values across these countries.",
        "Data transformations": "df[['Country', 'GDP']].sort_values(by='GDP', ascending=False)",
        "Data transformation operation": [
            "select",
            "sort"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "how are gdp and mteu correlated",
        "Relevant data columns": [
            "GDP",
            "mTEU"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "correlation_value = df[['GDP', 'mTEU']].corr()",
        "Data transformation operation": [
            "correlation"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "what is the propensity of the number of vehicles in japan and korea from the year 2000 to 2010",
        "Relevant data columns": [],
        "Data column classification": [],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The dataset provided does not contain information about the number of vehicles, nor does it include data specific to Japan or Korea or any data related to the years 2000 to 2010.",
        "Ambiguity resolution": "Request a dataset that includes the number of vehicles in Japan and Korea from the year 2000 to 2010, or adjust the query to focus on the data available in the current dataset.",
        "Data transformations": "",
        "Data transformation operation": [],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Number of Vehicles, Country, Year"
    },
    {
        "query": "does life expectancy have any relation with the percentage of smokers",
        "Relevant data columns": [
            "Life Expectancy (by years)",
            "Percentage of Smokers"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Life Expectancy (by years)', 'Percentage of Smokers']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is the male to female ratio more imbalanced in the last decade in russia",
        "Relevant data columns": [],
        "Data column classification": [],
        "Low-level visualization task": [
            "compare",
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain any columns related to gender or demographic data specific to Russia or any country.",
        "Ambiguity resolution": "The query cannot be resolved with the current dataset. Additional data regarding gender demographics by country is required.",
        "Data transformations": "",
        "Data transformation operation": [],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Male to Female Ratio"
    },
    {
        "query": "is the speed of economic development relative to the population of each country",
        "Relevant data columns": [
            "Median Income 2007",
            "Population 2007"
        ],
        "Data column classification": [
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'speed of economic development' is ambiguous and not directly represented in the dataset. It is unclear how 'speed' should be measured or calculated from the available data.",
        "Ambiguity resolution": "Assume 'speed of economic development' can be approximated by changes in median income relative to population changes. However, since only one year's data is available, direct calculation of 'speed' or growth rate is not possible without additional temporal data.",
        "Data transformations": "df[['Median Income 2007', 'Population 2007']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Speed of Economic Development"
    },
    {
        "query": "show me the gdp ranking of european countries",
        "Relevant data columns": [],
        "Data column classification": [],
        "Low-level visualization task": [
            "sort"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset does not contain GDP data or information about European countries.",
        "Ambiguity resolution": "Request a dataset that includes GDP data for European countries or modify the query to fit the available data.",
        "Data transformations": "",
        "Data transformation operation": [],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "GDP"
    },
    {
        "query": "to cluster the states in the us, I wish to use middle income",
        "Relevant data columns": [
            "Median Income 2007",
            "State"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "cluster"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'middle income' is ambiguous as it could refer to the median income or a categorization of states into middle-income groups.",
        "Ambiguity resolution": "Assume 'middle income' refers to the 'Median Income 2007' column for clustering.",
        "Data transformations": "df[['State', 'Median Income 2007']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "do all the countries in africa have a lower average pci than all the countries in europe",
        "Relevant data columns": [],
        "Data column classification": [],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query references 'countries in Africa' and 'countries in Europe' and 'average pci', but the dataset provided does not contain information about countries, continents, or per capita income (pci).",
        "Ambiguity resolution": "Clarify the dataset to include or access data that contains information about countries, their continents, and per capita income (pci) to perform the comparison.",
        "Data transformations": "",
        "Data transformation operation": [],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Country, Continent, PCI"
    },
    {
        "query": "could you tell me the continental location of the poorest ( lowest income ) country",
        "Relevant data columns": [
            "Median Income 2007",
            "State"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query refers to 'continental location' which is not a data column in the dataset. Additionally, the term 'country' is used, but the dataset contains U.S. states.",
        "Ambiguity resolution": "Clarify that the dataset contains U.S. states and not countries, and that continental location data is not available. Suggest using 'state' instead of 'country' and omitting the continental location.",
        "Data transformations": "df.loc[df['Median Income 2007'].idxmin(), 'State']",
        "Data transformation operation": [
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Continent"
    },
    {
        "query": "when looking at the average income in european countries, what is the variance",
        "Relevant data columns": [
            "Median Income 2007"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset provided does not include European countries, only states within the United States.",
        "Ambiguity resolution": "Clarify that the dataset only includes data for U.S. states and not European countries. If European data is required, a different dataset should be used.",
        "Data transformations": "",
        "Data transformation operation": "",
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "European countries data"
    },
    {
        "query": "what are the minimum and maximum populations of the chinese provinces",
        "Relevant data columns": [
            "Population 2007"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The dataset provided does not contain data about Chinese provinces, only U.S. states.",
        "Ambiguity resolution": "Clarify that the dataset only includes data for U.S. states and not Chinese provinces. If data on Chinese provinces is required, a different dataset should be used.",
        "Data transformations": "",
        "Data transformation operation": "",
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "Chinese provinces"
    },
    {
        "query": "do countries with high populations wish to slow down population growth",
        "Relevant data columns": [
            "Place",
            "State",
            "July 1, 2002 Population",
            "July 1, 2001 Population",
            "July 1, 2000 Population",
            "April 1, 2000 Population Estimates Base",
            "Census 2000 Population"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query asks about countries, but the dataset is about cities in the United States. It also assumes a desire to slow down population growth without specific data indicating such intentions.",
        "Ambiguity resolution": "Clarify that the data pertains to cities, not countries. To address the query, one might need additional data on policies or intentions regarding population growth control.",
        "Data transformations": "df[['Place', 'State', 'July 1, 2002 Population']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me the state which may have the largest average population in the next year",
        "Relevant data columns": [
            "State",
            "July 1, 2002 Population",
            "July 1, 2001 Population",
            "July 1, 2000 Population",
            "April 1, 2000 Population Estimates Base",
            "Census 2000 Population"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "predict",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query asks for a prediction ('next year') which is not directly supported by the dataset as it only contains historical data up to 2002.",
        "Ambiguity resolution": "Assume a simple model where the future population is estimated based on the average growth rate calculated from the available data.",
        "Data transformations": "df['Average Population'] = df[['July 1, 2002 Population', 'July 1, 2001 Population', 'July 1, 2000 Population', 'April 1, 2000 Population Estimates Base', 'Census 2000 Population']].mean(axis=1); df.groupby('State')['Average Population'].mean().idxmax()",
        "Data transformation operation": [
            "calculate mean",
            "groupby",
            "aggregate"
        ],
        "New Column Name": "Average Population",
        "Derivation Specification": "df['Average Population'] = df[['July 1, 2002 Population', 'July 1, 2001 Population', 'July 1, 2000 Population', 'April 1, 2000 Population Estimates Base', 'Census 2000 Population']].mean(axis=1)",
        "Missing Data Column": ""
    },
    {
        "query": "Are the students who are younger more likely to use WeChat",
        "Relevant data columns": [
            "age",
            "social App"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify what age range is considered 'younger', nor does it clarify how to measure 'more likely'.",
        "Ambiguity resolution": "Assume 'younger' refers to below the median age of the dataset. Calculate the proportion of users using WeChat among the younger group versus the older group.",
        "Data transformations": "df['Younger'] = df['age'] < df['age'].median(); wechat_usage = df.groupby('Younger')['social App'].apply(lambda x: (x == 'wechat').mean())",
        "Data transformation operation": [
            "groupby",
            "apply"
        ],
        "New Column Name": "Younger",
        "Derivation Specification": "df['Younger'] = df['age'] < df['age'].median()",
        "Missing Data Column": ""
    },
    {
        "query": "which movie is the highest-grossing",
        "Relevant data columns": [
            "Movie",
            "Revenue ($)"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.loc[df['Revenue ($)'].idxmax(), ['Movie', 'Revenue ($)']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "can you tell me if there is a correlation between revenue and the release year",
        "Relevant data columns": [
            "Revenue ($)",
            "Release Year"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df[['Release Year', 'Revenue ($)']]",
        "Data transformation operation": [
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "is there a typical film lengths group",
        "Relevant data columns": [
            "type"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query mentions 'film lengths group' but the dataset does not contain a column explicitly for 'film length' or 'duration'. It is unclear what 'type' refers to without additional context.",
        "Ambiguity resolution": "Assuming 'type' might refer to categories or groups of films which could indirectly relate to film lengths. If 'type' is not relevant, additional data on film lengths would be required.",
        "Data transformations": "df['type'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": "film length"
    },
    {
        "query": "the chart teaches them the horsepower range",
        "Relevant data columns": [
            "horsepower"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "determine range"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the range should be calculated for each product category or for the entire dataset.",
        "Ambiguity resolution": "Assume the range is needed for the entire dataset unless specified otherwise.",
        "Data transformations": "df['horsepower'].agg(['min', 'max'])",
        "Data transformation operation": [
            "aggregate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the relationship between level of education and crime rate",
        "Relevant data columns": [
            "education",
            "incident_id"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The term 'crime rate' is ambiguous as it is not directly represented in the dataset. It needs to be defined or approximated from available data.",
        "Ambiguity resolution": "Assume 'crime rate' can be approximated by the count of incidents per education level.",
        "Data transformations": "df.groupby('education').size().reset_index(name='crime_rate')",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "crime_rate",
        "Derivation Specification": "crime_rate = count of incidents per education level",
        "Missing Data Column": ""
    },
    {
        "query": "Are there any visible trends in violent crime rates over the time period",
        "Relevant data columns": [
            "year",
            "intent"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "It is unclear what specific types of violent crimes are to be included in the trend analysis.",
        "Ambiguity resolution": "Assume violent crimes include intents such as 'Homicide', 'Assault', etc., and filter data accordingly.",
        "Data transformations": "df_violent = df[df['intent'].isin(['Homicide', 'Assault'])]; trend_data = df_violent.groupby('year')['intent'].count()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the most frequent place of violent crime",
        "Relevant data columns": [
            "place",
            "intent"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "The term 'violent crime' is ambiguous as it is not explicitly defined in the dataset.",
        "Ambiguity resolution": "Assume 'violent crime' refers to intents such as 'Homicide', 'Assault', etc., and filter data accordingly before finding the most frequent place.",
        "Data transformations": "df[df['intent'].isin(['Homicide', 'Assault'])]['place'].value_counts().idxmax()",
        "Data transformation operation": [
            "filter",
            "count",
            "find maximum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Are there any correlations between crime types and geographic location",
        "Relevant data columns": [
            "intent",
            "state",
            "city_or_county"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "exploratory",
        "Ambiguity in the query": "The query does not specify what type of correlation is being sought (e.g., statistical correlation, visual patterns) or how geographic location is defined (state, city, or both).",
        "Ambiguity resolution": "Assume correlation is statistical and involves both state and city as geographic locations.",
        "Data transformations": "df[['intent', 'state', 'city_or_county']].dropna()",
        "Data transformation operation": [
            "select",
            "drop missing values"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the distribution for non-violent crimes based on age",
        "Relevant data columns": [
            "age",
            "intent"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'non-violent crimes' is not explicitly defined in the dataset, and it's unclear which 'intent' categories should be considered non-violent.",
        "Ambiguity resolution": "Assume non-violent crimes include categories like 'Suicide', 'Accidental', and 'Undetermined' based on common interpretations of non-violent versus violent crimes.",
        "Data transformations": "df = df[df['intent'].isin(['Suicide', 'Accidental', 'Undetermined'])]; df[['age', 'intent']]",
        "Data transformation operation": [
            "filter",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Are there any correlations in violent or non-violent crimes based on congressional district and year",
        "Relevant data columns": [
            "congressional_district",
            "year",
            "incident_characteristics"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what defines 'violent' or 'non-violent' crimes within the dataset.",
        "Ambiguity resolution": "Assume definitions for 'violent' and 'non-violent' based on the 'incident_characteristics' descriptions or create categories based on common crime types mentioned.",
        "Data transformations": "df['violent'] = df['incident_characteristics'].str.contains('murder|suicide|Homicide|Assault|Robbery|Shooting'); df['non_violent'] = ~df['violent']; correlation_data = df.groupby(['year', 'congressional_district']).agg({'violent': 'sum', 'non_violent': 'sum'})",
        "Data transformation operation": [
            "filter",
            "groupby",
            "sum"
        ],
        "New Column Name": "violent, non_violent",
        "Derivation Specification": "df['violent'] = df['incident_characteristics'].str.contains('murder|suicide|Homicide|Assault|Robbery|Shooting'); df['non_violent'] = ~df['violent']",
        "Missing Data Column": ""
    },
    {
        "query": "Is there a somewhat even distribution between the year and congressional district",
        "Relevant data columns": [
            "year",
            "congressional_district"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify what 'somewhat even distribution' means quantitatively or how to measure evenness.",
        "Ambiguity resolution": "Assume 'somewhat even distribution' means checking if each congressional district has a roughly similar number of incidents each year. Use statistical measures like standard deviation or variance to assess the evenness.",
        "Data transformations": "df.groupby(['year', 'congressional_district']).size().unstack(fill_value=0)",
        "Data transformation operation": [
            "groupby",
            "size",
            "unstack"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What city has the highest crime rate",
        "Relevant data columns": [
            "city_or_county",
            "incident_id"
        ],
        "Data column classification": [
            "keyword",
            "inferred"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The term 'crime rate' is ambiguous without knowing the population or the time frame over which to calculate the rate.",
        "Ambiguity resolution": "Assume total number of incidents per city as a proxy for crime rate, or require additional data such as population or time frame for accurate calculation.",
        "Data transformations": "df.groupby('city_or_county').size().nlargest(1)",
        "Data transformation operation": [
            "groupby",
            "size",
            "nlargest"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many gun violence incidents are there each year",
        "Relevant data columns": [
            "year"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "retrieve value",
            "trend"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('year').size()",
        "Data transformation operation": [
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Are there any significant correlations between any 2 variables in the dataset",
        "Relevant data columns": [
            "year",
            "month",
            "intent",
            "police",
            "sex",
            "age",
            "race",
            "hispanic",
            "place",
            "education"
        ],
        "Data column classification": [
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "correlate",
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": [
            "exploratory"
        ],
        "Ambiguity in the query": "The query does not specify which variables to consider for correlation, nor does it define what constitutes 'significant'.",
        "Ambiguity resolution": "Assume all numerical and categorical variables are to be considered; use statistical methods to determine significance, such as Pearson for numerical and Chi-squared test for categorical variables.",
        "Data transformations": "correlation_matrix = df.corr(method='pearson'); significant_correlations = correlation_matrix[correlation_matrix.abs() > 0.5]",
        "Data transformation operation": [
            "correlation calculation",
            "filter"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "How many incidents of gun violence result in death (Ie what proportion are fatal vs non-fatal)",
        "Relevant data columns": [
            "n_killed"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compute derived value",
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear whether incidents resulting in death should include those with at least one death or only those with deaths exclusively.",
        "Ambiguity resolution": "Assume any incident with one or more deaths is considered fatal.",
        "Data transformations": "total_incidents = len(df); fatal_incidents = len(df[df['n_killed'] > 0]); non_fatal_incidents = total_incidents - fatal_incidents; proportion_fatal = fatal_incidents / total_incidents; proportion_non_fatal = non_fatal_incidents / total_incidents",
        "Data transformation operation": [
            "filter",
            "calculate"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What\u2019s the frequency of gun violence incidents with multiple victims",
        "Relevant data columns": [
            "incident_characteristics"
        ],
        "Data column classification": [
            "inferred"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify what counts as 'multiple victims'. It could mean more than one victim, or it could refer to a specific threshold like mass shootings.",
        "Ambiguity resolution": "Assume 'multiple victims' means more than one victim. Filter incidents where characteristics include terms like 'wounded', 'injured', 'killed', excluding single victim scenarios.",
        "Data transformations": "df['multiple_victims'] = df['incident_characteristics'].str.contains('wounded|injured|killed', case=False, na=False); df_multiple_victims = df[df['multiple_victims']]; frequency = df_multiple_victims['incident_characteristics'].value_counts()",
        "Data transformation operation": [
            "filter",
            "count"
        ],
        "New Column Name": "multiple_victims",
        "Derivation Specification": "df['multiple_victims'] = df['incident_characteristics'].str.contains('wounded|injured|killed', case=False, na=False)",
        "Missing Data Column": ""
    },
    {
        "query": "Are males or females more likely to die of gun violence",
        "Relevant data columns": [
            "sex",
            "n_killed"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "",
        "Ambiguity resolution": "",
        "Data transformations": "df.groupby('sex')['n_killed'].sum()",
        "Data transformation operation": [
            "groupby",
            "sum"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Is one sex more likely to perpetrate gun violence",
        "Relevant data columns": [
            "sex"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify the type of gun violence (e.g., homicide, suicide, accidental) or if it should be aggregated over all incidents or broken down by year, location, etc.",
        "Ambiguity resolution": "Assume the query refers to all types of gun violence aggregated over all available data unless specified otherwise.",
        "Data transformations": "df['sex'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Is more gun violence committed with stolen guns or non stolen guns",
        "Relevant data columns": [
            "gun_stolen",
            "n_killed",
            "n_injured"
        ],
        "Data column classification": [
            "keyword",
            "inferred",
            "inferred"
        ],
        "Low-level visualization task": [
            "compare"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify what constitutes 'more gun violence'\u2014whether it refers to the number of incidents, the number of people killed, or the number of people injured.",
        "Ambiguity resolution": "Assume 'more gun violence' refers to the total number of victims (both killed and injured) in incidents involving stolen vs. non-stolen guns.",
        "Data transformations": "df['total_victims'] = df['n_killed'] + df['n_injured']; stolen_stats = df[df['gun_stolen']=='Stolen']['total_victims'].sum(); non_stolen_stats = df[df['gun_stolen']=='Not-stolen']['total_victims'].sum()",
        "Data transformation operation": [
            "new column creation",
            "filter",
            "sum"
        ],
        "New Column Name": "total_victims",
        "Derivation Specification": "df['total_victims'] = df['n_killed'] + df['n_injured']",
        "Missing Data Column": ""
    },
    {
        "query": "How have homicide rates increased over time",
        "Relevant data columns": [
            "Years",
            "Homicide (People)"
        ],
        "Data column classification": [
            "inferred",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for global trends or specific to a country or region, and whether adjustments for population changes are expected.",
        "Ambiguity resolution": "Assume a global trend analysis without adjustments for population unless specified.",
        "Data transformations": "df = df[['Years', 'Homicide (People)']].dropna()",
        "Data transformation operation": [
            "select",
            "dropna"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What type of gun violence has seen the most growth over the years",
        "Relevant data columns": [
            "Years",
            "Firearm deaths (People)",
            "Homicide (People)",
            "Suicide (People)",
            "Unintentional (People)",
            "Legal intervention (People)",
            "Undetermined (People)"
        ],
        "Data column classification": [
            "inferred",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "trend",
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "keyword",
            "inferred"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear if the query is asking for absolute numbers or percentage growth, and whether it includes all types of gun violence or specific categories.",
        "Ambiguity resolution": "Assume the query asks for percentage growth for each category of gun violence to identify which category has the highest growth rate.",
        "Data transformations": "df = df.set_index('Years'); growth_rates = df.pct_change().mean() * 100",
        "Data transformation operation": [
            "set_index",
            "percentage change",
            "mean",
            "multiply"
        ],
        "New Column Name": "growth_rate",
        "Derivation Specification": "growth_rate = df.pct_change().mean() * 100",
        "Missing Data Column": ""
    },
    {
        "query": "Are most gun death because of suicide",
        "Relevant data columns": [
            "intent"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution",
            "find anomalies"
        ],
        "Low-level visualization task classification": [
            "inferred",
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "It is unclear if the query is asking for a specific time period or location, or if it encompasses all data available.",
        "Ambiguity resolution": "Assume the query refers to all data available unless specified otherwise.",
        "Data transformations": "df['intent'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Did most gun violence happen inside home",
        "Relevant data columns": [
            "place"
        ],
        "Data column classification": [
            "keyword"
        ],
        "Low-level visualization task": [
            "characterize distribution"
        ],
        "Low-level visualization task classification": [
            "inferred"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify the time frame or geographical scope for analyzing gun violence incidents.",
        "Ambiguity resolution": "Assume analysis over the entire dataset and all available locations.",
        "Data transformations": "df['place'].value_counts()",
        "Data transformation operation": [
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "What is the correlation between education levels and suicide rates",
        "Relevant data columns": [
            "education",
            "intent"
        ],
        "Data column classification": [
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "correlate"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": [
            "targeted"
        ],
        "Ambiguity in the query": "The query does not specify the time frame or demographic details (like age, race, or sex) for which the correlation should be analyzed.",
        "Ambiguity resolution": "Assume the correlation is to be analyzed across all available data without filtering for specific demographics or time frames unless specified.",
        "Data transformations": "df_suicide = df[df['intent'] == 'Suicide']; correlation_data = df_suicide.groupby('education').size()",
        "Data transformation operation": [
            "filter",
            "groupby",
            "count"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    },
    {
        "query": "Which state/year has the most gun deaths",
        "Relevant data columns": [
            "state",
            "year",
            "n_killed"
        ],
        "Data column classification": [
            "keyword",
            "keyword",
            "keyword"
        ],
        "Low-level visualization task": [
            "find extremum"
        ],
        "Low-level visualization task classification": [
            "keyword"
        ],
        "Visualization goal": "targeted",
        "Ambiguity in the query": "It is unclear whether the query is asking for the state with the most gun deaths for each year, or the state/year combination with the highest number of gun deaths overall.",
        "Ambiguity resolution": "Assume the query is asking for the state/year combination with the highest number of gun deaths overall. If needed, also provide the state with the most gun deaths for each year.",
        "Data transformations": "df.groupby(['state', 'year'])['n_killed'].sum().reset_index().sort_values('n_killed', ascending=False).head(1)",
        "Data transformation operation": [
            "groupby",
            "sum",
            "sort",
            "select"
        ],
        "New Column Name": "",
        "Derivation Specification": "",
        "Missing Data Column": ""
    }
]